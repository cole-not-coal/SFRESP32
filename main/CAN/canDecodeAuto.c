/* This file is autogenerated from the script decodeCAN.py */
#include "canDecodeAuto.h"

uint8_t BRestart = 0;
uint8_t BClearMinMax = 0;
uint8_t BClearErrors = 0;
float tLastTaskTime1msTelemCar = 0;
float tMaxTaskTime1msTelemCar = 0;
float tLastTaskTime100msTelemCar = 0;
float tMaxTaskTime100msTelemCar = 0;
float tLastTaskTimeBGTelemCar = 0;
float tMaxTaskTimeBGTelemCar = 0;
float tSincePowerUpTelemCar = 0;
uint8_t NLastResetReasonTelemCar = 0;
float tLastTaskTime1msTelemPits = 0;
float tMaxTaskTime1msTelemPits = 0;
float tLastTaskTime100msTelemPits = 0;
float tMaxTaskTime100msTelemPits = 0;
float tLastTaskTimeBGTelemPits = 0;
float tMaxTaskTimeBGTelemPits = 0;
float tSincePowerUpTelemPits = 0;
uint8_t NLastResetReasonTelemPits = 0;
float tLastTaskTime1msIMDMon = 0;
float tMaxTaskTime1msIMDMon = 0;
float tLastTaskTime100msIMDMon = 0;
float tMaxTaskTime100msIMDMon = 0;
float tLastTaskTimeBGIMDMon = 0;
float tMaxTaskTimeBGIMDMon = 0;
float tSincePowerUpIMDMon = 0;
uint8_t NLastResetReasonIMDMon = 0;
float tLastTaskTime1msLogger = 0;
float tMaxTaskTime1msLogger = 0;
float tLastTaskTime100msLogger = 0;
float tMaxTaskTime100msLogger = 0;
float tLastTaskTimeBGLogger = 0;
float tMaxTaskTimeBGLogger = 0;
float tSincePowerUpLogger = 0;
uint8_t NLastResetReasonLogger = 0;
float tLastTaskTime1msPDU = 0;
float tMaxTaskTime1msPDU = 0;
float tLastTaskTime100msPDU = 0;
float tMaxTaskTime100msPDU = 0;
float tLastTaskTimeBGPDU = 0;
float tMaxTaskTimeBGPDU = 0;
float tSincePowerUpPDU = 0;
uint8_t NLastResetReasonPDU = 0;
float tLastTaskTime1msAPPS = 0;
float tMaxTaskTime1msAPPS = 0;
float tLastTaskTime100msAPPS = 0;
float tMaxTaskTime100msAPPS = 0;
float tLastTaskTimeBGAPPS = 0;
float tMaxTaskTimeBGAPPS = 0;
float tSincePowerUpAPPS = 0;
uint8_t NLastResetReasonAPPS = 0;
float tLastTaskTime1msScreen = 0;
float tMaxTaskTime1msScreen = 0;
float tLastTaskTime100msScreen = 0;
float tMaxTaskTime100msScreen = 0;
float tLastTaskTimeBGScreen = 0;
float tMaxTaskTimeBGScreen = 0;
float tSincePowerUpScreen = 0;
uint8_t NLastResetReasonScreen = 0;
float tLastTaskTime1msDash = 0;
float tMaxTaskTime1msDash = 0;
float tLastTaskTime100msDash = 0;
float tMaxTaskTime100msDash = 0;
float tLastTaskTimeBGDash = 0;
float tMaxTaskTimeBGDash = 0;
float tSincePowerUpDash = 0;
uint8_t NLastResetReasonDash = 0;
float tLastTaskTime1msDyno = 0;
float tMaxTaskTime1msDyno = 0;
float tLastTaskTime100msDyno = 0;
float tMaxTaskTime100msDyno = 0;
float tLastTaskTimeBGDyno = 0;
float tMaxTaskTimeBGDyno = 0;
float tSincePowerUpDyno = 0;
uint8_t NLastResetReasonDyno = 0;
float CMD_TargetAcCurrent = 0;
uint8_t CellID = 0;
float VCell001 = 0;
float VCell002 = 0;
float VCell003 = 0;
float VCell004 = 0;
float VCell005 = 0;
float VCell006 = 0;
float VCell007 = 0;
float VCell008 = 0;
float VCell009 = 0;
float VCell010 = 0;
float VCell011 = 0;
float VCell012 = 0;
float VCell013 = 0;
float VCell014 = 0;
float VCell015 = 0;
float VCell016 = 0;
float VCell017 = 0;
float VCell018 = 0;
float VCell019 = 0;
float VCell020 = 0;
float VCell021 = 0;
float VCell022 = 0;
float VCell023 = 0;
float VCell024 = 0;
float VCell025 = 0;
float VCell026 = 0;
float VCell027 = 0;
float VCell028 = 0;
float VCell029 = 0;
float VCell030 = 0;
float VCell031 = 0;
float VCell032 = 0;
float VCell033 = 0;
float VCell034 = 0;
float VCell035 = 0;
float VCell036 = 0;
float VCell037 = 0;
float VCell038 = 0;
float VCell039 = 0;
float VCell040 = 0;
float VCell041 = 0;
float VCell042 = 0;
float VCell043 = 0;
float VCell044 = 0;
float VCell045 = 0;
float VCell046 = 0;
float VCell047 = 0;
float VCell048 = 0;
float VCell049 = 0;
float VCell050 = 0;
float VCell051 = 0;
float VCell052 = 0;
float VCell053 = 0;
float VCell054 = 0;
float VCell055 = 0;
float VCell056 = 0;
float VCell057 = 0;
float VCell058 = 0;
float VCell059 = 0;
float VCell060 = 0;
float VCell061 = 0;
float VCell062 = 0;
float VCell063 = 0;
float VCell064 = 0;
float VCell065 = 0;
float VCell066 = 0;
float VCell067 = 0;
float VCell068 = 0;
float VCell069 = 0;
float VCell070 = 0;
float VCell071 = 0;
float VCell072 = 0;
float VCell073 = 0;
float VCell074 = 0;
float VCell075 = 0;
float VCell076 = 0;
float VCell077 = 0;
float VCell078 = 0;
float VCell079 = 0;
float VCell080 = 0;
float VCell081 = 0;
float VCell082 = 0;
float VCell083 = 0;
float VCell084 = 0;
float VCell085 = 0;
float VCell086 = 0;
float VCell087 = 0;
float VCell088 = 0;
float VCell089 = 0;
float VCell090 = 0;
float VCell091 = 0;
float VCell092 = 0;
float VCell093 = 0;
float VCell094 = 0;
float VCell095 = 0;
float VCell096 = 0;
float VCell097 = 0;
float VCell098 = 0;
float VCell099 = 0;
float VCell100 = 0;
float VCell101 = 0;
float VCell102 = 0;
float VCell103 = 0;
float VCell104 = 0;
float VCell105 = 0;
float VCell106 = 0;
float VCell107 = 0;
float VCell108 = 0;
float VCell109 = 0;
float VCell110 = 0;
float VCell111 = 0;
float VCell112 = 0;
float RCell001 = 0;
float RCell002 = 0;
float RCell003 = 0;
float RCell004 = 0;
float RCell005 = 0;
float RCell006 = 0;
float RCell007 = 0;
float RCell008 = 0;
float RCell009 = 0;
float RCell010 = 0;
float RCell011 = 0;
float RCell012 = 0;
float RCell013 = 0;
float RCell014 = 0;
float RCell015 = 0;
float RCell016 = 0;
float RCell017 = 0;
float RCell018 = 0;
float RCell019 = 0;
float RCell020 = 0;
float RCell021 = 0;
float RCell022 = 0;
float RCell023 = 0;
float RCell024 = 0;
float RCell025 = 0;
float RCell026 = 0;
float RCell027 = 0;
float RCell028 = 0;
float RCell029 = 0;
float RCell030 = 0;
float RCell031 = 0;
float RCell032 = 0;
float RCell033 = 0;
float RCell034 = 0;
float RCell035 = 0;
float RCell036 = 0;
float RCell037 = 0;
float RCell038 = 0;
float RCell039 = 0;
float RCell040 = 0;
float RCell041 = 0;
float RCell042 = 0;
float RCell043 = 0;
float RCell044 = 0;
float RCell045 = 0;
float RCell046 = 0;
float RCell047 = 0;
float RCell048 = 0;
float RCell049 = 0;
float RCell050 = 0;
float RCell051 = 0;
float RCell052 = 0;
float RCell053 = 0;
float RCell054 = 0;
float RCell055 = 0;
float RCell056 = 0;
float RCell057 = 0;
float RCell058 = 0;
float RCell059 = 0;
float RCell060 = 0;
float RCell061 = 0;
float RCell062 = 0;
float RCell063 = 0;
float RCell064 = 0;
float RCell065 = 0;
float RCell066 = 0;
float RCell067 = 0;
float RCell068 = 0;
float RCell069 = 0;
float RCell070 = 0;
float RCell071 = 0;
float RCell072 = 0;
float RCell073 = 0;
float RCell074 = 0;
float RCell075 = 0;
float RCell076 = 0;
float RCell077 = 0;
float RCell078 = 0;
float RCell079 = 0;
float RCell080 = 0;
float RCell081 = 0;
float RCell082 = 0;
float RCell083 = 0;
float RCell084 = 0;
float RCell085 = 0;
float RCell086 = 0;
float RCell087 = 0;
float RCell088 = 0;
float RCell089 = 0;
float RCell090 = 0;
float RCell091 = 0;
float RCell092 = 0;
float RCell093 = 0;
float RCell094 = 0;
float RCell095 = 0;
float RCell096 = 0;
float RCell097 = 0;
float RCell098 = 0;
float RCell099 = 0;
float RCell100 = 0;
float RCell101 = 0;
float RCell102 = 0;
float RCell103 = 0;
float RCell104 = 0;
float RCell105 = 0;
float RCell106 = 0;
float RCell107 = 0;
float RCell108 = 0;
float RCell109 = 0;
float RCell110 = 0;
float RCell111 = 0;
float RCell112 = 0;
uint8_t BBalancingCell001 = 0;
uint8_t BBalancingCell002 = 0;
uint8_t BBalancingCell003 = 0;
uint8_t BBalancingCell004 = 0;
uint8_t BBalancingCell005 = 0;
uint8_t BBalancingCell006 = 0;
uint8_t BBalancingCell007 = 0;
uint8_t BBalancingCell008 = 0;
uint8_t BBalancingCell009 = 0;
uint8_t BBalancingCell010 = 0;
uint8_t BBalancingCell011 = 0;
uint8_t BBalancingCell012 = 0;
uint8_t BBalancingCell013 = 0;
uint8_t BBalancingCell014 = 0;
uint8_t BBalancingCell015 = 0;
uint8_t BBalancingCell016 = 0;
uint8_t BBalancingCell017 = 0;
uint8_t BBalancingCell018 = 0;
uint8_t BBalancingCell019 = 0;
uint8_t BBalancingCell020 = 0;
uint8_t BBalancingCell021 = 0;
uint8_t BBalancingCell022 = 0;
uint8_t BBalancingCell023 = 0;
uint8_t BBalancingCell024 = 0;
uint8_t BBalancingCell025 = 0;
uint8_t BBalancingCell026 = 0;
uint8_t BBalancingCell027 = 0;
uint8_t BBalancingCell028 = 0;
uint8_t BBalancingCell029 = 0;
uint8_t BBalancingCell030 = 0;
uint8_t BBalancingCell031 = 0;
uint8_t BBalancingCell032 = 0;
uint8_t BBalancingCell033 = 0;
uint8_t BBalancingCell034 = 0;
uint8_t BBalancingCell035 = 0;
uint8_t BBalancingCell036 = 0;
uint8_t BBalancingCell037 = 0;
uint8_t BBalancingCell038 = 0;
uint8_t BBalancingCell039 = 0;
uint8_t BBalancingCell040 = 0;
uint8_t BBalancingCell041 = 0;
uint8_t BBalancingCell042 = 0;
uint8_t BBalancingCell043 = 0;
uint8_t BBalancingCell044 = 0;
uint8_t BBalancingCell045 = 0;
uint8_t BBalancingCell046 = 0;
uint8_t BBalancingCell047 = 0;
uint8_t BBalancingCell048 = 0;
uint8_t BBalancingCell049 = 0;
uint8_t BBalancingCell050 = 0;
uint8_t BBalancingCell051 = 0;
uint8_t BBalancingCell052 = 0;
uint8_t BBalancingCell053 = 0;
uint8_t BBalancingCell054 = 0;
uint8_t BBalancingCell055 = 0;
uint8_t BBalancingCell056 = 0;
uint8_t BBalancingCell057 = 0;
uint8_t BBalancingCell058 = 0;
uint8_t BBalancingCell059 = 0;
uint8_t BBalancingCell060 = 0;
uint8_t BBalancingCell061 = 0;
uint8_t BBalancingCell062 = 0;
uint8_t BBalancingCell063 = 0;
uint8_t BBalancingCell064 = 0;
uint8_t BBalancingCell065 = 0;
uint8_t BBalancingCell066 = 0;
uint8_t BBalancingCell067 = 0;
uint8_t BBalancingCell068 = 0;
uint8_t BBalancingCell069 = 0;
uint8_t BBalancingCell070 = 0;
uint8_t BBalancingCell071 = 0;
uint8_t BBalancingCell072 = 0;
uint8_t BBalancingCell073 = 0;
uint8_t BBalancingCell074 = 0;
uint8_t BBalancingCell075 = 0;
uint8_t BBalancingCell076 = 0;
uint8_t BBalancingCell077 = 0;
uint8_t BBalancingCell078 = 0;
uint8_t BBalancingCell079 = 0;
uint8_t BBalancingCell080 = 0;
uint8_t BBalancingCell081 = 0;
uint8_t BBalancingCell082 = 0;
uint8_t BBalancingCell083 = 0;
uint8_t BBalancingCell084 = 0;
uint8_t BBalancingCell085 = 0;
uint8_t BBalancingCell086 = 0;
uint8_t BBalancingCell087 = 0;
uint8_t BBalancingCell088 = 0;
uint8_t BBalancingCell089 = 0;
uint8_t BBalancingCell090 = 0;
uint8_t BBalancingCell091 = 0;
uint8_t BBalancingCell092 = 0;
uint8_t BBalancingCell093 = 0;
uint8_t BBalancingCell094 = 0;
uint8_t BBalancingCell095 = 0;
uint8_t BBalancingCell096 = 0;
uint8_t BBalancingCell097 = 0;
uint8_t BBalancingCell098 = 0;
uint8_t BBalancingCell099 = 0;
uint8_t BBalancingCell100 = 0;
uint8_t BBalancingCell101 = 0;
uint8_t BBalancingCell102 = 0;
uint8_t BBalancingCell103 = 0;
uint8_t BBalancingCell104 = 0;
uint8_t BBalancingCell105 = 0;
uint8_t BBalancingCell106 = 0;
uint8_t BBalancingCell107 = 0;
uint8_t BBalancingCell108 = 0;
uint8_t BBalancingCell109 = 0;
uint8_t BBalancingCell110 = 0;
uint8_t BBalancingCell111 = 0;
uint8_t BBalancingCell112 = 0;
float VOpenCell001 = 0;
float VOpenCell002 = 0;
float VOpenCell003 = 0;
float VOpenCell004 = 0;
float VOpenCell005 = 0;
float VOpenCell006 = 0;
float VOpenCell007 = 0;
float VOpenCell008 = 0;
float VOpenCell009 = 0;
float VOpenCell010 = 0;
float VOpenCell011 = 0;
float VOpenCell012 = 0;
float VOpenCell013 = 0;
float VOpenCell014 = 0;
float VOpenCell015 = 0;
float VOpenCell016 = 0;
float VOpenCell017 = 0;
float VOpenCell018 = 0;
float VOpenCell019 = 0;
float VOpenCell020 = 0;
float VOpenCell021 = 0;
float VOpenCell022 = 0;
float VOpenCell023 = 0;
float VOpenCell024 = 0;
float VOpenCell025 = 0;
float VOpenCell026 = 0;
float VOpenCell027 = 0;
float VOpenCell028 = 0;
float VOpenCell029 = 0;
float VOpenCell030 = 0;
float VOpenCell031 = 0;
float VOpenCell032 = 0;
float VOpenCell033 = 0;
float VOpenCell034 = 0;
float VOpenCell035 = 0;
float VOpenCell036 = 0;
float VOpenCell037 = 0;
float VOpenCell038 = 0;
float VOpenCell039 = 0;
float VOpenCell040 = 0;
float VOpenCell041 = 0;
float VOpenCell042 = 0;
float VOpenCell043 = 0;
float VOpenCell044 = 0;
float VOpenCell045 = 0;
float VOpenCell046 = 0;
float VOpenCell047 = 0;
float VOpenCell048 = 0;
float VOpenCell049 = 0;
float VOpenCell050 = 0;
float VOpenCell051 = 0;
float VOpenCell052 = 0;
float VOpenCell053 = 0;
float VOpenCell054 = 0;
float VOpenCell055 = 0;
float VOpenCell056 = 0;
float VOpenCell057 = 0;
float VOpenCell058 = 0;
float VOpenCell059 = 0;
float VOpenCell060 = 0;
float VOpenCell061 = 0;
float VOpenCell062 = 0;
float VOpenCell063 = 0;
float VOpenCell064 = 0;
float VOpenCell065 = 0;
float VOpenCell066 = 0;
float VOpenCell067 = 0;
float VOpenCell068 = 0;
float VOpenCell069 = 0;
float VOpenCell070 = 0;
float VOpenCell071 = 0;
float VOpenCell072 = 0;
float VOpenCell073 = 0;
float VOpenCell074 = 0;
float VOpenCell075 = 0;
float VOpenCell076 = 0;
float VOpenCell077 = 0;
float VOpenCell078 = 0;
float VOpenCell079 = 0;
float VOpenCell080 = 0;
float VOpenCell081 = 0;
float VOpenCell082 = 0;
float VOpenCell083 = 0;
float VOpenCell084 = 0;
float VOpenCell085 = 0;
float VOpenCell086 = 0;
float VOpenCell087 = 0;
float VOpenCell088 = 0;
float VOpenCell089 = 0;
float VOpenCell090 = 0;
float VOpenCell091 = 0;
float VOpenCell092 = 0;
float VOpenCell093 = 0;
float VOpenCell094 = 0;
float VOpenCell095 = 0;
float VOpenCell096 = 0;
float VOpenCell097 = 0;
float VOpenCell098 = 0;
float VOpenCell099 = 0;
float VOpenCell100 = 0;
float VOpenCell101 = 0;
float VOpenCell102 = 0;
float VOpenCell103 = 0;
float VOpenCell104 = 0;
float VOpenCell105 = 0;
float VOpenCell106 = 0;
float VOpenCell107 = 0;
float VOpenCell108 = 0;
float VOpenCell109 = 0;
float VOpenCell110 = 0;
float VOpenCell111 = 0;
float VOpenCell112 = 0;
uint8_t CheckSum_CellVoltages = 0;
uint8_t BIMDOff = 0;
uint8_t BIMDUndervoltage = 0;
uint8_t BIMDStarting = 0;
uint8_t BIMDSSTGood = 0;
uint8_t BIMDDeviceError = 0;
uint8_t BIMDGroundConnectionFault = 0;
uint8_t BIMDInvalidState = 0;
float RIsolation = 0;
float CMD_TargetBrakeCurrent = 0;
int32_t CMD_TargetSpeed = 0;
int8_t rAPPs1 = 0;
int8_t rAPPs2 = 0;
int8_t rAPPsFinal = 0;
uint8_t BThrottleOK = 0;
uint8_t BAPPS1Fail = 0;
uint8_t BAPPS2Fail = 0;
uint8_t BAPPSDrift = 0;
float CMD_TargetPosition = 0;
float VDynoPressure1Raw = 0;
float VDynoPressure2Raw = 0;
float VDynoPressure3Raw = 0;
float VDynoCoolantFlowRaw = 0;
float VDynoTemp1Raw = 0;
float VDynoTemp2Raw = 0;
float VDynoTemp3Raw = 0;
float pDynoPressure1 = 0;
float pDynoPressure2 = 0;
float pDynoPressure3 = 0;
float VDynoCoolantFlow = 0;
float TDynoTemp1 = 0;
float TDynoTemp2 = 0;
float TDynoTemp3 = 0;
float CMD_TargetRelativeCurrent = 0;
float CMD_TargeRelativeBrakeCurrent = 0;
uint8_t CMD_SetDigOutput4 = 0;
uint8_t CMD_SetDigOutput3 = 0;
uint8_t CMD_SetDigOutput2 = 0;
uint8_t CMD_SetDigOutput1 = 0;
float CMD_MaxAcCurrent = 0;
float CMD_MaxAcBrakeCurrent = 0;
float CMD_MaxDcCurrent = 0;
float CMD_MaxDcBrakeCurrent = 0;
uint8_t CMD_DriveEnable = 0;
float TFRTireChannel01 = 0;
float TFRTireChannel02 = 0;
float TFRTireChannel03 = 0;
float TFRTireChannel04 = 0;
float TFRTireChannel05 = 0;
float TFRTireChannel06 = 0;
float TFRTireChannel07 = 0;
float TFRTireChannel08 = 0;
float TFRTireChannel09 = 0;
float TFRTireChannel10 = 0;
float TFRTireChannel11 = 0;
float TFRTireChannel12 = 0;
float TFRTireChannel13 = 0;
float TFRTireChannel14 = 0;
float TFRTireChannel15 = 0;
float TFRTireChannel16 = 0;
float TFLTireChannel01 = 0;
float TFLTireChannel02 = 0;
float TFLTireChannel03 = 0;
float TFLTireChannel04 = 0;
float TFLTireChannel05 = 0;
float TFLTireChannel06 = 0;
float TFLTireChannel07 = 0;
float TFLTireChannel08 = 0;
float TFLTireChannel09 = 0;
float TFLTireChannel10 = 0;
float TFLTireChannel11 = 0;
float TFLTireChannel12 = 0;
float TFLTireChannel13 = 0;
float TFLTireChannel14 = 0;
float TFLTireChannel15 = 0;
float TFLTireChannel16 = 0;
float TRRTireChannel01 = 0;
float TRRTireChannel02 = 0;
float TRRTireChannel03 = 0;
float TRRTireChannel04 = 0;
float TRRTireChannel05 = 0;
float TRRTireChannel06 = 0;
float TRRTireChannel07 = 0;
float TRRTireChannel08 = 0;
float TRRTireChannel09 = 0;
float TRRTireChannel10 = 0;
float TRRTireChannel11 = 0;
float TRRTireChannel12 = 0;
float TRRTireChannel13 = 0;
float TRRTireChannel14 = 0;
float TRRTireChannel15 = 0;
float TRRTireChannel16 = 0;
float TRLTireChannel01 = 0;
float TRLTireChannel02 = 0;
float TRLTireChannel03 = 0;
float TRLTireChannel04 = 0;
float TRLTireChannel05 = 0;
float TRLTireChannel06 = 0;
float TRLTireChannel07 = 0;
float TRLTireChannel08 = 0;
float TRLTireChannel09 = 0;
float TRLTireChannel10 = 0;
float TRLTireChannel11 = 0;
float TRLTireChannel12 = 0;
float TRLTireChannel13 = 0;
float TRLTireChannel14 = 0;
float TRLTireChannel15 = 0;
float TRLTireChannel16 = 0;
uint8_t ControlMode = 0;
float TargetIq = 0;
float MotorPosition = 0;
uint8_t isMotorStill = 0;
int32_t Actual_ERPM = 0;
float Actual_Duty = 0;
int16_t Actual_InputVoltage = 0;
float Actual_ACCurrent = 0;
float Actual_DCCurrent = 0;
float Actual_TempController = 0;
float Actual_TempMotor = 0;
uint8_t Actual_FaultCode = 0;
float Actual_FOC_id = 0;
float Actual_FOC_iq = 0;
int8_t Actual_Throttle = 0;
int8_t Actual_Brake = 0;
uint8_t Digital_output_4 = 0;
uint8_t Digital_output_3 = 0;
uint8_t Digital_output_2 = 0;
uint8_t Digital_output_1 = 0;
uint8_t Digital_input_4 = 0;
uint8_t Digital_input_3 = 0;
uint8_t Digital_input_2 = 0;
uint8_t Digital_input_1 = 0;
uint8_t Drive_enable = 0;
uint8_t Motor_temp_limit = 0;
uint8_t Motor_accel_limit = 0;
uint8_t Input_voltage_limit = 0;
uint8_t IGBT_temp_limit = 0;
uint8_t IGBT_accel_limit = 0;
uint8_t Drive_enable_limit = 0;
uint8_t DC_current_limit = 0;
uint8_t Capacitor_temp_limit = 0;
uint8_t Power_limit = 0;
uint8_t RPM_max_limit = 0;
uint8_t RPM_min_limit = 0;
float CAN_map_version = 0;
float MaxAcCurrent = 0;
float AvailableMaxAcCurrent = 0;
float MinAcCurrent = 0;
float AvailableMinAcCurrent = 0;
float MaxDcCurrent = 0;
float AvailableMaxDcCurrent = 0;
float MinDcCurrent = 0;
float AvailableMinDcCurrent = 0;
float Pack_Current = 0;
float Pack_Inst_Voltage = 0;
float Pack_SOC = 0;
float Pack_Resistance = 0;
float CheckSum_CellStats1 = 0;
float Pack_CCL_0 = 0;
float Pack_DCL = 0;
float Pack_DOD = 0;
float Pack_Open_Voltage = 0;
float Maximum_Pack_Voltage_0 = 0;
float Minimum_Pack_Voltage = 0;
float High_Cell_Voltage = 0;
float Avg_Cell_Voltage = 0;
float Low_Cell_Voltage = 0;
uint8_t High_Cell_Voltage_ID = 0;
uint8_t Low_Cell_Voltage_ID = 0;
float High_Opencell_Voltage = 0;
float Avg_Opencell_Voltage = 0;
float Low_Opencell_Voltage = 0;
uint8_t High_Opencell_ID = 0;
uint8_t Low_Opencell_ID = 0;
float High_Cell_Resistance = 0;
float Avg_Cell_Resistance = 0;
float Low_Cell_Resistance = 0;
uint8_t High_Intres_ID = 0;
uint8_t Low_Intres_ID = 0;
float Maximum_Cell_Voltage_0 = 0;
float Pack_CCL_2 = 0;
uint8_t DTC_P0A08_Charger_Safety_Relay_Fault_1 = 0;
float Maximum_Pack_Voltage_1 = 0;
float Pack_CCL_1 = 0;
uint8_t DTC_P0A08_Charger_Safety_Relay_Fault_0 = 0;
float Maximum_Cell_Voltage_1 = 0;
float Pack_CCL_3 = 0;
uint8_t DTC_P0A08_Charger_Safety_Relay_Fault_2 = 0;

esp_err_t ESPControl(CAN_frame_t stFrame)
{
    /*
    *===========================================================================
    *   ESPControl
    *   Message: ESPControl (0x10)
    *   Description: ESP Control Message
    *   Takes:   stFrame: The CAN frame to decode
    *   Returns: ESP_OK if successful, error code if not.
    *   Autogenerated by decodeCAN.py
    */
    if (stFrame.byDLC != 8) return ESP_ERR_INVALID_SIZE;
    if (stFrame.dwID != 0x10) return ESP_ERR_INVALID_ARG;

    /* Standard Signals */
    BRestart = (uint8_t)(((stFrame.abData[0] >> 7) & 0x1));
    BClearMinMax = (uint8_t)(((stFrame.abData[0] >> 6) & 0x1));
    BClearErrors = (uint8_t)(((stFrame.abData[0] >> 5) & 0x1));
    return ESP_OK;
}

esp_err_t ESPControlTx(twai_node_handle_t stCANBus)
{
    /*
    *===========================================================================
    *   ESPControlTx
    *   Encodes and Transmits Message: ESPControl (0x10)
    *   Uses global signal variables.
    *   Takes:   stCANBus: Handle to CAN bus to transmit on
    *   Returns: ESP_OK if successful, error code if not.
    */
    CAN_frame_t stFrame;
    stFrame.dwID = 0x10;
    stFrame.byDLC = 8;
    memset(stFrame.abData, 0, 8);

    stFrame.abData[0] |= (uint8_t)(((((uint32_t)BRestart & 0x1) >> 0) & 0x1) << 7);
    stFrame.abData[0] |= (uint8_t)(((((uint32_t)BClearMinMax & 0x1) >> 0) & 0x1) << 6);
    stFrame.abData[0] |= (uint8_t)(((((uint32_t)BClearErrors & 0x1) >> 0) & 0x1) << 5);

    return CAN_transmit(stCANBus, &stFrame);
}

esp_err_t MCUStatusTelemCar(CAN_frame_t stFrame)
{
    /*
    *===========================================================================
    *   MCUStatusTelemCar
    *   Message: MCUStatusTelemCar (0x11)
    *   Description: MCU Status Message
    *   Takes:   stFrame: The CAN frame to decode
    *   Returns: ESP_OK if successful, error code if not.
    *   Autogenerated by decodeCAN.py
    */
    if (stFrame.byDLC != 8) return ESP_ERR_INVALID_SIZE;
    if (stFrame.dwID != 0x11) return ESP_ERR_INVALID_ARG;

    /* Standard Signals */
    tLastTaskTime1msTelemCar = (float)(((stFrame.abData[0] >> 0) & 0xFF)) * 50.0f;
    tMaxTaskTime1msTelemCar = (float)(((stFrame.abData[1] >> 0) & 0xFF)) * 50.0f;
    tLastTaskTime100msTelemCar = (float)(((stFrame.abData[2] >> 0) & 0xFF)) * 500.0f;
    tMaxTaskTime100msTelemCar = (float)(((stFrame.abData[3] >> 0) & 0xFF)) * 500.0f;
    tLastTaskTimeBGTelemCar = (float)(((stFrame.abData[4] >> 0) & 0xFF)) * 500.0f;
    tMaxTaskTimeBGTelemCar = (float)(((stFrame.abData[5] >> 0) & 0xFF)) * 500.0f;
    tSincePowerUpTelemCar = (float)((((uint16_t)((stFrame.abData[6] >> 0) & 0xFF)) << 4) | ((uint16_t)((stFrame.abData[7] >> 4) & 0xF))) * 4.0f;
    NLastResetReasonTelemCar = (uint8_t)(((stFrame.abData[7] >> 0) & 0xF));
    return ESP_OK;
}

esp_err_t MCUStatusTelemCarTx(twai_node_handle_t stCANBus)
{
    /*
    *===========================================================================
    *   MCUStatusTelemCarTx
    *   Encodes and Transmits Message: MCUStatusTelemCar (0x11)
    *   Uses global signal variables.
    *   Takes:   stCANBus: Handle to CAN bus to transmit on
    *   Returns: ESP_OK if successful, error code if not.
    */
    CAN_frame_t stFrame;
    stFrame.dwID = 0x11;
    stFrame.byDLC = 8;
    memset(stFrame.abData, 0, 8);

    stFrame.abData[0] |= (uint8_t)(((((uint32_t)(tLastTaskTime1msTelemCar / 50.0f) & 0xFF) >> 0) & 0xFF) << 0);
    stFrame.abData[1] |= (uint8_t)(((((uint32_t)(tMaxTaskTime1msTelemCar / 50.0f) & 0xFF) >> 0) & 0xFF) << 0);
    stFrame.abData[2] |= (uint8_t)(((((uint32_t)(tLastTaskTime100msTelemCar / 500.0f) & 0xFF) >> 0) & 0xFF) << 0);
    stFrame.abData[3] |= (uint8_t)(((((uint32_t)(tMaxTaskTime100msTelemCar / 500.0f) & 0xFF) >> 0) & 0xFF) << 0);
    stFrame.abData[4] |= (uint8_t)(((((uint32_t)(tLastTaskTimeBGTelemCar / 500.0f) & 0xFF) >> 0) & 0xFF) << 0);
    stFrame.abData[5] |= (uint8_t)(((((uint32_t)(tMaxTaskTimeBGTelemCar / 500.0f) & 0xFF) >> 0) & 0xFF) << 0);
    stFrame.abData[6] |= (uint8_t)(((((uint32_t)(tSincePowerUpTelemCar / 4.0f) & 0xFFF) >> 4) & 0xFF) << 0);
    stFrame.abData[7] |= (uint8_t)(((((uint32_t)(tSincePowerUpTelemCar / 4.0f) & 0xFFF) >> 0) & 0xF) << 4);
    stFrame.abData[7] |= (uint8_t)(((((uint32_t)NLastResetReasonTelemCar & 0xF) >> 0) & 0xF) << 0);

    return CAN_transmit(stCANBus, &stFrame);
}

esp_err_t MCUStatusTelemPits(CAN_frame_t stFrame)
{
    /*
    *===========================================================================
    *   MCUStatusTelemPits
    *   Message: MCUStatusTelemPits (0x12)
    *   Description: MCU Status Message
    *   Takes:   stFrame: The CAN frame to decode
    *   Returns: ESP_OK if successful, error code if not.
    *   Autogenerated by decodeCAN.py
    */
    if (stFrame.byDLC != 8) return ESP_ERR_INVALID_SIZE;
    if (stFrame.dwID != 0x12) return ESP_ERR_INVALID_ARG;

    /* Standard Signals */
    tLastTaskTime1msTelemPits = (float)(((stFrame.abData[0] >> 0) & 0xFF)) * 50.0f;
    tMaxTaskTime1msTelemPits = (float)(((stFrame.abData[1] >> 0) & 0xFF)) * 50.0f;
    tLastTaskTime100msTelemPits = (float)(((stFrame.abData[2] >> 0) & 0xFF)) * 500.0f;
    tMaxTaskTime100msTelemPits = (float)(((stFrame.abData[3] >> 0) & 0xFF)) * 500.0f;
    tLastTaskTimeBGTelemPits = (float)(((stFrame.abData[4] >> 0) & 0xFF)) * 500.0f;
    tMaxTaskTimeBGTelemPits = (float)(((stFrame.abData[5] >> 0) & 0xFF)) * 500.0f;
    tSincePowerUpTelemPits = (float)((((uint16_t)((stFrame.abData[6] >> 0) & 0xFF)) << 4) | ((uint16_t)((stFrame.abData[7] >> 4) & 0xF))) * 4.0f;
    NLastResetReasonTelemPits = (uint8_t)(((stFrame.abData[7] >> 0) & 0xF));
    return ESP_OK;
}

esp_err_t MCUStatusTelemPitsTx(twai_node_handle_t stCANBus)
{
    /*
    *===========================================================================
    *   MCUStatusTelemPitsTx
    *   Encodes and Transmits Message: MCUStatusTelemPits (0x12)
    *   Uses global signal variables.
    *   Takes:   stCANBus: Handle to CAN bus to transmit on
    *   Returns: ESP_OK if successful, error code if not.
    */
    CAN_frame_t stFrame;
    stFrame.dwID = 0x12;
    stFrame.byDLC = 8;
    memset(stFrame.abData, 0, 8);

    stFrame.abData[0] |= (uint8_t)(((((uint32_t)(tLastTaskTime1msTelemPits / 50.0f) & 0xFF) >> 0) & 0xFF) << 0);
    stFrame.abData[1] |= (uint8_t)(((((uint32_t)(tMaxTaskTime1msTelemPits / 50.0f) & 0xFF) >> 0) & 0xFF) << 0);
    stFrame.abData[2] |= (uint8_t)(((((uint32_t)(tLastTaskTime100msTelemPits / 500.0f) & 0xFF) >> 0) & 0xFF) << 0);
    stFrame.abData[3] |= (uint8_t)(((((uint32_t)(tMaxTaskTime100msTelemPits / 500.0f) & 0xFF) >> 0) & 0xFF) << 0);
    stFrame.abData[4] |= (uint8_t)(((((uint32_t)(tLastTaskTimeBGTelemPits / 500.0f) & 0xFF) >> 0) & 0xFF) << 0);
    stFrame.abData[5] |= (uint8_t)(((((uint32_t)(tMaxTaskTimeBGTelemPits / 500.0f) & 0xFF) >> 0) & 0xFF) << 0);
    stFrame.abData[6] |= (uint8_t)(((((uint32_t)(tSincePowerUpTelemPits / 4.0f) & 0xFFF) >> 4) & 0xFF) << 0);
    stFrame.abData[7] |= (uint8_t)(((((uint32_t)(tSincePowerUpTelemPits / 4.0f) & 0xFFF) >> 0) & 0xF) << 4);
    stFrame.abData[7] |= (uint8_t)(((((uint32_t)NLastResetReasonTelemPits & 0xF) >> 0) & 0xF) << 0);

    return CAN_transmit(stCANBus, &stFrame);
}

esp_err_t MCUStatusIMDMonitor(CAN_frame_t stFrame)
{
    /*
    *===========================================================================
    *   MCUStatusIMDMonitor
    *   Message: MCUStatusIMDMonitor (0x13)
    *   Description: MCU Status Message
    *   Takes:   stFrame: The CAN frame to decode
    *   Returns: ESP_OK if successful, error code if not.
    *   Autogenerated by decodeCAN.py
    */
    if (stFrame.byDLC != 8) return ESP_ERR_INVALID_SIZE;
    if (stFrame.dwID != 0x13) return ESP_ERR_INVALID_ARG;

    /* Standard Signals */
    tLastTaskTime1msIMDMon = (float)(((stFrame.abData[0] >> 0) & 0xFF)) * 50.0f;
    tMaxTaskTime1msIMDMon = (float)(((stFrame.abData[1] >> 0) & 0xFF)) * 50.0f;
    tLastTaskTime100msIMDMon = (float)(((stFrame.abData[2] >> 0) & 0xFF)) * 500.0f;
    tMaxTaskTime100msIMDMon = (float)(((stFrame.abData[3] >> 0) & 0xFF)) * 500.0f;
    tLastTaskTimeBGIMDMon = (float)(((stFrame.abData[4] >> 0) & 0xFF)) * 500.0f;
    tMaxTaskTimeBGIMDMon = (float)(((stFrame.abData[5] >> 0) & 0xFF)) * 500.0f;
    tSincePowerUpIMDMon = (float)((((uint16_t)((stFrame.abData[6] >> 0) & 0xFF)) << 4) | ((uint16_t)((stFrame.abData[7] >> 4) & 0xF))) * 4.0f;
    NLastResetReasonIMDMon = (uint8_t)(((stFrame.abData[7] >> 0) & 0xF));
    return ESP_OK;
}

esp_err_t MCUStatusIMDMonitorTx(twai_node_handle_t stCANBus)
{
    /*
    *===========================================================================
    *   MCUStatusIMDMonitorTx
    *   Encodes and Transmits Message: MCUStatusIMDMonitor (0x13)
    *   Uses global signal variables.
    *   Takes:   stCANBus: Handle to CAN bus to transmit on
    *   Returns: ESP_OK if successful, error code if not.
    */
    CAN_frame_t stFrame;
    stFrame.dwID = 0x13;
    stFrame.byDLC = 8;
    memset(stFrame.abData, 0, 8);

    stFrame.abData[0] |= (uint8_t)(((((uint32_t)(tLastTaskTime1msIMDMon / 50.0f) & 0xFF) >> 0) & 0xFF) << 0);
    stFrame.abData[1] |= (uint8_t)(((((uint32_t)(tMaxTaskTime1msIMDMon / 50.0f) & 0xFF) >> 0) & 0xFF) << 0);
    stFrame.abData[2] |= (uint8_t)(((((uint32_t)(tLastTaskTime100msIMDMon / 500.0f) & 0xFF) >> 0) & 0xFF) << 0);
    stFrame.abData[3] |= (uint8_t)(((((uint32_t)(tMaxTaskTime100msIMDMon / 500.0f) & 0xFF) >> 0) & 0xFF) << 0);
    stFrame.abData[4] |= (uint8_t)(((((uint32_t)(tLastTaskTimeBGIMDMon / 500.0f) & 0xFF) >> 0) & 0xFF) << 0);
    stFrame.abData[5] |= (uint8_t)(((((uint32_t)(tMaxTaskTimeBGIMDMon / 500.0f) & 0xFF) >> 0) & 0xFF) << 0);
    stFrame.abData[6] |= (uint8_t)(((((uint32_t)(tSincePowerUpIMDMon / 4.0f) & 0xFFF) >> 4) & 0xFF) << 0);
    stFrame.abData[7] |= (uint8_t)(((((uint32_t)(tSincePowerUpIMDMon / 4.0f) & 0xFFF) >> 0) & 0xF) << 4);
    stFrame.abData[7] |= (uint8_t)(((((uint32_t)NLastResetReasonIMDMon & 0xF) >> 0) & 0xF) << 0);

    return CAN_transmit(stCANBus, &stFrame);
}

esp_err_t MCUStatusLogger(CAN_frame_t stFrame)
{
    /*
    *===========================================================================
    *   MCUStatusLogger
    *   Message: MCUStatusLogger (0x14)
    *   Description: MCU Status Message (Not sent to BUS just logged to SD card directly)
    *   Takes:   stFrame: The CAN frame to decode
    *   Returns: ESP_OK if successful, error code if not.
    *   Autogenerated by decodeCAN.py
    */
    if (stFrame.byDLC != 8) return ESP_ERR_INVALID_SIZE;
    if (stFrame.dwID != 0x14) return ESP_ERR_INVALID_ARG;

    /* Standard Signals */
    tLastTaskTime1msLogger = (float)(((stFrame.abData[0] >> 0) & 0xFF)) * 50.0f;
    tMaxTaskTime1msLogger = (float)(((stFrame.abData[1] >> 0) & 0xFF)) * 50.0f;
    tLastTaskTime100msLogger = (float)(((stFrame.abData[2] >> 0) & 0xFF)) * 500.0f;
    tMaxTaskTime100msLogger = (float)(((stFrame.abData[3] >> 0) & 0xFF)) * 500.0f;
    tLastTaskTimeBGLogger = (float)(((stFrame.abData[4] >> 0) & 0xFF)) * 500.0f;
    tMaxTaskTimeBGLogger = (float)(((stFrame.abData[5] >> 0) & 0xFF)) * 500.0f;
    tSincePowerUpLogger = (float)((((uint16_t)((stFrame.abData[6] >> 0) & 0xFF)) << 4) | ((uint16_t)((stFrame.abData[7] >> 4) & 0xF))) * 4.0f;
    NLastResetReasonLogger = (uint8_t)(((stFrame.abData[7] >> 0) & 0xF));
    return ESP_OK;
}

esp_err_t MCUStatusLoggerTx(twai_node_handle_t stCANBus)
{
    /*
    *===========================================================================
    *   MCUStatusLoggerTx
    *   Encodes and Transmits Message: MCUStatusLogger (0x14)
    *   Uses global signal variables.
    *   Takes:   stCANBus: Handle to CAN bus to transmit on
    *   Returns: ESP_OK if successful, error code if not.
    */
    CAN_frame_t stFrame;
    stFrame.dwID = 0x14;
    stFrame.byDLC = 8;
    memset(stFrame.abData, 0, 8);

    stFrame.abData[0] |= (uint8_t)(((((uint32_t)(tLastTaskTime1msLogger / 50.0f) & 0xFF) >> 0) & 0xFF) << 0);
    stFrame.abData[1] |= (uint8_t)(((((uint32_t)(tMaxTaskTime1msLogger / 50.0f) & 0xFF) >> 0) & 0xFF) << 0);
    stFrame.abData[2] |= (uint8_t)(((((uint32_t)(tLastTaskTime100msLogger / 500.0f) & 0xFF) >> 0) & 0xFF) << 0);
    stFrame.abData[3] |= (uint8_t)(((((uint32_t)(tMaxTaskTime100msLogger / 500.0f) & 0xFF) >> 0) & 0xFF) << 0);
    stFrame.abData[4] |= (uint8_t)(((((uint32_t)(tLastTaskTimeBGLogger / 500.0f) & 0xFF) >> 0) & 0xFF) << 0);
    stFrame.abData[5] |= (uint8_t)(((((uint32_t)(tMaxTaskTimeBGLogger / 500.0f) & 0xFF) >> 0) & 0xFF) << 0);
    stFrame.abData[6] |= (uint8_t)(((((uint32_t)(tSincePowerUpLogger / 4.0f) & 0xFFF) >> 4) & 0xFF) << 0);
    stFrame.abData[7] |= (uint8_t)(((((uint32_t)(tSincePowerUpLogger / 4.0f) & 0xFFF) >> 0) & 0xF) << 4);
    stFrame.abData[7] |= (uint8_t)(((((uint32_t)NLastResetReasonLogger & 0xF) >> 0) & 0xF) << 0);

    return CAN_transmit(stCANBus, &stFrame);
}

esp_err_t MCUStatusPDU(CAN_frame_t stFrame)
{
    /*
    *===========================================================================
    *   MCUStatusPDU
    *   Message: MCUStatusPDU (0x15)
    *   Description: MCU Status Message
    *   Takes:   stFrame: The CAN frame to decode
    *   Returns: ESP_OK if successful, error code if not.
    *   Autogenerated by decodeCAN.py
    */
    if (stFrame.byDLC != 8) return ESP_ERR_INVALID_SIZE;
    if (stFrame.dwID != 0x15) return ESP_ERR_INVALID_ARG;

    /* Standard Signals */
    tLastTaskTime1msPDU = (float)(((stFrame.abData[0] >> 0) & 0xFF)) * 50.0f;
    tMaxTaskTime1msPDU = (float)(((stFrame.abData[1] >> 0) & 0xFF)) * 50.0f;
    tLastTaskTime100msPDU = (float)(((stFrame.abData[2] >> 0) & 0xFF)) * 500.0f;
    tMaxTaskTime100msPDU = (float)(((stFrame.abData[3] >> 0) & 0xFF)) * 500.0f;
    tLastTaskTimeBGPDU = (float)(((stFrame.abData[4] >> 0) & 0xFF)) * 500.0f;
    tMaxTaskTimeBGPDU = (float)(((stFrame.abData[5] >> 0) & 0xFF)) * 500.0f;
    tSincePowerUpPDU = (float)((((uint16_t)((stFrame.abData[6] >> 0) & 0xFF)) << 4) | ((uint16_t)((stFrame.abData[7] >> 4) & 0xF))) * 4.0f;
    NLastResetReasonPDU = (uint8_t)(((stFrame.abData[7] >> 0) & 0xF));
    return ESP_OK;
}

esp_err_t MCUStatusPDUTx(twai_node_handle_t stCANBus)
{
    /*
    *===========================================================================
    *   MCUStatusPDUTx
    *   Encodes and Transmits Message: MCUStatusPDU (0x15)
    *   Uses global signal variables.
    *   Takes:   stCANBus: Handle to CAN bus to transmit on
    *   Returns: ESP_OK if successful, error code if not.
    */
    CAN_frame_t stFrame;
    stFrame.dwID = 0x15;
    stFrame.byDLC = 8;
    memset(stFrame.abData, 0, 8);

    stFrame.abData[0] |= (uint8_t)(((((uint32_t)(tLastTaskTime1msPDU / 50.0f) & 0xFF) >> 0) & 0xFF) << 0);
    stFrame.abData[1] |= (uint8_t)(((((uint32_t)(tMaxTaskTime1msPDU / 50.0f) & 0xFF) >> 0) & 0xFF) << 0);
    stFrame.abData[2] |= (uint8_t)(((((uint32_t)(tLastTaskTime100msPDU / 500.0f) & 0xFF) >> 0) & 0xFF) << 0);
    stFrame.abData[3] |= (uint8_t)(((((uint32_t)(tMaxTaskTime100msPDU / 500.0f) & 0xFF) >> 0) & 0xFF) << 0);
    stFrame.abData[4] |= (uint8_t)(((((uint32_t)(tLastTaskTimeBGPDU / 500.0f) & 0xFF) >> 0) & 0xFF) << 0);
    stFrame.abData[5] |= (uint8_t)(((((uint32_t)(tMaxTaskTimeBGPDU / 500.0f) & 0xFF) >> 0) & 0xFF) << 0);
    stFrame.abData[6] |= (uint8_t)(((((uint32_t)(tSincePowerUpPDU / 4.0f) & 0xFFF) >> 4) & 0xFF) << 0);
    stFrame.abData[7] |= (uint8_t)(((((uint32_t)(tSincePowerUpPDU / 4.0f) & 0xFFF) >> 0) & 0xF) << 4);
    stFrame.abData[7] |= (uint8_t)(((((uint32_t)NLastResetReasonPDU & 0xF) >> 0) & 0xF) << 0);

    return CAN_transmit(stCANBus, &stFrame);
}

esp_err_t StatusAPPS(CAN_frame_t stFrame)
{
    /*
    *===========================================================================
    *   StatusAPPS
    *   Message: StatusAPPS (0x16)
    *   Description: MCU Status Message
    *   Takes:   stFrame: The CAN frame to decode
    *   Returns: ESP_OK if successful, error code if not.
    *   Autogenerated by decodeCAN.py
    */
    if (stFrame.byDLC != 8) return ESP_ERR_INVALID_SIZE;
    if (stFrame.dwID != 0x16) return ESP_ERR_INVALID_ARG;

    /* Standard Signals */
    tLastTaskTime1msAPPS = (float)(((stFrame.abData[0] >> 0) & 0xFF)) * 50.0f;
    tMaxTaskTime1msAPPS = (float)(((stFrame.abData[1] >> 0) & 0xFF)) * 50.0f;
    tLastTaskTime100msAPPS = (float)(((stFrame.abData[2] >> 0) & 0xFF)) * 500.0f;
    tMaxTaskTime100msAPPS = (float)(((stFrame.abData[3] >> 0) & 0xFF)) * 500.0f;
    tLastTaskTimeBGAPPS = (float)(((stFrame.abData[4] >> 0) & 0xFF)) * 500.0f;
    tMaxTaskTimeBGAPPS = (float)(((stFrame.abData[5] >> 0) & 0xFF)) * 500.0f;
    tSincePowerUpAPPS = (float)((((uint16_t)((stFrame.abData[6] >> 0) & 0xFF)) << 4) | ((uint16_t)((stFrame.abData[7] >> 4) & 0xF))) * 4.0f;
    NLastResetReasonAPPS = (uint8_t)(((stFrame.abData[7] >> 0) & 0xF));
    return ESP_OK;
}

esp_err_t StatusAPPSTx(twai_node_handle_t stCANBus)
{
    /*
    *===========================================================================
    *   StatusAPPSTx
    *   Encodes and Transmits Message: StatusAPPS (0x16)
    *   Uses global signal variables.
    *   Takes:   stCANBus: Handle to CAN bus to transmit on
    *   Returns: ESP_OK if successful, error code if not.
    */
    CAN_frame_t stFrame;
    stFrame.dwID = 0x16;
    stFrame.byDLC = 8;
    memset(stFrame.abData, 0, 8);

    stFrame.abData[0] |= (uint8_t)(((((uint32_t)(tLastTaskTime1msAPPS / 50.0f) & 0xFF) >> 0) & 0xFF) << 0);
    stFrame.abData[1] |= (uint8_t)(((((uint32_t)(tMaxTaskTime1msAPPS / 50.0f) & 0xFF) >> 0) & 0xFF) << 0);
    stFrame.abData[2] |= (uint8_t)(((((uint32_t)(tLastTaskTime100msAPPS / 500.0f) & 0xFF) >> 0) & 0xFF) << 0);
    stFrame.abData[3] |= (uint8_t)(((((uint32_t)(tMaxTaskTime100msAPPS / 500.0f) & 0xFF) >> 0) & 0xFF) << 0);
    stFrame.abData[4] |= (uint8_t)(((((uint32_t)(tLastTaskTimeBGAPPS / 500.0f) & 0xFF) >> 0) & 0xFF) << 0);
    stFrame.abData[5] |= (uint8_t)(((((uint32_t)(tMaxTaskTimeBGAPPS / 500.0f) & 0xFF) >> 0) & 0xFF) << 0);
    stFrame.abData[6] |= (uint8_t)(((((uint32_t)(tSincePowerUpAPPS / 4.0f) & 0xFFF) >> 4) & 0xFF) << 0);
    stFrame.abData[7] |= (uint8_t)(((((uint32_t)(tSincePowerUpAPPS / 4.0f) & 0xFFF) >> 0) & 0xF) << 4);
    stFrame.abData[7] |= (uint8_t)(((((uint32_t)NLastResetReasonAPPS & 0xF) >> 0) & 0xF) << 0);

    return CAN_transmit(stCANBus, &stFrame);
}

esp_err_t MCUStatusScreen(CAN_frame_t stFrame)
{
    /*
    *===========================================================================
    *   MCUStatusScreen
    *   Message: MCUStatusScreen (0x17)
    *   Description: MCU Status Message
    *   Takes:   stFrame: The CAN frame to decode
    *   Returns: ESP_OK if successful, error code if not.
    *   Autogenerated by decodeCAN.py
    */
    if (stFrame.byDLC != 8) return ESP_ERR_INVALID_SIZE;
    if (stFrame.dwID != 0x17) return ESP_ERR_INVALID_ARG;

    /* Standard Signals */
    tLastTaskTime1msScreen = (float)(((stFrame.abData[0] >> 0) & 0xFF)) * 50.0f;
    tMaxTaskTime1msScreen = (float)(((stFrame.abData[1] >> 0) & 0xFF)) * 50.0f;
    tLastTaskTime100msScreen = (float)(((stFrame.abData[2] >> 0) & 0xFF)) * 500.0f;
    tMaxTaskTime100msScreen = (float)(((stFrame.abData[3] >> 0) & 0xFF)) * 500.0f;
    tLastTaskTimeBGScreen = (float)(((stFrame.abData[4] >> 0) & 0xFF)) * 500.0f;
    tMaxTaskTimeBGScreen = (float)(((stFrame.abData[5] >> 0) & 0xFF)) * 500.0f;
    tSincePowerUpScreen = (float)((((uint16_t)((stFrame.abData[6] >> 0) & 0xFF)) << 4) | ((uint16_t)((stFrame.abData[7] >> 4) & 0xF))) * 4.0f;
    NLastResetReasonScreen = (uint8_t)(((stFrame.abData[7] >> 0) & 0xF));
    return ESP_OK;
}

esp_err_t MCUStatusScreenTx(twai_node_handle_t stCANBus)
{
    /*
    *===========================================================================
    *   MCUStatusScreenTx
    *   Encodes and Transmits Message: MCUStatusScreen (0x17)
    *   Uses global signal variables.
    *   Takes:   stCANBus: Handle to CAN bus to transmit on
    *   Returns: ESP_OK if successful, error code if not.
    */
    CAN_frame_t stFrame;
    stFrame.dwID = 0x17;
    stFrame.byDLC = 8;
    memset(stFrame.abData, 0, 8);

    stFrame.abData[0] |= (uint8_t)(((((uint32_t)(tLastTaskTime1msScreen / 50.0f) & 0xFF) >> 0) & 0xFF) << 0);
    stFrame.abData[1] |= (uint8_t)(((((uint32_t)(tMaxTaskTime1msScreen / 50.0f) & 0xFF) >> 0) & 0xFF) << 0);
    stFrame.abData[2] |= (uint8_t)(((((uint32_t)(tLastTaskTime100msScreen / 500.0f) & 0xFF) >> 0) & 0xFF) << 0);
    stFrame.abData[3] |= (uint8_t)(((((uint32_t)(tMaxTaskTime100msScreen / 500.0f) & 0xFF) >> 0) & 0xFF) << 0);
    stFrame.abData[4] |= (uint8_t)(((((uint32_t)(tLastTaskTimeBGScreen / 500.0f) & 0xFF) >> 0) & 0xFF) << 0);
    stFrame.abData[5] |= (uint8_t)(((((uint32_t)(tMaxTaskTimeBGScreen / 500.0f) & 0xFF) >> 0) & 0xFF) << 0);
    stFrame.abData[6] |= (uint8_t)(((((uint32_t)(tSincePowerUpScreen / 4.0f) & 0xFFF) >> 4) & 0xFF) << 0);
    stFrame.abData[7] |= (uint8_t)(((((uint32_t)(tSincePowerUpScreen / 4.0f) & 0xFFF) >> 0) & 0xF) << 4);
    stFrame.abData[7] |= (uint8_t)(((((uint32_t)NLastResetReasonScreen & 0xF) >> 0) & 0xF) << 0);

    return CAN_transmit(stCANBus, &stFrame);
}

esp_err_t MCUStatusDash(CAN_frame_t stFrame)
{
    /*
    *===========================================================================
    *   MCUStatusDash
    *   Message: MCUStatusDash (0x18)
    *   Description: MCU Status Message
    *   Takes:   stFrame: The CAN frame to decode
    *   Returns: ESP_OK if successful, error code if not.
    *   Autogenerated by decodeCAN.py
    */
    if (stFrame.byDLC != 8) return ESP_ERR_INVALID_SIZE;
    if (stFrame.dwID != 0x18) return ESP_ERR_INVALID_ARG;

    /* Standard Signals */
    tLastTaskTime1msDash = (float)(((stFrame.abData[0] >> 0) & 0xFF)) * 50.0f;
    tMaxTaskTime1msDash = (float)(((stFrame.abData[1] >> 0) & 0xFF)) * 50.0f;
    tLastTaskTime100msDash = (float)(((stFrame.abData[2] >> 0) & 0xFF)) * 500.0f;
    tMaxTaskTime100msDash = (float)(((stFrame.abData[3] >> 0) & 0xFF)) * 500.0f;
    tLastTaskTimeBGDash = (float)(((stFrame.abData[4] >> 0) & 0xFF)) * 500.0f;
    tMaxTaskTimeBGDash = (float)(((stFrame.abData[5] >> 0) & 0xFF)) * 500.0f;
    tSincePowerUpDash = (float)((((uint16_t)((stFrame.abData[6] >> 0) & 0xFF)) << 4) | ((uint16_t)((stFrame.abData[7] >> 4) & 0xF))) * 4.0f;
    NLastResetReasonDash = (uint8_t)(((stFrame.abData[7] >> 0) & 0xF));
    return ESP_OK;
}

esp_err_t MCUStatusDashTx(twai_node_handle_t stCANBus)
{
    /*
    *===========================================================================
    *   MCUStatusDashTx
    *   Encodes and Transmits Message: MCUStatusDash (0x18)
    *   Uses global signal variables.
    *   Takes:   stCANBus: Handle to CAN bus to transmit on
    *   Returns: ESP_OK if successful, error code if not.
    */
    CAN_frame_t stFrame;
    stFrame.dwID = 0x18;
    stFrame.byDLC = 8;
    memset(stFrame.abData, 0, 8);

    stFrame.abData[0] |= (uint8_t)(((((uint32_t)(tLastTaskTime1msDash / 50.0f) & 0xFF) >> 0) & 0xFF) << 0);
    stFrame.abData[1] |= (uint8_t)(((((uint32_t)(tMaxTaskTime1msDash / 50.0f) & 0xFF) >> 0) & 0xFF) << 0);
    stFrame.abData[2] |= (uint8_t)(((((uint32_t)(tLastTaskTime100msDash / 500.0f) & 0xFF) >> 0) & 0xFF) << 0);
    stFrame.abData[3] |= (uint8_t)(((((uint32_t)(tMaxTaskTime100msDash / 500.0f) & 0xFF) >> 0) & 0xFF) << 0);
    stFrame.abData[4] |= (uint8_t)(((((uint32_t)(tLastTaskTimeBGDash / 500.0f) & 0xFF) >> 0) & 0xFF) << 0);
    stFrame.abData[5] |= (uint8_t)(((((uint32_t)(tMaxTaskTimeBGDash / 500.0f) & 0xFF) >> 0) & 0xFF) << 0);
    stFrame.abData[6] |= (uint8_t)(((((uint32_t)(tSincePowerUpDash / 4.0f) & 0xFFF) >> 4) & 0xFF) << 0);
    stFrame.abData[7] |= (uint8_t)(((((uint32_t)(tSincePowerUpDash / 4.0f) & 0xFFF) >> 0) & 0xF) << 4);
    stFrame.abData[7] |= (uint8_t)(((((uint32_t)NLastResetReasonDash & 0xF) >> 0) & 0xF) << 0);

    return CAN_transmit(stCANBus, &stFrame);
}

esp_err_t MCUStatusDyno(CAN_frame_t stFrame)
{
    /*
    *===========================================================================
    *   MCUStatusDyno
    *   Message: MCUStatusDyno (0x19)
    *   Takes:   stFrame: The CAN frame to decode
    *   Returns: ESP_OK if successful, error code if not.
    *   Autogenerated by decodeCAN.py
    */
    if (stFrame.byDLC != 8) return ESP_ERR_INVALID_SIZE;
    if (stFrame.dwID != 0x19) return ESP_ERR_INVALID_ARG;

    /* Standard Signals */
    tLastTaskTime1msDyno = (float)(((stFrame.abData[0] >> 0) & 0xFF)) * 50.0f;
    tMaxTaskTime1msDyno = (float)(((stFrame.abData[1] >> 0) & 0xFF)) * 50.0f;
    tLastTaskTime100msDyno = (float)(((stFrame.abData[2] >> 0) & 0xFF)) * 500.0f;
    tMaxTaskTime100msDyno = (float)(((stFrame.abData[3] >> 0) & 0xFF)) * 500.0f;
    tLastTaskTimeBGDyno = (float)(((stFrame.abData[4] >> 0) & 0xFF)) * 500.0f;
    tMaxTaskTimeBGDyno = (float)(((stFrame.abData[5] >> 0) & 0xFF)) * 500.0f;
    tSincePowerUpDyno = (float)((((uint16_t)((stFrame.abData[6] >> 0) & 0xFF)) << 4) | ((uint16_t)((stFrame.abData[7] >> 4) & 0xF))) * 4.0f;
    NLastResetReasonDyno = (uint8_t)(((stFrame.abData[7] >> 0) & 0xF));
    return ESP_OK;
}

esp_err_t MCUStatusDynoTx(twai_node_handle_t stCANBus)
{
    /*
    *===========================================================================
    *   MCUStatusDynoTx
    *   Encodes and Transmits Message: MCUStatusDyno (0x19)
    *   Uses global signal variables.
    *   Takes:   stCANBus: Handle to CAN bus to transmit on
    *   Returns: ESP_OK if successful, error code if not.
    */
    CAN_frame_t stFrame;
    stFrame.dwID = 0x19;
    stFrame.byDLC = 8;
    memset(stFrame.abData, 0, 8);

    stFrame.abData[0] |= (uint8_t)(((((uint32_t)(tLastTaskTime1msDyno / 50.0f) & 0xFF) >> 0) & 0xFF) << 0);
    stFrame.abData[1] |= (uint8_t)(((((uint32_t)(tMaxTaskTime1msDyno / 50.0f) & 0xFF) >> 0) & 0xFF) << 0);
    stFrame.abData[2] |= (uint8_t)(((((uint32_t)(tLastTaskTime100msDyno / 500.0f) & 0xFF) >> 0) & 0xFF) << 0);
    stFrame.abData[3] |= (uint8_t)(((((uint32_t)(tMaxTaskTime100msDyno / 500.0f) & 0xFF) >> 0) & 0xFF) << 0);
    stFrame.abData[4] |= (uint8_t)(((((uint32_t)(tLastTaskTimeBGDyno / 500.0f) & 0xFF) >> 0) & 0xFF) << 0);
    stFrame.abData[5] |= (uint8_t)(((((uint32_t)(tMaxTaskTimeBGDyno / 500.0f) & 0xFF) >> 0) & 0xFF) << 0);
    stFrame.abData[6] |= (uint8_t)(((((uint32_t)(tSincePowerUpDyno / 4.0f) & 0xFFF) >> 4) & 0xFF) << 0);
    stFrame.abData[7] |= (uint8_t)(((((uint32_t)(tSincePowerUpDyno / 4.0f) & 0xFFF) >> 0) & 0xF) << 4);
    stFrame.abData[7] |= (uint8_t)(((((uint32_t)NLastResetReasonDyno & 0xF) >> 0) & 0xF) << 0);

    return CAN_transmit(stCANBus, &stFrame);
}

esp_err_t SetAcCurrent(CAN_frame_t stFrame)
{
    /*
    *===========================================================================
    *   SetAcCurrent
    *   Message: SetAcCurrent (0x24)
    *   Description: Node ID: 4 (decimal)
    *   Takes:   stFrame: The CAN frame to decode
    *   Returns: ESP_OK if successful, error code if not.
    *   Autogenerated by decodeCAN.py
    */
    if (stFrame.byDLC != 8) return ESP_ERR_INVALID_SIZE;
    if (stFrame.dwID != 0x24) return ESP_ERR_INVALID_ARG;

    /* Standard Signals */
    CMD_TargetAcCurrent = (float)((((uint16_t)((stFrame.abData[0] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[1] >> 0) & 0xFF))) * 0.1f;
    return ESP_OK;
}

esp_err_t SetAcCurrentTx(twai_node_handle_t stCANBus)
{
    /*
    *===========================================================================
    *   SetAcCurrentTx
    *   Encodes and Transmits Message: SetAcCurrent (0x24)
    *   Uses global signal variables.
    *   Takes:   stCANBus: Handle to CAN bus to transmit on
    *   Returns: ESP_OK if successful, error code if not.
    */
    CAN_frame_t stFrame;
    stFrame.dwID = 0x24;
    stFrame.byDLC = 8;
    memset(stFrame.abData, 0, 8);

    stFrame.abData[0] |= (uint8_t)(((((uint32_t)(CMD_TargetAcCurrent / 0.1f) & 0xFFFF) >> 8) & 0xFF) << 0);
    stFrame.abData[1] |= (uint8_t)(((((uint32_t)(CMD_TargetAcCurrent / 0.1f) & 0xFFFF) >> 0) & 0xFF) << 0);

    return CAN_transmit(stCANBus, &stFrame);
}

esp_err_t CellVoltages(CAN_frame_t stFrame)
{
    /*
    *===========================================================================
    *   CellVoltages
    *   Message: CellVoltages (0x36)
    *   Description: All Cell Voltages
    *   Takes:   stFrame: The CAN frame to decode
    *   Returns: ESP_OK if successful, error code if not.
    *   Autogenerated by decodeCAN.py
    */
    if (stFrame.byDLC != 8) return ESP_ERR_INVALID_SIZE;
    if (stFrame.dwID != 0x36) return ESP_ERR_INVALID_ARG;

    /* Standard Signals */
    CheckSum_CellVoltages = (uint8_t)(((stFrame.abData[7] >> 0) & 0xFF));

    /* Mux Switch */
    CellID = (uint8_t)(((stFrame.abData[0] >> 0) & 0xFF));

    /* Muxed Signals */
    switch(((stFrame.abData[0] >> 0) & 0xFF))
    {
        case 0:
            VCell001 = (float)((((uint16_t)((stFrame.abData[1] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[2] >> 0) & 0xFF))) * 0.0001f;
            RCell001 = (float)((((uint16_t)((stFrame.abData[3] >> 0) & 0x7F)) << 8) | ((uint16_t)((stFrame.abData[4] >> 0) & 0xFF))) * 0.01f;
            BBalancingCell001 = (uint8_t)(((stFrame.abData[3] >> 0) & 0x1));
            VOpenCell001 = (float)((((uint16_t)((stFrame.abData[5] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[6] >> 0) & 0xFF))) * 0.000100000000000001f;
            break;
        case 1:
            VCell002 = (float)((((uint16_t)((stFrame.abData[1] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[2] >> 0) & 0xFF))) * 0.0001f;
            RCell002 = (float)((((uint16_t)((stFrame.abData[3] >> 0) & 0x7F)) << 8) | ((uint16_t)((stFrame.abData[4] >> 0) & 0xFF))) * 0.01f;
            BBalancingCell002 = (uint8_t)(((stFrame.abData[3] >> 0) & 0x1));
            VOpenCell002 = (float)((((uint16_t)((stFrame.abData[5] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[6] >> 0) & 0xFF))) * 0.000100000000000001f;
            break;
        case 2:
            VCell003 = (float)((((uint16_t)((stFrame.abData[1] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[2] >> 0) & 0xFF))) * 0.0001f;
            RCell003 = (float)((((uint16_t)((stFrame.abData[3] >> 0) & 0x7F)) << 8) | ((uint16_t)((stFrame.abData[4] >> 0) & 0xFF))) * 0.01f;
            BBalancingCell003 = (uint8_t)(((stFrame.abData[3] >> 0) & 0x1));
            VOpenCell003 = (float)((((uint16_t)((stFrame.abData[5] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[6] >> 0) & 0xFF))) * 0.000100000000000001f;
            break;
        case 3:
            VCell004 = (float)((((uint16_t)((stFrame.abData[1] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[2] >> 0) & 0xFF))) * 0.0001f;
            RCell004 = (float)((((uint16_t)((stFrame.abData[3] >> 0) & 0x7F)) << 8) | ((uint16_t)((stFrame.abData[4] >> 0) & 0xFF))) * 0.01f;
            BBalancingCell004 = (uint8_t)(((stFrame.abData[3] >> 0) & 0x1));
            VOpenCell004 = (float)((((uint16_t)((stFrame.abData[5] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[6] >> 0) & 0xFF))) * 0.000100000000000001f;
            break;
        case 4:
            VCell005 = (float)((((uint16_t)((stFrame.abData[1] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[2] >> 0) & 0xFF))) * 0.0001f;
            RCell005 = (float)((((uint16_t)((stFrame.abData[3] >> 0) & 0x7F)) << 8) | ((uint16_t)((stFrame.abData[4] >> 0) & 0xFF))) * 0.01f;
            BBalancingCell005 = (uint8_t)(((stFrame.abData[3] >> 0) & 0x1));
            VOpenCell005 = (float)((((uint16_t)((stFrame.abData[5] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[6] >> 0) & 0xFF))) * 0.000100000000000001f;
            break;
        case 5:
            VCell006 = (float)((((uint16_t)((stFrame.abData[1] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[2] >> 0) & 0xFF))) * 0.0001f;
            RCell006 = (float)((((uint16_t)((stFrame.abData[3] >> 0) & 0x7F)) << 8) | ((uint16_t)((stFrame.abData[4] >> 0) & 0xFF))) * 0.01f;
            BBalancingCell006 = (uint8_t)(((stFrame.abData[3] >> 0) & 0x1));
            VOpenCell006 = (float)((((uint16_t)((stFrame.abData[5] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[6] >> 0) & 0xFF))) * 0.000100000000000001f;
            break;
        case 6:
            VCell007 = (float)((((uint16_t)((stFrame.abData[1] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[2] >> 0) & 0xFF))) * 0.0001f;
            RCell007 = (float)((((uint16_t)((stFrame.abData[3] >> 0) & 0x7F)) << 8) | ((uint16_t)((stFrame.abData[4] >> 0) & 0xFF))) * 0.01f;
            BBalancingCell007 = (uint8_t)(((stFrame.abData[3] >> 0) & 0x1));
            VOpenCell007 = (float)((((uint16_t)((stFrame.abData[5] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[6] >> 0) & 0xFF))) * 0.000100000000000001f;
            break;
        case 7:
            VCell008 = (float)((((uint16_t)((stFrame.abData[1] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[2] >> 0) & 0xFF))) * 0.0001f;
            RCell008 = (float)((((uint16_t)((stFrame.abData[3] >> 0) & 0x7F)) << 8) | ((uint16_t)((stFrame.abData[4] >> 0) & 0xFF))) * 0.01f;
            BBalancingCell008 = (uint8_t)(((stFrame.abData[3] >> 0) & 0x1));
            VOpenCell008 = (float)((((uint16_t)((stFrame.abData[5] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[6] >> 0) & 0xFF))) * 0.000100000000000001f;
            break;
        case 8:
            VCell009 = (float)((((uint16_t)((stFrame.abData[1] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[2] >> 0) & 0xFF))) * 0.0001f;
            RCell009 = (float)((((uint16_t)((stFrame.abData[3] >> 0) & 0x7F)) << 8) | ((uint16_t)((stFrame.abData[4] >> 0) & 0xFF))) * 0.01f;
            BBalancingCell009 = (uint8_t)(((stFrame.abData[3] >> 0) & 0x1));
            VOpenCell009 = (float)((((uint16_t)((stFrame.abData[5] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[6] >> 0) & 0xFF))) * 0.000100000000000001f;
            break;
        case 9:
            VCell010 = (float)((((uint16_t)((stFrame.abData[1] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[2] >> 0) & 0xFF))) * 0.0001f;
            RCell010 = (float)((((uint16_t)((stFrame.abData[3] >> 0) & 0x7F)) << 8) | ((uint16_t)((stFrame.abData[4] >> 0) & 0xFF))) * 0.01f;
            BBalancingCell010 = (uint8_t)(((stFrame.abData[3] >> 0) & 0x1));
            VOpenCell010 = (float)((((uint16_t)((stFrame.abData[5] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[6] >> 0) & 0xFF))) * 0.000100000000000001f;
            break;
        case 10:
            VCell011 = (float)((((uint16_t)((stFrame.abData[1] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[2] >> 0) & 0xFF))) * 0.0001f;
            RCell011 = (float)((((uint16_t)((stFrame.abData[3] >> 0) & 0x7F)) << 8) | ((uint16_t)((stFrame.abData[4] >> 0) & 0xFF))) * 0.01f;
            BBalancingCell011 = (uint8_t)(((stFrame.abData[3] >> 0) & 0x1));
            VOpenCell011 = (float)((((uint16_t)((stFrame.abData[5] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[6] >> 0) & 0xFF))) * 0.000100000000000001f;
            break;
        case 11:
            VCell012 = (float)((((uint16_t)((stFrame.abData[1] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[2] >> 0) & 0xFF))) * 0.0001f;
            RCell012 = (float)((((uint16_t)((stFrame.abData[3] >> 0) & 0x7F)) << 8) | ((uint16_t)((stFrame.abData[4] >> 0) & 0xFF))) * 0.01f;
            BBalancingCell012 = (uint8_t)(((stFrame.abData[3] >> 0) & 0x1));
            VOpenCell012 = (float)((((uint16_t)((stFrame.abData[5] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[6] >> 0) & 0xFF))) * 0.000100000000000001f;
            break;
        case 12:
            VCell013 = (float)((((uint16_t)((stFrame.abData[1] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[2] >> 0) & 0xFF))) * 0.0001f;
            RCell013 = (float)((((uint16_t)((stFrame.abData[3] >> 0) & 0x7F)) << 8) | ((uint16_t)((stFrame.abData[4] >> 0) & 0xFF))) * 0.01f;
            BBalancingCell013 = (uint8_t)(((stFrame.abData[3] >> 0) & 0x1));
            VOpenCell013 = (float)((((uint16_t)((stFrame.abData[5] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[6] >> 0) & 0xFF))) * 0.000100000000000001f;
            break;
        case 13:
            VCell014 = (float)((((uint16_t)((stFrame.abData[1] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[2] >> 0) & 0xFF))) * 0.0001f;
            RCell014 = (float)((((uint16_t)((stFrame.abData[3] >> 0) & 0x7F)) << 8) | ((uint16_t)((stFrame.abData[4] >> 0) & 0xFF))) * 0.01f;
            BBalancingCell014 = (uint8_t)(((stFrame.abData[3] >> 0) & 0x1));
            VOpenCell014 = (float)((((uint16_t)((stFrame.abData[5] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[6] >> 0) & 0xFF))) * 0.000100000000000001f;
            break;
        case 14:
            VCell015 = (float)((((uint16_t)((stFrame.abData[1] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[2] >> 0) & 0xFF))) * 0.0001f;
            RCell015 = (float)((((uint16_t)((stFrame.abData[3] >> 0) & 0x7F)) << 8) | ((uint16_t)((stFrame.abData[4] >> 0) & 0xFF))) * 0.01f;
            BBalancingCell015 = (uint8_t)(((stFrame.abData[3] >> 0) & 0x1));
            VOpenCell015 = (float)((((uint16_t)((stFrame.abData[5] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[6] >> 0) & 0xFF))) * 0.000100000000000001f;
            break;
        case 15:
            VCell016 = (float)((((uint16_t)((stFrame.abData[1] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[2] >> 0) & 0xFF))) * 0.0001f;
            RCell016 = (float)((((uint16_t)((stFrame.abData[3] >> 0) & 0x7F)) << 8) | ((uint16_t)((stFrame.abData[4] >> 0) & 0xFF))) * 0.01f;
            BBalancingCell016 = (uint8_t)(((stFrame.abData[3] >> 0) & 0x1));
            VOpenCell016 = (float)((((uint16_t)((stFrame.abData[5] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[6] >> 0) & 0xFF))) * 0.000100000000000001f;
            break;
        case 16:
            VCell017 = (float)((((uint16_t)((stFrame.abData[1] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[2] >> 0) & 0xFF))) * 0.0001f;
            RCell017 = (float)((((uint16_t)((stFrame.abData[3] >> 0) & 0x7F)) << 8) | ((uint16_t)((stFrame.abData[4] >> 0) & 0xFF))) * 0.01f;
            BBalancingCell017 = (uint8_t)(((stFrame.abData[3] >> 0) & 0x1));
            VOpenCell017 = (float)((((uint16_t)((stFrame.abData[5] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[6] >> 0) & 0xFF))) * 0.000100000000000001f;
            break;
        case 17:
            VCell018 = (float)((((uint16_t)((stFrame.abData[1] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[2] >> 0) & 0xFF))) * 0.0001f;
            RCell018 = (float)((((uint16_t)((stFrame.abData[3] >> 0) & 0x7F)) << 8) | ((uint16_t)((stFrame.abData[4] >> 0) & 0xFF))) * 0.01f;
            BBalancingCell018 = (uint8_t)(((stFrame.abData[3] >> 0) & 0x1));
            VOpenCell018 = (float)((((uint16_t)((stFrame.abData[5] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[6] >> 0) & 0xFF))) * 0.000100000000000001f;
            break;
        case 18:
            VCell019 = (float)((((uint16_t)((stFrame.abData[1] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[2] >> 0) & 0xFF))) * 0.0001f;
            RCell019 = (float)((((uint16_t)((stFrame.abData[3] >> 0) & 0x7F)) << 8) | ((uint16_t)((stFrame.abData[4] >> 0) & 0xFF))) * 0.01f;
            BBalancingCell019 = (uint8_t)(((stFrame.abData[3] >> 0) & 0x1));
            VOpenCell019 = (float)((((uint16_t)((stFrame.abData[5] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[6] >> 0) & 0xFF))) * 0.000100000000000001f;
            break;
        case 19:
            VCell020 = (float)((((uint16_t)((stFrame.abData[1] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[2] >> 0) & 0xFF))) * 0.0001f;
            RCell020 = (float)((((uint16_t)((stFrame.abData[3] >> 0) & 0x7F)) << 8) | ((uint16_t)((stFrame.abData[4] >> 0) & 0xFF))) * 0.01f;
            BBalancingCell020 = (uint8_t)(((stFrame.abData[3] >> 0) & 0x1));
            VOpenCell020 = (float)((((uint16_t)((stFrame.abData[5] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[6] >> 0) & 0xFF))) * 0.000100000000000001f;
            break;
        case 20:
            VCell021 = (float)((((uint16_t)((stFrame.abData[1] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[2] >> 0) & 0xFF))) * 0.0001f;
            RCell021 = (float)((((uint16_t)((stFrame.abData[3] >> 0) & 0x7F)) << 8) | ((uint16_t)((stFrame.abData[4] >> 0) & 0xFF))) * 0.01f;
            BBalancingCell021 = (uint8_t)(((stFrame.abData[3] >> 0) & 0x1));
            VOpenCell021 = (float)((((uint16_t)((stFrame.abData[5] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[6] >> 0) & 0xFF))) * 0.000100000000000001f;
            break;
        case 21:
            VCell022 = (float)((((uint16_t)((stFrame.abData[1] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[2] >> 0) & 0xFF))) * 0.0001f;
            RCell022 = (float)((((uint16_t)((stFrame.abData[3] >> 0) & 0x7F)) << 8) | ((uint16_t)((stFrame.abData[4] >> 0) & 0xFF))) * 0.01f;
            BBalancingCell022 = (uint8_t)(((stFrame.abData[3] >> 0) & 0x1));
            VOpenCell022 = (float)((((uint16_t)((stFrame.abData[5] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[6] >> 0) & 0xFF))) * 0.000100000000000001f;
            break;
        case 22:
            VCell023 = (float)((((uint16_t)((stFrame.abData[1] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[2] >> 0) & 0xFF))) * 0.0001f;
            RCell023 = (float)((((uint16_t)((stFrame.abData[3] >> 0) & 0x7F)) << 8) | ((uint16_t)((stFrame.abData[4] >> 0) & 0xFF))) * 0.01f;
            BBalancingCell023 = (uint8_t)(((stFrame.abData[3] >> 0) & 0x1));
            VOpenCell023 = (float)((((uint16_t)((stFrame.abData[5] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[6] >> 0) & 0xFF))) * 0.000100000000000001f;
            break;
        case 23:
            VCell024 = (float)((((uint16_t)((stFrame.abData[1] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[2] >> 0) & 0xFF))) * 0.0001f;
            RCell024 = (float)((((uint16_t)((stFrame.abData[3] >> 0) & 0x7F)) << 8) | ((uint16_t)((stFrame.abData[4] >> 0) & 0xFF))) * 0.01f;
            BBalancingCell024 = (uint8_t)(((stFrame.abData[3] >> 0) & 0x1));
            VOpenCell024 = (float)((((uint16_t)((stFrame.abData[5] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[6] >> 0) & 0xFF))) * 0.000100000000000001f;
            break;
        case 24:
            VCell025 = (float)((((uint16_t)((stFrame.abData[1] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[2] >> 0) & 0xFF))) * 0.0001f;
            RCell025 = (float)((((uint16_t)((stFrame.abData[3] >> 0) & 0x7F)) << 8) | ((uint16_t)((stFrame.abData[4] >> 0) & 0xFF))) * 0.01f;
            BBalancingCell025 = (uint8_t)(((stFrame.abData[3] >> 0) & 0x1));
            VOpenCell025 = (float)((((uint16_t)((stFrame.abData[5] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[6] >> 0) & 0xFF))) * 0.000100000000000001f;
            break;
        case 25:
            VCell026 = (float)((((uint16_t)((stFrame.abData[1] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[2] >> 0) & 0xFF))) * 0.0001f;
            RCell026 = (float)((((uint16_t)((stFrame.abData[3] >> 0) & 0x7F)) << 8) | ((uint16_t)((stFrame.abData[4] >> 0) & 0xFF))) * 0.01f;
            BBalancingCell026 = (uint8_t)(((stFrame.abData[3] >> 0) & 0x1));
            VOpenCell026 = (float)((((uint16_t)((stFrame.abData[5] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[6] >> 0) & 0xFF))) * 0.000100000000000001f;
            break;
        case 26:
            VCell027 = (float)((((uint16_t)((stFrame.abData[1] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[2] >> 0) & 0xFF))) * 0.0001f;
            RCell027 = (float)((((uint16_t)((stFrame.abData[3] >> 0) & 0x7F)) << 8) | ((uint16_t)((stFrame.abData[4] >> 0) & 0xFF))) * 0.01f;
            BBalancingCell027 = (uint8_t)(((stFrame.abData[3] >> 0) & 0x1));
            VOpenCell027 = (float)((((uint16_t)((stFrame.abData[5] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[6] >> 0) & 0xFF))) * 0.000100000000000001f;
            break;
        case 27:
            VCell028 = (float)((((uint16_t)((stFrame.abData[1] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[2] >> 0) & 0xFF))) * 0.0001f;
            RCell028 = (float)((((uint16_t)((stFrame.abData[3] >> 0) & 0x7F)) << 8) | ((uint16_t)((stFrame.abData[4] >> 0) & 0xFF))) * 0.01f;
            BBalancingCell028 = (uint8_t)(((stFrame.abData[3] >> 0) & 0x1));
            VOpenCell028 = (float)((((uint16_t)((stFrame.abData[5] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[6] >> 0) & 0xFF))) * 0.000100000000000001f;
            break;
        case 28:
            VCell029 = (float)((((uint16_t)((stFrame.abData[1] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[2] >> 0) & 0xFF))) * 0.0001f;
            RCell029 = (float)((((uint16_t)((stFrame.abData[3] >> 0) & 0x7F)) << 8) | ((uint16_t)((stFrame.abData[4] >> 0) & 0xFF))) * 0.01f;
            BBalancingCell029 = (uint8_t)(((stFrame.abData[3] >> 0) & 0x1));
            VOpenCell029 = (float)((((uint16_t)((stFrame.abData[5] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[6] >> 0) & 0xFF))) * 0.000100000000000001f;
            break;
        case 29:
            VCell030 = (float)((((uint16_t)((stFrame.abData[1] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[2] >> 0) & 0xFF))) * 0.0001f;
            RCell030 = (float)((((uint16_t)((stFrame.abData[3] >> 0) & 0x7F)) << 8) | ((uint16_t)((stFrame.abData[4] >> 0) & 0xFF))) * 0.01f;
            BBalancingCell030 = (uint8_t)(((stFrame.abData[3] >> 0) & 0x1));
            VOpenCell030 = (float)((((uint16_t)((stFrame.abData[5] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[6] >> 0) & 0xFF))) * 0.000100000000000001f;
            break;
        case 30:
            VCell031 = (float)((((uint16_t)((stFrame.abData[1] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[2] >> 0) & 0xFF))) * 0.0001f;
            RCell031 = (float)((((uint16_t)((stFrame.abData[3] >> 0) & 0x7F)) << 8) | ((uint16_t)((stFrame.abData[4] >> 0) & 0xFF))) * 0.01f;
            BBalancingCell031 = (uint8_t)(((stFrame.abData[3] >> 0) & 0x1));
            VOpenCell031 = (float)((((uint16_t)((stFrame.abData[5] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[6] >> 0) & 0xFF))) * 0.000100000000000001f;
            break;
        case 31:
            VCell032 = (float)((((uint16_t)((stFrame.abData[1] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[2] >> 0) & 0xFF))) * 0.0001f;
            RCell032 = (float)((((uint16_t)((stFrame.abData[3] >> 0) & 0x7F)) << 8) | ((uint16_t)((stFrame.abData[4] >> 0) & 0xFF))) * 0.01f;
            BBalancingCell032 = (uint8_t)(((stFrame.abData[3] >> 0) & 0x1));
            VOpenCell032 = (float)((((uint16_t)((stFrame.abData[5] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[6] >> 0) & 0xFF))) * 0.000100000000000001f;
            break;
        case 32:
            VCell033 = (float)((((uint16_t)((stFrame.abData[1] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[2] >> 0) & 0xFF))) * 0.0001f;
            RCell033 = (float)((((uint16_t)((stFrame.abData[3] >> 0) & 0x7F)) << 8) | ((uint16_t)((stFrame.abData[4] >> 0) & 0xFF))) * 0.01f;
            BBalancingCell033 = (uint8_t)(((stFrame.abData[3] >> 0) & 0x1));
            VOpenCell033 = (float)((((uint16_t)((stFrame.abData[5] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[6] >> 0) & 0xFF))) * 0.000100000000000001f;
            break;
        case 33:
            VCell034 = (float)((((uint16_t)((stFrame.abData[1] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[2] >> 0) & 0xFF))) * 0.0001f;
            RCell034 = (float)((((uint16_t)((stFrame.abData[3] >> 0) & 0x7F)) << 8) | ((uint16_t)((stFrame.abData[4] >> 0) & 0xFF))) * 0.01f;
            BBalancingCell034 = (uint8_t)(((stFrame.abData[3] >> 0) & 0x1));
            VOpenCell034 = (float)((((uint16_t)((stFrame.abData[5] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[6] >> 0) & 0xFF))) * 0.000100000000000001f;
            break;
        case 34:
            VCell035 = (float)((((uint16_t)((stFrame.abData[1] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[2] >> 0) & 0xFF))) * 0.0001f;
            RCell035 = (float)((((uint16_t)((stFrame.abData[3] >> 0) & 0x7F)) << 8) | ((uint16_t)((stFrame.abData[4] >> 0) & 0xFF))) * 0.01f;
            BBalancingCell035 = (uint8_t)(((stFrame.abData[3] >> 0) & 0x1));
            VOpenCell035 = (float)((((uint16_t)((stFrame.abData[5] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[6] >> 0) & 0xFF))) * 0.000100000000000001f;
            break;
        case 35:
            VCell036 = (float)((((uint16_t)((stFrame.abData[1] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[2] >> 0) & 0xFF))) * 0.0001f;
            RCell036 = (float)((((uint16_t)((stFrame.abData[3] >> 0) & 0x7F)) << 8) | ((uint16_t)((stFrame.abData[4] >> 0) & 0xFF))) * 0.01f;
            BBalancingCell036 = (uint8_t)(((stFrame.abData[3] >> 0) & 0x1));
            VOpenCell036 = (float)((((uint16_t)((stFrame.abData[5] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[6] >> 0) & 0xFF))) * 0.000100000000000001f;
            break;
        case 36:
            VCell037 = (float)((((uint16_t)((stFrame.abData[1] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[2] >> 0) & 0xFF))) * 0.0001f;
            RCell037 = (float)((((uint16_t)((stFrame.abData[3] >> 0) & 0x7F)) << 8) | ((uint16_t)((stFrame.abData[4] >> 0) & 0xFF))) * 0.01f;
            BBalancingCell037 = (uint8_t)(((stFrame.abData[3] >> 0) & 0x1));
            VOpenCell037 = (float)((((uint16_t)((stFrame.abData[5] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[6] >> 0) & 0xFF))) * 0.000100000000000001f;
            break;
        case 37:
            VCell038 = (float)((((uint16_t)((stFrame.abData[1] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[2] >> 0) & 0xFF))) * 0.0001f;
            RCell038 = (float)((((uint16_t)((stFrame.abData[3] >> 0) & 0x7F)) << 8) | ((uint16_t)((stFrame.abData[4] >> 0) & 0xFF))) * 0.01f;
            BBalancingCell038 = (uint8_t)(((stFrame.abData[3] >> 0) & 0x1));
            VOpenCell038 = (float)((((uint16_t)((stFrame.abData[5] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[6] >> 0) & 0xFF))) * 0.000100000000000001f;
            break;
        case 38:
            VCell039 = (float)((((uint16_t)((stFrame.abData[1] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[2] >> 0) & 0xFF))) * 0.0001f;
            RCell039 = (float)((((uint16_t)((stFrame.abData[3] >> 0) & 0x7F)) << 8) | ((uint16_t)((stFrame.abData[4] >> 0) & 0xFF))) * 0.01f;
            BBalancingCell039 = (uint8_t)(((stFrame.abData[3] >> 0) & 0x1));
            VOpenCell039 = (float)((((uint16_t)((stFrame.abData[5] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[6] >> 0) & 0xFF))) * 0.000100000000000001f;
            break;
        case 39:
            VCell040 = (float)((((uint16_t)((stFrame.abData[1] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[2] >> 0) & 0xFF))) * 0.0001f;
            RCell040 = (float)((((uint16_t)((stFrame.abData[3] >> 0) & 0x7F)) << 8) | ((uint16_t)((stFrame.abData[4] >> 0) & 0xFF))) * 0.01f;
            BBalancingCell040 = (uint8_t)(((stFrame.abData[3] >> 0) & 0x1));
            VOpenCell040 = (float)((((uint16_t)((stFrame.abData[5] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[6] >> 0) & 0xFF))) * 0.000100000000000001f;
            break;
        case 40:
            VCell041 = (float)((((uint16_t)((stFrame.abData[1] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[2] >> 0) & 0xFF))) * 0.0001f;
            RCell041 = (float)((((uint16_t)((stFrame.abData[3] >> 0) & 0x7F)) << 8) | ((uint16_t)((stFrame.abData[4] >> 0) & 0xFF))) * 0.01f;
            BBalancingCell041 = (uint8_t)(((stFrame.abData[3] >> 0) & 0x1));
            VOpenCell041 = (float)((((uint16_t)((stFrame.abData[5] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[6] >> 0) & 0xFF))) * 0.000100000000000001f;
            break;
        case 41:
            VCell042 = (float)((((uint16_t)((stFrame.abData[1] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[2] >> 0) & 0xFF))) * 0.0001f;
            RCell042 = (float)((((uint16_t)((stFrame.abData[3] >> 0) & 0x7F)) << 8) | ((uint16_t)((stFrame.abData[4] >> 0) & 0xFF))) * 0.01f;
            BBalancingCell042 = (uint8_t)(((stFrame.abData[3] >> 0) & 0x1));
            VOpenCell042 = (float)((((uint16_t)((stFrame.abData[5] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[6] >> 0) & 0xFF))) * 0.000100000000000001f;
            break;
        case 42:
            VCell043 = (float)((((uint16_t)((stFrame.abData[1] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[2] >> 0) & 0xFF))) * 0.0001f;
            RCell043 = (float)((((uint16_t)((stFrame.abData[3] >> 0) & 0x7F)) << 8) | ((uint16_t)((stFrame.abData[4] >> 0) & 0xFF))) * 0.01f;
            BBalancingCell043 = (uint8_t)(((stFrame.abData[3] >> 0) & 0x1));
            VOpenCell043 = (float)((((uint16_t)((stFrame.abData[5] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[6] >> 0) & 0xFF))) * 0.000100000000000001f;
            break;
        case 43:
            VCell044 = (float)((((uint16_t)((stFrame.abData[1] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[2] >> 0) & 0xFF))) * 0.0001f;
            RCell044 = (float)((((uint16_t)((stFrame.abData[3] >> 0) & 0x7F)) << 8) | ((uint16_t)((stFrame.abData[4] >> 0) & 0xFF))) * 0.01f;
            BBalancingCell044 = (uint8_t)(((stFrame.abData[3] >> 0) & 0x1));
            VOpenCell044 = (float)((((uint16_t)((stFrame.abData[5] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[6] >> 0) & 0xFF))) * 0.000100000000000001f;
            break;
        case 44:
            VCell045 = (float)((((uint16_t)((stFrame.abData[1] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[2] >> 0) & 0xFF))) * 0.0001f;
            RCell045 = (float)((((uint16_t)((stFrame.abData[3] >> 0) & 0x7F)) << 8) | ((uint16_t)((stFrame.abData[4] >> 0) & 0xFF))) * 0.01f;
            BBalancingCell045 = (uint8_t)(((stFrame.abData[3] >> 0) & 0x1));
            VOpenCell045 = (float)((((uint16_t)((stFrame.abData[5] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[6] >> 0) & 0xFF))) * 0.000100000000000001f;
            break;
        case 45:
            VCell046 = (float)((((uint16_t)((stFrame.abData[1] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[2] >> 0) & 0xFF))) * 0.0001f;
            RCell046 = (float)((((uint16_t)((stFrame.abData[3] >> 0) & 0x7F)) << 8) | ((uint16_t)((stFrame.abData[4] >> 0) & 0xFF))) * 0.01f;
            BBalancingCell046 = (uint8_t)(((stFrame.abData[3] >> 0) & 0x1));
            VOpenCell046 = (float)((((uint16_t)((stFrame.abData[5] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[6] >> 0) & 0xFF))) * 0.000100000000000001f;
            break;
        case 46:
            VCell047 = (float)((((uint16_t)((stFrame.abData[1] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[2] >> 0) & 0xFF))) * 0.0001f;
            RCell047 = (float)((((uint16_t)((stFrame.abData[3] >> 0) & 0x7F)) << 8) | ((uint16_t)((stFrame.abData[4] >> 0) & 0xFF))) * 0.01f;
            BBalancingCell047 = (uint8_t)(((stFrame.abData[3] >> 0) & 0x1));
            VOpenCell047 = (float)((((uint16_t)((stFrame.abData[5] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[6] >> 0) & 0xFF))) * 0.000100000000000001f;
            break;
        case 47:
            VCell048 = (float)((((uint16_t)((stFrame.abData[1] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[2] >> 0) & 0xFF))) * 0.0001f;
            RCell048 = (float)((((uint16_t)((stFrame.abData[3] >> 0) & 0x7F)) << 8) | ((uint16_t)((stFrame.abData[4] >> 0) & 0xFF))) * 0.01f;
            BBalancingCell048 = (uint8_t)(((stFrame.abData[3] >> 0) & 0x1));
            VOpenCell048 = (float)((((uint16_t)((stFrame.abData[5] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[6] >> 0) & 0xFF))) * 0.000100000000000001f;
            break;
        case 48:
            VCell049 = (float)((((uint16_t)((stFrame.abData[1] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[2] >> 0) & 0xFF))) * 0.0001f;
            RCell049 = (float)((((uint16_t)((stFrame.abData[3] >> 0) & 0x7F)) << 8) | ((uint16_t)((stFrame.abData[4] >> 0) & 0xFF))) * 0.01f;
            BBalancingCell049 = (uint8_t)(((stFrame.abData[3] >> 0) & 0x1));
            VOpenCell049 = (float)((((uint16_t)((stFrame.abData[5] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[6] >> 0) & 0xFF))) * 0.000100000000000001f;
            break;
        case 49:
            VCell050 = (float)((((uint16_t)((stFrame.abData[1] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[2] >> 0) & 0xFF))) * 0.0001f;
            RCell050 = (float)((((uint16_t)((stFrame.abData[3] >> 0) & 0x7F)) << 8) | ((uint16_t)((stFrame.abData[4] >> 0) & 0xFF))) * 0.01f;
            BBalancingCell050 = (uint8_t)(((stFrame.abData[3] >> 0) & 0x1));
            VOpenCell050 = (float)((((uint16_t)((stFrame.abData[5] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[6] >> 0) & 0xFF))) * 0.000100000000000001f;
            break;
        case 50:
            VCell051 = (float)((((uint16_t)((stFrame.abData[1] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[2] >> 0) & 0xFF))) * 0.0001f;
            RCell051 = (float)((((uint16_t)((stFrame.abData[3] >> 0) & 0x7F)) << 8) | ((uint16_t)((stFrame.abData[4] >> 0) & 0xFF))) * 0.01f;
            BBalancingCell051 = (uint8_t)(((stFrame.abData[3] >> 0) & 0x1));
            VOpenCell051 = (float)((((uint16_t)((stFrame.abData[5] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[6] >> 0) & 0xFF))) * 0.000100000000000001f;
            break;
        case 51:
            VCell052 = (float)((((uint16_t)((stFrame.abData[1] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[2] >> 0) & 0xFF))) * 0.0001f;
            RCell052 = (float)((((uint16_t)((stFrame.abData[3] >> 0) & 0x7F)) << 8) | ((uint16_t)((stFrame.abData[4] >> 0) & 0xFF))) * 0.01f;
            BBalancingCell052 = (uint8_t)(((stFrame.abData[3] >> 0) & 0x1));
            VOpenCell052 = (float)((((uint16_t)((stFrame.abData[5] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[6] >> 0) & 0xFF))) * 0.000100000000000001f;
            break;
        case 52:
            VCell053 = (float)((((uint16_t)((stFrame.abData[1] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[2] >> 0) & 0xFF))) * 0.0001f;
            RCell053 = (float)((((uint16_t)((stFrame.abData[3] >> 0) & 0x7F)) << 8) | ((uint16_t)((stFrame.abData[4] >> 0) & 0xFF))) * 0.01f;
            BBalancingCell053 = (uint8_t)(((stFrame.abData[3] >> 0) & 0x1));
            VOpenCell053 = (float)((((uint16_t)((stFrame.abData[5] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[6] >> 0) & 0xFF))) * 0.000100000000000001f;
            break;
        case 53:
            VCell054 = (float)((((uint16_t)((stFrame.abData[1] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[2] >> 0) & 0xFF))) * 0.0001f;
            RCell054 = (float)((((uint16_t)((stFrame.abData[3] >> 0) & 0x7F)) << 8) | ((uint16_t)((stFrame.abData[4] >> 0) & 0xFF))) * 0.01f;
            BBalancingCell054 = (uint8_t)(((stFrame.abData[3] >> 0) & 0x1));
            VOpenCell054 = (float)((((uint16_t)((stFrame.abData[5] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[6] >> 0) & 0xFF))) * 0.000100000000000001f;
            break;
        case 54:
            VCell055 = (float)((((uint16_t)((stFrame.abData[1] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[2] >> 0) & 0xFF))) * 0.0001f;
            RCell055 = (float)((((uint16_t)((stFrame.abData[3] >> 0) & 0x7F)) << 8) | ((uint16_t)((stFrame.abData[4] >> 0) & 0xFF))) * 0.01f;
            BBalancingCell055 = (uint8_t)(((stFrame.abData[3] >> 0) & 0x1));
            VOpenCell055 = (float)((((uint16_t)((stFrame.abData[5] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[6] >> 0) & 0xFF))) * 0.000100000000000001f;
            break;
        case 55:
            VCell056 = (float)((((uint16_t)((stFrame.abData[1] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[2] >> 0) & 0xFF))) * 0.0001f;
            RCell056 = (float)((((uint16_t)((stFrame.abData[3] >> 0) & 0x7F)) << 8) | ((uint16_t)((stFrame.abData[4] >> 0) & 0xFF))) * 0.01f;
            BBalancingCell056 = (uint8_t)(((stFrame.abData[3] >> 0) & 0x1));
            VOpenCell056 = (float)((((uint16_t)((stFrame.abData[5] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[6] >> 0) & 0xFF))) * 0.000100000000000001f;
            break;
        case 56:
            VCell057 = (float)((((uint16_t)((stFrame.abData[1] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[2] >> 0) & 0xFF))) * 0.0001f;
            RCell057 = (float)((((uint16_t)((stFrame.abData[3] >> 0) & 0x7F)) << 8) | ((uint16_t)((stFrame.abData[4] >> 0) & 0xFF))) * 0.01f;
            BBalancingCell057 = (uint8_t)(((stFrame.abData[3] >> 0) & 0x1));
            VOpenCell057 = (float)((((uint16_t)((stFrame.abData[5] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[6] >> 0) & 0xFF))) * 0.000100000000000001f;
            break;
        case 57:
            VCell058 = (float)((((uint16_t)((stFrame.abData[1] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[2] >> 0) & 0xFF))) * 0.0001f;
            RCell058 = (float)((((uint16_t)((stFrame.abData[3] >> 0) & 0x7F)) << 8) | ((uint16_t)((stFrame.abData[4] >> 0) & 0xFF))) * 0.01f;
            BBalancingCell058 = (uint8_t)(((stFrame.abData[3] >> 0) & 0x1));
            VOpenCell058 = (float)((((uint16_t)((stFrame.abData[5] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[6] >> 0) & 0xFF))) * 0.000100000000000001f;
            break;
        case 58:
            VCell059 = (float)((((uint16_t)((stFrame.abData[1] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[2] >> 0) & 0xFF))) * 0.0001f;
            RCell059 = (float)((((uint16_t)((stFrame.abData[3] >> 0) & 0x7F)) << 8) | ((uint16_t)((stFrame.abData[4] >> 0) & 0xFF))) * 0.01f;
            BBalancingCell059 = (uint8_t)(((stFrame.abData[3] >> 0) & 0x1));
            VOpenCell059 = (float)((((uint16_t)((stFrame.abData[5] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[6] >> 0) & 0xFF))) * 0.000100000000000001f;
            break;
        case 59:
            VCell060 = (float)((((uint16_t)((stFrame.abData[1] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[2] >> 0) & 0xFF))) * 0.0001f;
            RCell060 = (float)((((uint16_t)((stFrame.abData[3] >> 0) & 0x7F)) << 8) | ((uint16_t)((stFrame.abData[4] >> 0) & 0xFF))) * 0.01f;
            BBalancingCell060 = (uint8_t)(((stFrame.abData[3] >> 0) & 0x1));
            VOpenCell060 = (float)((((uint16_t)((stFrame.abData[5] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[6] >> 0) & 0xFF))) * 0.000100000000000001f;
            break;
        case 60:
            VCell061 = (float)((((uint16_t)((stFrame.abData[1] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[2] >> 0) & 0xFF))) * 0.0001f;
            RCell061 = (float)((((uint16_t)((stFrame.abData[3] >> 0) & 0x7F)) << 8) | ((uint16_t)((stFrame.abData[4] >> 0) & 0xFF))) * 0.01f;
            BBalancingCell061 = (uint8_t)(((stFrame.abData[3] >> 0) & 0x1));
            VOpenCell061 = (float)((((uint16_t)((stFrame.abData[5] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[6] >> 0) & 0xFF))) * 0.000100000000000001f;
            break;
        case 61:
            VCell062 = (float)((((uint16_t)((stFrame.abData[1] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[2] >> 0) & 0xFF))) * 0.0001f;
            RCell062 = (float)((((uint16_t)((stFrame.abData[3] >> 0) & 0x7F)) << 8) | ((uint16_t)((stFrame.abData[4] >> 0) & 0xFF))) * 0.01f;
            BBalancingCell062 = (uint8_t)(((stFrame.abData[3] >> 0) & 0x1));
            VOpenCell062 = (float)((((uint16_t)((stFrame.abData[5] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[6] >> 0) & 0xFF))) * 0.000100000000000001f;
            break;
        case 62:
            VCell063 = (float)((((uint16_t)((stFrame.abData[1] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[2] >> 0) & 0xFF))) * 0.0001f;
            RCell063 = (float)((((uint16_t)((stFrame.abData[3] >> 0) & 0x7F)) << 8) | ((uint16_t)((stFrame.abData[4] >> 0) & 0xFF))) * 0.01f;
            BBalancingCell063 = (uint8_t)(((stFrame.abData[3] >> 0) & 0x1));
            VOpenCell063 = (float)((((uint16_t)((stFrame.abData[5] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[6] >> 0) & 0xFF))) * 0.000100000000000001f;
            break;
        case 63:
            VCell064 = (float)((((uint16_t)((stFrame.abData[1] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[2] >> 0) & 0xFF))) * 0.0001f;
            RCell064 = (float)((((uint16_t)((stFrame.abData[3] >> 0) & 0x7F)) << 8) | ((uint16_t)((stFrame.abData[4] >> 0) & 0xFF))) * 0.01f;
            BBalancingCell064 = (uint8_t)(((stFrame.abData[3] >> 0) & 0x1));
            VOpenCell064 = (float)((((uint16_t)((stFrame.abData[5] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[6] >> 0) & 0xFF))) * 0.000100000000000001f;
            break;
        case 64:
            VCell065 = (float)((((uint16_t)((stFrame.abData[1] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[2] >> 0) & 0xFF))) * 0.0001f;
            RCell065 = (float)((((uint16_t)((stFrame.abData[3] >> 0) & 0x7F)) << 8) | ((uint16_t)((stFrame.abData[4] >> 0) & 0xFF))) * 0.01f;
            BBalancingCell065 = (uint8_t)(((stFrame.abData[3] >> 0) & 0x1));
            VOpenCell065 = (float)((((uint16_t)((stFrame.abData[5] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[6] >> 0) & 0xFF))) * 0.000100000000000001f;
            break;
        case 65:
            VCell066 = (float)((((uint16_t)((stFrame.abData[1] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[2] >> 0) & 0xFF))) * 0.0001f;
            RCell066 = (float)((((uint16_t)((stFrame.abData[3] >> 0) & 0x7F)) << 8) | ((uint16_t)((stFrame.abData[4] >> 0) & 0xFF))) * 0.01f;
            BBalancingCell066 = (uint8_t)(((stFrame.abData[3] >> 0) & 0x1));
            VOpenCell066 = (float)((((uint16_t)((stFrame.abData[5] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[6] >> 0) & 0xFF))) * 0.000100000000000001f;
            break;
        case 66:
            VCell067 = (float)((((uint16_t)((stFrame.abData[1] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[2] >> 0) & 0xFF))) * 0.0001f;
            RCell067 = (float)((((uint16_t)((stFrame.abData[3] >> 0) & 0x7F)) << 8) | ((uint16_t)((stFrame.abData[4] >> 0) & 0xFF))) * 0.01f;
            BBalancingCell067 = (uint8_t)(((stFrame.abData[3] >> 0) & 0x1));
            VOpenCell067 = (float)((((uint16_t)((stFrame.abData[5] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[6] >> 0) & 0xFF))) * 0.000100000000000001f;
            break;
        case 67:
            VCell068 = (float)((((uint16_t)((stFrame.abData[1] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[2] >> 0) & 0xFF))) * 0.0001f;
            RCell068 = (float)((((uint16_t)((stFrame.abData[3] >> 0) & 0x7F)) << 8) | ((uint16_t)((stFrame.abData[4] >> 0) & 0xFF))) * 0.01f;
            BBalancingCell068 = (uint8_t)(((stFrame.abData[3] >> 0) & 0x1));
            VOpenCell068 = (float)((((uint16_t)((stFrame.abData[5] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[6] >> 0) & 0xFF))) * 0.000100000000000001f;
            break;
        case 68:
            VCell069 = (float)((((uint16_t)((stFrame.abData[1] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[2] >> 0) & 0xFF))) * 0.0001f;
            RCell069 = (float)((((uint16_t)((stFrame.abData[3] >> 0) & 0x7F)) << 8) | ((uint16_t)((stFrame.abData[4] >> 0) & 0xFF))) * 0.01f;
            BBalancingCell069 = (uint8_t)(((stFrame.abData[3] >> 0) & 0x1));
            VOpenCell069 = (float)((((uint16_t)((stFrame.abData[5] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[6] >> 0) & 0xFF))) * 0.000100000000000001f;
            break;
        case 69:
            VCell070 = (float)((((uint16_t)((stFrame.abData[1] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[2] >> 0) & 0xFF))) * 0.0001f;
            RCell070 = (float)((((uint16_t)((stFrame.abData[3] >> 0) & 0x7F)) << 8) | ((uint16_t)((stFrame.abData[4] >> 0) & 0xFF))) * 0.01f;
            BBalancingCell070 = (uint8_t)(((stFrame.abData[3] >> 0) & 0x1));
            VOpenCell070 = (float)((((uint16_t)((stFrame.abData[5] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[6] >> 0) & 0xFF))) * 0.000100000000000001f;
            break;
        case 70:
            VCell071 = (float)((((uint16_t)((stFrame.abData[1] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[2] >> 0) & 0xFF))) * 0.0001f;
            RCell071 = (float)((((uint16_t)((stFrame.abData[3] >> 0) & 0x7F)) << 8) | ((uint16_t)((stFrame.abData[4] >> 0) & 0xFF))) * 0.01f;
            BBalancingCell071 = (uint8_t)(((stFrame.abData[3] >> 0) & 0x1));
            VOpenCell071 = (float)((((uint16_t)((stFrame.abData[5] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[6] >> 0) & 0xFF))) * 0.000100000000000001f;
            break;
        case 71:
            VCell072 = (float)((((uint16_t)((stFrame.abData[1] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[2] >> 0) & 0xFF))) * 0.0001f;
            RCell072 = (float)((((uint16_t)((stFrame.abData[3] >> 0) & 0x7F)) << 8) | ((uint16_t)((stFrame.abData[4] >> 0) & 0xFF))) * 0.01f;
            BBalancingCell072 = (uint8_t)(((stFrame.abData[3] >> 0) & 0x1));
            VOpenCell072 = (float)((((uint16_t)((stFrame.abData[5] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[6] >> 0) & 0xFF))) * 0.000100000000000001f;
            break;
        case 72:
            VCell073 = (float)((((uint16_t)((stFrame.abData[1] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[2] >> 0) & 0xFF))) * 0.0001f;
            RCell073 = (float)((((uint16_t)((stFrame.abData[3] >> 0) & 0x7F)) << 8) | ((uint16_t)((stFrame.abData[4] >> 0) & 0xFF))) * 0.01f;
            BBalancingCell073 = (uint8_t)(((stFrame.abData[3] >> 0) & 0x1));
            VOpenCell073 = (float)((((uint16_t)((stFrame.abData[5] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[6] >> 0) & 0xFF))) * 0.000100000000000001f;
            break;
        case 73:
            VCell074 = (float)((((uint16_t)((stFrame.abData[1] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[2] >> 0) & 0xFF))) * 0.0001f;
            RCell074 = (float)((((uint16_t)((stFrame.abData[3] >> 0) & 0x7F)) << 8) | ((uint16_t)((stFrame.abData[4] >> 0) & 0xFF))) * 0.01f;
            BBalancingCell074 = (uint8_t)(((stFrame.abData[3] >> 0) & 0x1));
            VOpenCell074 = (float)((((uint16_t)((stFrame.abData[5] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[6] >> 0) & 0xFF))) * 0.000100000000000001f;
            break;
        case 74:
            VCell075 = (float)((((uint16_t)((stFrame.abData[1] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[2] >> 0) & 0xFF))) * 0.0001f;
            RCell075 = (float)((((uint16_t)((stFrame.abData[3] >> 0) & 0x7F)) << 8) | ((uint16_t)((stFrame.abData[4] >> 0) & 0xFF))) * 0.01f;
            BBalancingCell075 = (uint8_t)(((stFrame.abData[3] >> 0) & 0x1));
            VOpenCell075 = (float)((((uint16_t)((stFrame.abData[5] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[6] >> 0) & 0xFF))) * 0.000100000000000001f;
            break;
        case 75:
            VCell076 = (float)((((uint16_t)((stFrame.abData[1] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[2] >> 0) & 0xFF))) * 0.0001f;
            RCell076 = (float)((((uint16_t)((stFrame.abData[3] >> 0) & 0x7F)) << 8) | ((uint16_t)((stFrame.abData[4] >> 0) & 0xFF))) * 0.01f;
            BBalancingCell076 = (uint8_t)(((stFrame.abData[3] >> 0) & 0x1));
            VOpenCell076 = (float)((((uint16_t)((stFrame.abData[5] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[6] >> 0) & 0xFF))) * 0.000100000000000001f;
            break;
        case 76:
            VCell077 = (float)((((uint16_t)((stFrame.abData[1] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[2] >> 0) & 0xFF))) * 0.0001f;
            RCell077 = (float)((((uint16_t)((stFrame.abData[3] >> 0) & 0x7F)) << 8) | ((uint16_t)((stFrame.abData[4] >> 0) & 0xFF))) * 0.01f;
            BBalancingCell077 = (uint8_t)(((stFrame.abData[3] >> 0) & 0x1));
            VOpenCell077 = (float)((((uint16_t)((stFrame.abData[5] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[6] >> 0) & 0xFF))) * 0.000100000000000001f;
            break;
        case 77:
            VCell078 = (float)((((uint16_t)((stFrame.abData[1] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[2] >> 0) & 0xFF))) * 0.0001f;
            RCell078 = (float)((((uint16_t)((stFrame.abData[3] >> 0) & 0x7F)) << 8) | ((uint16_t)((stFrame.abData[4] >> 0) & 0xFF))) * 0.01f;
            BBalancingCell078 = (uint8_t)(((stFrame.abData[3] >> 0) & 0x1));
            VOpenCell078 = (float)((((uint16_t)((stFrame.abData[5] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[6] >> 0) & 0xFF))) * 0.000100000000000001f;
            break;
        case 78:
            VCell079 = (float)((((uint16_t)((stFrame.abData[1] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[2] >> 0) & 0xFF))) * 0.0001f;
            RCell079 = (float)((((uint16_t)((stFrame.abData[3] >> 0) & 0x7F)) << 8) | ((uint16_t)((stFrame.abData[4] >> 0) & 0xFF))) * 0.01f;
            BBalancingCell079 = (uint8_t)(((stFrame.abData[3] >> 0) & 0x1));
            VOpenCell079 = (float)((((uint16_t)((stFrame.abData[5] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[6] >> 0) & 0xFF))) * 0.000100000000000001f;
            break;
        case 79:
            VCell080 = (float)((((uint16_t)((stFrame.abData[1] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[2] >> 0) & 0xFF))) * 0.0001f;
            RCell080 = (float)((((uint16_t)((stFrame.abData[3] >> 0) & 0x7F)) << 8) | ((uint16_t)((stFrame.abData[4] >> 0) & 0xFF))) * 0.01f;
            BBalancingCell080 = (uint8_t)(((stFrame.abData[3] >> 0) & 0x1));
            VOpenCell080 = (float)((((uint16_t)((stFrame.abData[5] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[6] >> 0) & 0xFF))) * 0.000100000000000001f;
            break;
        case 80:
            VCell081 = (float)((((uint16_t)((stFrame.abData[1] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[2] >> 0) & 0xFF))) * 0.0001f;
            RCell081 = (float)((((uint16_t)((stFrame.abData[3] >> 0) & 0x7F)) << 8) | ((uint16_t)((stFrame.abData[4] >> 0) & 0xFF))) * 0.01f;
            BBalancingCell081 = (uint8_t)(((stFrame.abData[3] >> 0) & 0x1));
            VOpenCell081 = (float)((((uint16_t)((stFrame.abData[5] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[6] >> 0) & 0xFF))) * 0.000100000000000001f;
            break;
        case 81:
            VCell082 = (float)((((uint16_t)((stFrame.abData[1] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[2] >> 0) & 0xFF))) * 0.0001f;
            RCell082 = (float)((((uint16_t)((stFrame.abData[3] >> 0) & 0x7F)) << 8) | ((uint16_t)((stFrame.abData[4] >> 0) & 0xFF))) * 0.01f;
            BBalancingCell082 = (uint8_t)(((stFrame.abData[3] >> 0) & 0x1));
            VOpenCell082 = (float)((((uint16_t)((stFrame.abData[5] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[6] >> 0) & 0xFF))) * 0.000100000000000001f;
            break;
        case 82:
            VCell083 = (float)((((uint16_t)((stFrame.abData[1] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[2] >> 0) & 0xFF))) * 0.0001f;
            RCell083 = (float)((((uint16_t)((stFrame.abData[3] >> 0) & 0x7F)) << 8) | ((uint16_t)((stFrame.abData[4] >> 0) & 0xFF))) * 0.01f;
            BBalancingCell083 = (uint8_t)(((stFrame.abData[3] >> 0) & 0x1));
            VOpenCell083 = (float)((((uint16_t)((stFrame.abData[5] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[6] >> 0) & 0xFF))) * 0.000100000000000001f;
            break;
        case 83:
            VCell084 = (float)((((uint16_t)((stFrame.abData[1] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[2] >> 0) & 0xFF))) * 0.0001f;
            RCell084 = (float)((((uint16_t)((stFrame.abData[3] >> 0) & 0x7F)) << 8) | ((uint16_t)((stFrame.abData[4] >> 0) & 0xFF))) * 0.01f;
            BBalancingCell084 = (uint8_t)(((stFrame.abData[3] >> 0) & 0x1));
            VOpenCell084 = (float)((((uint16_t)((stFrame.abData[5] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[6] >> 0) & 0xFF))) * 0.000100000000000001f;
            break;
        case 84:
            VCell085 = (float)((((uint16_t)((stFrame.abData[1] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[2] >> 0) & 0xFF))) * 0.0001f;
            RCell085 = (float)((((uint16_t)((stFrame.abData[3] >> 0) & 0x7F)) << 8) | ((uint16_t)((stFrame.abData[4] >> 0) & 0xFF))) * 0.01f;
            BBalancingCell085 = (uint8_t)(((stFrame.abData[3] >> 0) & 0x1));
            VOpenCell085 = (float)((((uint16_t)((stFrame.abData[5] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[6] >> 0) & 0xFF))) * 0.000100000000000001f;
            break;
        case 85:
            VCell086 = (float)((((uint16_t)((stFrame.abData[1] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[2] >> 0) & 0xFF))) * 0.0001f;
            RCell086 = (float)((((uint16_t)((stFrame.abData[3] >> 0) & 0x7F)) << 8) | ((uint16_t)((stFrame.abData[4] >> 0) & 0xFF))) * 0.01f;
            BBalancingCell086 = (uint8_t)(((stFrame.abData[3] >> 0) & 0x1));
            VOpenCell086 = (float)((((uint16_t)((stFrame.abData[5] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[6] >> 0) & 0xFF))) * 0.000100000000000001f;
            break;
        case 86:
            VCell087 = (float)((((uint16_t)((stFrame.abData[1] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[2] >> 0) & 0xFF))) * 0.0001f;
            RCell087 = (float)((((uint16_t)((stFrame.abData[3] >> 0) & 0x7F)) << 8) | ((uint16_t)((stFrame.abData[4] >> 0) & 0xFF))) * 0.01f;
            BBalancingCell087 = (uint8_t)(((stFrame.abData[3] >> 0) & 0x1));
            VOpenCell087 = (float)((((uint16_t)((stFrame.abData[5] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[6] >> 0) & 0xFF))) * 0.000100000000000001f;
            break;
        case 87:
            VCell088 = (float)((((uint16_t)((stFrame.abData[1] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[2] >> 0) & 0xFF))) * 0.0001f;
            RCell088 = (float)((((uint16_t)((stFrame.abData[3] >> 0) & 0x7F)) << 8) | ((uint16_t)((stFrame.abData[4] >> 0) & 0xFF))) * 0.01f;
            BBalancingCell088 = (uint8_t)(((stFrame.abData[3] >> 0) & 0x1));
            VOpenCell088 = (float)((((uint16_t)((stFrame.abData[5] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[6] >> 0) & 0xFF))) * 0.000100000000000001f;
            break;
        case 88:
            VCell089 = (float)((((uint16_t)((stFrame.abData[1] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[2] >> 0) & 0xFF))) * 0.0001f;
            RCell089 = (float)((((uint16_t)((stFrame.abData[3] >> 0) & 0x7F)) << 8) | ((uint16_t)((stFrame.abData[4] >> 0) & 0xFF))) * 0.01f;
            BBalancingCell089 = (uint8_t)(((stFrame.abData[3] >> 0) & 0x1));
            VOpenCell089 = (float)((((uint16_t)((stFrame.abData[5] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[6] >> 0) & 0xFF))) * 0.000100000000000001f;
            break;
        case 89:
            VCell090 = (float)((((uint16_t)((stFrame.abData[1] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[2] >> 0) & 0xFF))) * 0.000100000000000001f;
            RCell090 = (float)((((uint16_t)((stFrame.abData[3] >> 0) & 0x7F)) << 8) | ((uint16_t)((stFrame.abData[4] >> 0) & 0xFF))) * 0.01f;
            BBalancingCell090 = (uint8_t)(((stFrame.abData[3] >> 0) & 0x1));
            VOpenCell090 = (float)((((uint16_t)((stFrame.abData[5] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[6] >> 0) & 0xFF))) * 0.000100000000000001f;
            break;
        case 90:
            VCell091 = (float)((((uint16_t)((stFrame.abData[1] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[2] >> 0) & 0xFF))) * 0.000100000000000001f;
            RCell091 = (float)((((uint16_t)((stFrame.abData[3] >> 0) & 0x7F)) << 8) | ((uint16_t)((stFrame.abData[4] >> 0) & 0xFF))) * 0.01f;
            BBalancingCell091 = (uint8_t)(((stFrame.abData[3] >> 0) & 0x1));
            VOpenCell091 = (float)((((uint16_t)((stFrame.abData[5] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[6] >> 0) & 0xFF))) * 0.000100000000000001f;
            break;
        case 91:
            VCell092 = (float)((((uint16_t)((stFrame.abData[1] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[2] >> 0) & 0xFF))) * 0.000100000000000001f;
            RCell092 = (float)((((uint16_t)((stFrame.abData[3] >> 0) & 0x7F)) << 8) | ((uint16_t)((stFrame.abData[4] >> 0) & 0xFF))) * 0.01f;
            BBalancingCell092 = (uint8_t)(((stFrame.abData[3] >> 0) & 0x1));
            VOpenCell092 = (float)((((uint16_t)((stFrame.abData[5] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[6] >> 0) & 0xFF))) * 0.000100000000000001f;
            break;
        case 92:
            VCell093 = (float)((((uint16_t)((stFrame.abData[1] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[2] >> 0) & 0xFF))) * 0.000100000000000001f;
            RCell093 = (float)((((uint16_t)((stFrame.abData[3] >> 0) & 0x7F)) << 8) | ((uint16_t)((stFrame.abData[4] >> 0) & 0xFF))) * 0.01f;
            BBalancingCell093 = (uint8_t)(((stFrame.abData[3] >> 0) & 0x1));
            VOpenCell093 = (float)((((uint16_t)((stFrame.abData[5] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[6] >> 0) & 0xFF))) * 0.000100000000000001f;
            break;
        case 93:
            VCell094 = (float)((((uint16_t)((stFrame.abData[1] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[2] >> 0) & 0xFF))) * 0.000100000000000001f;
            RCell094 = (float)((((uint16_t)((stFrame.abData[3] >> 0) & 0x7F)) << 8) | ((uint16_t)((stFrame.abData[4] >> 0) & 0xFF))) * 0.01f;
            BBalancingCell094 = (uint8_t)(((stFrame.abData[3] >> 0) & 0x1));
            VOpenCell094 = (float)((((uint16_t)((stFrame.abData[5] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[6] >> 0) & 0xFF))) * 0.000100000000000001f;
            break;
        case 94:
            VCell095 = (float)((((uint16_t)((stFrame.abData[1] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[2] >> 0) & 0xFF))) * 0.000100000000000001f;
            RCell095 = (float)((((uint16_t)((stFrame.abData[3] >> 0) & 0x7F)) << 8) | ((uint16_t)((stFrame.abData[4] >> 0) & 0xFF))) * 0.01f;
            BBalancingCell095 = (uint8_t)(((stFrame.abData[3] >> 0) & 0x1));
            VOpenCell095 = (float)((((uint16_t)((stFrame.abData[5] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[6] >> 0) & 0xFF))) * 0.000100000000000001f;
            break;
        case 95:
            VCell096 = (float)((((uint16_t)((stFrame.abData[1] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[2] >> 0) & 0xFF))) * 0.000100000000000001f;
            RCell096 = (float)((((uint16_t)((stFrame.abData[3] >> 0) & 0x7F)) << 8) | ((uint16_t)((stFrame.abData[4] >> 0) & 0xFF))) * 0.01f;
            BBalancingCell096 = (uint8_t)(((stFrame.abData[3] >> 0) & 0x1));
            VOpenCell096 = (float)((((uint16_t)((stFrame.abData[5] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[6] >> 0) & 0xFF))) * 0.000100000000000001f;
            break;
        case 96:
            VCell097 = (float)((((uint16_t)((stFrame.abData[1] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[2] >> 0) & 0xFF))) * 0.000100000000000001f;
            RCell097 = (float)((((uint16_t)((stFrame.abData[3] >> 0) & 0x7F)) << 8) | ((uint16_t)((stFrame.abData[4] >> 0) & 0xFF))) * 0.01f;
            BBalancingCell097 = (uint8_t)(((stFrame.abData[3] >> 0) & 0x1));
            VOpenCell097 = (float)((((uint16_t)((stFrame.abData[5] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[6] >> 0) & 0xFF))) * 0.000100000000000001f;
            break;
        case 97:
            VCell098 = (float)((((uint16_t)((stFrame.abData[1] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[2] >> 0) & 0xFF))) * 0.000100000000000001f;
            RCell098 = (float)((((uint16_t)((stFrame.abData[3] >> 0) & 0x7F)) << 8) | ((uint16_t)((stFrame.abData[4] >> 0) & 0xFF))) * 0.01f;
            BBalancingCell098 = (uint8_t)(((stFrame.abData[3] >> 0) & 0x1));
            VOpenCell098 = (float)((((uint16_t)((stFrame.abData[5] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[6] >> 0) & 0xFF))) * 0.000100000000000001f;
            break;
        case 98:
            VCell099 = (float)((((uint16_t)((stFrame.abData[1] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[2] >> 0) & 0xFF))) * 0.000100000000000001f;
            RCell099 = (float)((((uint16_t)((stFrame.abData[3] >> 0) & 0x7F)) << 8) | ((uint16_t)((stFrame.abData[4] >> 0) & 0xFF))) * 0.01f;
            BBalancingCell099 = (uint8_t)(((stFrame.abData[3] >> 0) & 0x1));
            VOpenCell099 = (float)((((uint16_t)((stFrame.abData[5] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[6] >> 0) & 0xFF))) * 0.000100000000000001f;
            break;
        case 99:
            VCell100 = (float)((((uint16_t)((stFrame.abData[1] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[2] >> 0) & 0xFF))) * 0.000100000000000001f;
            RCell100 = (float)((((uint16_t)((stFrame.abData[3] >> 0) & 0x7F)) << 8) | ((uint16_t)((stFrame.abData[4] >> 0) & 0xFF))) * 0.01f;
            BBalancingCell100 = (uint8_t)(((stFrame.abData[3] >> 0) & 0x1));
            VOpenCell100 = (float)((((uint16_t)((stFrame.abData[5] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[6] >> 0) & 0xFF))) * 0.000100000000000001f;
            break;
        case 100:
            VCell101 = (float)((((uint16_t)((stFrame.abData[1] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[2] >> 0) & 0xFF))) * 0.000100000000000001f;
            RCell101 = (float)((((uint16_t)((stFrame.abData[3] >> 0) & 0x7F)) << 8) | ((uint16_t)((stFrame.abData[4] >> 0) & 0xFF))) * 0.01f;
            BBalancingCell101 = (uint8_t)(((stFrame.abData[3] >> 0) & 0x1));
            VOpenCell101 = (float)((((uint16_t)((stFrame.abData[5] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[6] >> 0) & 0xFF))) * 0.000100000000000001f;
            break;
        case 101:
            VCell102 = (float)((((uint16_t)((stFrame.abData[1] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[2] >> 0) & 0xFF))) * 0.000100000000000001f;
            RCell102 = (float)((((uint16_t)((stFrame.abData[3] >> 0) & 0x7F)) << 8) | ((uint16_t)((stFrame.abData[4] >> 0) & 0xFF))) * 0.01f;
            BBalancingCell102 = (uint8_t)(((stFrame.abData[3] >> 0) & 0x1));
            VOpenCell102 = (float)((((uint16_t)((stFrame.abData[5] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[6] >> 0) & 0xFF))) * 0.000100000000000001f;
            break;
        case 102:
            VCell103 = (float)((((uint16_t)((stFrame.abData[1] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[2] >> 0) & 0xFF))) * 0.000100000000000001f;
            RCell103 = (float)((((uint16_t)((stFrame.abData[3] >> 0) & 0x7F)) << 8) | ((uint16_t)((stFrame.abData[4] >> 0) & 0xFF))) * 0.01f;
            BBalancingCell103 = (uint8_t)(((stFrame.abData[3] >> 0) & 0x1));
            VOpenCell103 = (float)((((uint16_t)((stFrame.abData[5] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[6] >> 0) & 0xFF))) * 0.000100000000000001f;
            break;
        case 103:
            VCell104 = (float)((((uint16_t)((stFrame.abData[1] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[2] >> 0) & 0xFF))) * 0.000100000000000001f;
            RCell104 = (float)((((uint16_t)((stFrame.abData[3] >> 0) & 0x7F)) << 8) | ((uint16_t)((stFrame.abData[4] >> 0) & 0xFF))) * 0.01f;
            BBalancingCell104 = (uint8_t)(((stFrame.abData[3] >> 0) & 0x1));
            VOpenCell104 = (float)((((uint16_t)((stFrame.abData[5] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[6] >> 0) & 0xFF))) * 0.000100000000000001f;
            break;
        case 104:
            VCell105 = (float)((((uint16_t)((stFrame.abData[1] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[2] >> 0) & 0xFF))) * 0.000100000000000001f;
            RCell105 = (float)((((uint16_t)((stFrame.abData[3] >> 0) & 0x7F)) << 8) | ((uint16_t)((stFrame.abData[4] >> 0) & 0xFF))) * 0.01f;
            BBalancingCell105 = (uint8_t)(((stFrame.abData[3] >> 0) & 0x1));
            VOpenCell105 = (float)((((uint16_t)((stFrame.abData[5] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[6] >> 0) & 0xFF))) * 0.000100000000000001f;
            break;
        case 105:
            VCell106 = (float)((((uint16_t)((stFrame.abData[1] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[2] >> 0) & 0xFF))) * 0.000100000000000001f;
            RCell106 = (float)((((uint16_t)((stFrame.abData[3] >> 0) & 0x7F)) << 8) | ((uint16_t)((stFrame.abData[4] >> 0) & 0xFF))) * 0.01f;
            BBalancingCell106 = (uint8_t)(((stFrame.abData[3] >> 0) & 0x1));
            VOpenCell106 = (float)((((uint16_t)((stFrame.abData[5] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[6] >> 0) & 0xFF))) * 0.000100000000000001f;
            break;
        case 106:
            VCell107 = (float)((((uint16_t)((stFrame.abData[1] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[2] >> 0) & 0xFF))) * 0.000100000000000001f;
            RCell107 = (float)((((uint16_t)((stFrame.abData[3] >> 0) & 0x7F)) << 8) | ((uint16_t)((stFrame.abData[4] >> 0) & 0xFF))) * 0.01f;
            BBalancingCell107 = (uint8_t)(((stFrame.abData[3] >> 0) & 0x1));
            VOpenCell107 = (float)((((uint16_t)((stFrame.abData[5] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[6] >> 0) & 0xFF))) * 0.000100000000000001f;
            break;
        case 107:
            VCell108 = (float)((((uint16_t)((stFrame.abData[1] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[2] >> 0) & 0xFF))) * 0.000100000000000001f;
            RCell108 = (float)((((uint16_t)((stFrame.abData[3] >> 0) & 0x7F)) << 8) | ((uint16_t)((stFrame.abData[4] >> 0) & 0xFF))) * 0.01f;
            BBalancingCell108 = (uint8_t)(((stFrame.abData[3] >> 0) & 0x1));
            VOpenCell108 = (float)((((uint16_t)((stFrame.abData[5] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[6] >> 0) & 0xFF))) * 0.000100000000000001f;
            break;
        case 108:
            VCell109 = (float)((((uint16_t)((stFrame.abData[1] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[2] >> 0) & 0xFF))) * 0.000100000000000001f;
            RCell109 = (float)((((uint16_t)((stFrame.abData[3] >> 0) & 0x7F)) << 8) | ((uint16_t)((stFrame.abData[4] >> 0) & 0xFF))) * 0.01f;
            BBalancingCell109 = (uint8_t)(((stFrame.abData[3] >> 0) & 0x1));
            VOpenCell109 = (float)((((uint16_t)((stFrame.abData[5] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[6] >> 0) & 0xFF))) * 0.000100000000000001f;
            break;
        case 109:
            VCell110 = (float)((((uint16_t)((stFrame.abData[1] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[2] >> 0) & 0xFF))) * 0.000100000000000001f;
            RCell110 = (float)((((uint16_t)((stFrame.abData[3] >> 0) & 0x7F)) << 8) | ((uint16_t)((stFrame.abData[4] >> 0) & 0xFF))) * 0.01f;
            BBalancingCell110 = (uint8_t)(((stFrame.abData[3] >> 0) & 0x1));
            VOpenCell110 = (float)((((uint16_t)((stFrame.abData[5] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[6] >> 0) & 0xFF))) * 0.000100000000000001f;
            break;
        case 110:
            VCell111 = (float)((((uint16_t)((stFrame.abData[1] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[2] >> 0) & 0xFF))) * 0.000100000000000001f;
            RCell111 = (float)((((uint16_t)((stFrame.abData[3] >> 0) & 0x7F)) << 8) | ((uint16_t)((stFrame.abData[4] >> 0) & 0xFF))) * 0.01f;
            BBalancingCell111 = (uint8_t)(((stFrame.abData[3] >> 0) & 0x1));
            VOpenCell111 = (float)((((uint16_t)((stFrame.abData[5] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[6] >> 0) & 0xFF))) * 0.000100000000000001f;
            break;
        case 111:
            VCell112 = (float)((((uint16_t)((stFrame.abData[1] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[2] >> 0) & 0xFF))) * 0.000100000000000001f;
            RCell112 = (float)((((uint16_t)((stFrame.abData[3] >> 0) & 0x7F)) << 8) | ((uint16_t)((stFrame.abData[4] >> 0) & 0xFF))) * 0.01f;
            BBalancingCell112 = (uint8_t)(((stFrame.abData[3] >> 0) & 0x1));
            VOpenCell112 = (float)((((uint16_t)((stFrame.abData[5] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[6] >> 0) & 0xFF))) * 0.000100000000000001f;
            break;
        default:
            break;
    }
    return ESP_OK;
}

esp_err_t CellVoltagesTx(twai_node_handle_t stCANBus)
{
    /*
    *===========================================================================
    *   CellVoltagesTx
    *   Encodes and Transmits Message: CellVoltages (0x36)
    *   Uses global signal variables.
    *   Takes:   stCANBus: Handle to CAN bus to transmit on
    *   Returns: ESP_OK if successful, error code if not.
    */
    CAN_frame_t stFrame;
    stFrame.dwID = 0x36;
    stFrame.byDLC = 8;
    memset(stFrame.abData, 0, 8);

    stFrame.abData[7] |= (uint8_t)(((((uint32_t)CheckSum_CellVoltages & 0xFF) >> 0) & 0xFF) << 0);

    /* Mux Switch */
    stFrame.abData[0] |= (uint8_t)(((((uint32_t)CellID & 0xFF) >> 0) & 0xFF) << 0);

    /* Muxed Signals */
    switch((int)CellID)
    {
        case 0:
            stFrame.abData[1] |= (uint8_t)(((((uint32_t)(VCell001 / 0.0001f) & 0xFFFF) >> 8) & 0xFF) << 0);
            stFrame.abData[2] |= (uint8_t)(((((uint32_t)(VCell001 / 0.0001f) & 0xFFFF) >> 0) & 0xFF) << 0);
            stFrame.abData[3] |= (uint8_t)(((((uint32_t)(RCell001 / 0.01f) & 0x7FFF) >> 8) & 0x7F) << 0);
            stFrame.abData[4] |= (uint8_t)(((((uint32_t)(RCell001 / 0.01f) & 0x7FFF) >> 0) & 0xFF) << 0);
            stFrame.abData[3] |= (uint8_t)(((((uint32_t)BBalancingCell001 & 0x1) >> 0) & 0x1) << 0);
            stFrame.abData[5] |= (uint8_t)(((((uint32_t)(VOpenCell001 / 0.000100000000000001f) & 0xFFFF) >> 8) & 0xFF) << 0);
            stFrame.abData[6] |= (uint8_t)(((((uint32_t)(VOpenCell001 / 0.000100000000000001f) & 0xFFFF) >> 0) & 0xFF) << 0);
            break;
        case 1:
            stFrame.abData[1] |= (uint8_t)(((((uint32_t)(VCell002 / 0.0001f) & 0xFFFF) >> 8) & 0xFF) << 0);
            stFrame.abData[2] |= (uint8_t)(((((uint32_t)(VCell002 / 0.0001f) & 0xFFFF) >> 0) & 0xFF) << 0);
            stFrame.abData[3] |= (uint8_t)(((((uint32_t)(RCell002 / 0.01f) & 0x7FFF) >> 8) & 0x7F) << 0);
            stFrame.abData[4] |= (uint8_t)(((((uint32_t)(RCell002 / 0.01f) & 0x7FFF) >> 0) & 0xFF) << 0);
            stFrame.abData[3] |= (uint8_t)(((((uint32_t)BBalancingCell002 & 0x1) >> 0) & 0x1) << 0);
            stFrame.abData[5] |= (uint8_t)(((((uint32_t)(VOpenCell002 / 0.000100000000000001f) & 0xFFFF) >> 8) & 0xFF) << 0);
            stFrame.abData[6] |= (uint8_t)(((((uint32_t)(VOpenCell002 / 0.000100000000000001f) & 0xFFFF) >> 0) & 0xFF) << 0);
            break;
        case 2:
            stFrame.abData[1] |= (uint8_t)(((((uint32_t)(VCell003 / 0.0001f) & 0xFFFF) >> 8) & 0xFF) << 0);
            stFrame.abData[2] |= (uint8_t)(((((uint32_t)(VCell003 / 0.0001f) & 0xFFFF) >> 0) & 0xFF) << 0);
            stFrame.abData[3] |= (uint8_t)(((((uint32_t)(RCell003 / 0.01f) & 0x7FFF) >> 8) & 0x7F) << 0);
            stFrame.abData[4] |= (uint8_t)(((((uint32_t)(RCell003 / 0.01f) & 0x7FFF) >> 0) & 0xFF) << 0);
            stFrame.abData[3] |= (uint8_t)(((((uint32_t)BBalancingCell003 & 0x1) >> 0) & 0x1) << 0);
            stFrame.abData[5] |= (uint8_t)(((((uint32_t)(VOpenCell003 / 0.000100000000000001f) & 0xFFFF) >> 8) & 0xFF) << 0);
            stFrame.abData[6] |= (uint8_t)(((((uint32_t)(VOpenCell003 / 0.000100000000000001f) & 0xFFFF) >> 0) & 0xFF) << 0);
            break;
        case 3:
            stFrame.abData[1] |= (uint8_t)(((((uint32_t)(VCell004 / 0.0001f) & 0xFFFF) >> 8) & 0xFF) << 0);
            stFrame.abData[2] |= (uint8_t)(((((uint32_t)(VCell004 / 0.0001f) & 0xFFFF) >> 0) & 0xFF) << 0);
            stFrame.abData[3] |= (uint8_t)(((((uint32_t)(RCell004 / 0.01f) & 0x7FFF) >> 8) & 0x7F) << 0);
            stFrame.abData[4] |= (uint8_t)(((((uint32_t)(RCell004 / 0.01f) & 0x7FFF) >> 0) & 0xFF) << 0);
            stFrame.abData[3] |= (uint8_t)(((((uint32_t)BBalancingCell004 & 0x1) >> 0) & 0x1) << 0);
            stFrame.abData[5] |= (uint8_t)(((((uint32_t)(VOpenCell004 / 0.000100000000000001f) & 0xFFFF) >> 8) & 0xFF) << 0);
            stFrame.abData[6] |= (uint8_t)(((((uint32_t)(VOpenCell004 / 0.000100000000000001f) & 0xFFFF) >> 0) & 0xFF) << 0);
            break;
        case 4:
            stFrame.abData[1] |= (uint8_t)(((((uint32_t)(VCell005 / 0.0001f) & 0xFFFF) >> 8) & 0xFF) << 0);
            stFrame.abData[2] |= (uint8_t)(((((uint32_t)(VCell005 / 0.0001f) & 0xFFFF) >> 0) & 0xFF) << 0);
            stFrame.abData[3] |= (uint8_t)(((((uint32_t)(RCell005 / 0.01f) & 0x7FFF) >> 8) & 0x7F) << 0);
            stFrame.abData[4] |= (uint8_t)(((((uint32_t)(RCell005 / 0.01f) & 0x7FFF) >> 0) & 0xFF) << 0);
            stFrame.abData[3] |= (uint8_t)(((((uint32_t)BBalancingCell005 & 0x1) >> 0) & 0x1) << 0);
            stFrame.abData[5] |= (uint8_t)(((((uint32_t)(VOpenCell005 / 0.000100000000000001f) & 0xFFFF) >> 8) & 0xFF) << 0);
            stFrame.abData[6] |= (uint8_t)(((((uint32_t)(VOpenCell005 / 0.000100000000000001f) & 0xFFFF) >> 0) & 0xFF) << 0);
            break;
        case 5:
            stFrame.abData[1] |= (uint8_t)(((((uint32_t)(VCell006 / 0.0001f) & 0xFFFF) >> 8) & 0xFF) << 0);
            stFrame.abData[2] |= (uint8_t)(((((uint32_t)(VCell006 / 0.0001f) & 0xFFFF) >> 0) & 0xFF) << 0);
            stFrame.abData[3] |= (uint8_t)(((((uint32_t)(RCell006 / 0.01f) & 0x7FFF) >> 8) & 0x7F) << 0);
            stFrame.abData[4] |= (uint8_t)(((((uint32_t)(RCell006 / 0.01f) & 0x7FFF) >> 0) & 0xFF) << 0);
            stFrame.abData[3] |= (uint8_t)(((((uint32_t)BBalancingCell006 & 0x1) >> 0) & 0x1) << 0);
            stFrame.abData[5] |= (uint8_t)(((((uint32_t)(VOpenCell006 / 0.000100000000000001f) & 0xFFFF) >> 8) & 0xFF) << 0);
            stFrame.abData[6] |= (uint8_t)(((((uint32_t)(VOpenCell006 / 0.000100000000000001f) & 0xFFFF) >> 0) & 0xFF) << 0);
            break;
        case 6:
            stFrame.abData[1] |= (uint8_t)(((((uint32_t)(VCell007 / 0.0001f) & 0xFFFF) >> 8) & 0xFF) << 0);
            stFrame.abData[2] |= (uint8_t)(((((uint32_t)(VCell007 / 0.0001f) & 0xFFFF) >> 0) & 0xFF) << 0);
            stFrame.abData[3] |= (uint8_t)(((((uint32_t)(RCell007 / 0.01f) & 0x7FFF) >> 8) & 0x7F) << 0);
            stFrame.abData[4] |= (uint8_t)(((((uint32_t)(RCell007 / 0.01f) & 0x7FFF) >> 0) & 0xFF) << 0);
            stFrame.abData[3] |= (uint8_t)(((((uint32_t)BBalancingCell007 & 0x1) >> 0) & 0x1) << 0);
            stFrame.abData[5] |= (uint8_t)(((((uint32_t)(VOpenCell007 / 0.000100000000000001f) & 0xFFFF) >> 8) & 0xFF) << 0);
            stFrame.abData[6] |= (uint8_t)(((((uint32_t)(VOpenCell007 / 0.000100000000000001f) & 0xFFFF) >> 0) & 0xFF) << 0);
            break;
        case 7:
            stFrame.abData[1] |= (uint8_t)(((((uint32_t)(VCell008 / 0.0001f) & 0xFFFF) >> 8) & 0xFF) << 0);
            stFrame.abData[2] |= (uint8_t)(((((uint32_t)(VCell008 / 0.0001f) & 0xFFFF) >> 0) & 0xFF) << 0);
            stFrame.abData[3] |= (uint8_t)(((((uint32_t)(RCell008 / 0.01f) & 0x7FFF) >> 8) & 0x7F) << 0);
            stFrame.abData[4] |= (uint8_t)(((((uint32_t)(RCell008 / 0.01f) & 0x7FFF) >> 0) & 0xFF) << 0);
            stFrame.abData[3] |= (uint8_t)(((((uint32_t)BBalancingCell008 & 0x1) >> 0) & 0x1) << 0);
            stFrame.abData[5] |= (uint8_t)(((((uint32_t)(VOpenCell008 / 0.000100000000000001f) & 0xFFFF) >> 8) & 0xFF) << 0);
            stFrame.abData[6] |= (uint8_t)(((((uint32_t)(VOpenCell008 / 0.000100000000000001f) & 0xFFFF) >> 0) & 0xFF) << 0);
            break;
        case 8:
            stFrame.abData[1] |= (uint8_t)(((((uint32_t)(VCell009 / 0.0001f) & 0xFFFF) >> 8) & 0xFF) << 0);
            stFrame.abData[2] |= (uint8_t)(((((uint32_t)(VCell009 / 0.0001f) & 0xFFFF) >> 0) & 0xFF) << 0);
            stFrame.abData[3] |= (uint8_t)(((((uint32_t)(RCell009 / 0.01f) & 0x7FFF) >> 8) & 0x7F) << 0);
            stFrame.abData[4] |= (uint8_t)(((((uint32_t)(RCell009 / 0.01f) & 0x7FFF) >> 0) & 0xFF) << 0);
            stFrame.abData[3] |= (uint8_t)(((((uint32_t)BBalancingCell009 & 0x1) >> 0) & 0x1) << 0);
            stFrame.abData[5] |= (uint8_t)(((((uint32_t)(VOpenCell009 / 0.000100000000000001f) & 0xFFFF) >> 8) & 0xFF) << 0);
            stFrame.abData[6] |= (uint8_t)(((((uint32_t)(VOpenCell009 / 0.000100000000000001f) & 0xFFFF) >> 0) & 0xFF) << 0);
            break;
        case 9:
            stFrame.abData[1] |= (uint8_t)(((((uint32_t)(VCell010 / 0.0001f) & 0xFFFF) >> 8) & 0xFF) << 0);
            stFrame.abData[2] |= (uint8_t)(((((uint32_t)(VCell010 / 0.0001f) & 0xFFFF) >> 0) & 0xFF) << 0);
            stFrame.abData[3] |= (uint8_t)(((((uint32_t)(RCell010 / 0.01f) & 0x7FFF) >> 8) & 0x7F) << 0);
            stFrame.abData[4] |= (uint8_t)(((((uint32_t)(RCell010 / 0.01f) & 0x7FFF) >> 0) & 0xFF) << 0);
            stFrame.abData[3] |= (uint8_t)(((((uint32_t)BBalancingCell010 & 0x1) >> 0) & 0x1) << 0);
            stFrame.abData[5] |= (uint8_t)(((((uint32_t)(VOpenCell010 / 0.000100000000000001f) & 0xFFFF) >> 8) & 0xFF) << 0);
            stFrame.abData[6] |= (uint8_t)(((((uint32_t)(VOpenCell010 / 0.000100000000000001f) & 0xFFFF) >> 0) & 0xFF) << 0);
            break;
        case 10:
            stFrame.abData[1] |= (uint8_t)(((((uint32_t)(VCell011 / 0.0001f) & 0xFFFF) >> 8) & 0xFF) << 0);
            stFrame.abData[2] |= (uint8_t)(((((uint32_t)(VCell011 / 0.0001f) & 0xFFFF) >> 0) & 0xFF) << 0);
            stFrame.abData[3] |= (uint8_t)(((((uint32_t)(RCell011 / 0.01f) & 0x7FFF) >> 8) & 0x7F) << 0);
            stFrame.abData[4] |= (uint8_t)(((((uint32_t)(RCell011 / 0.01f) & 0x7FFF) >> 0) & 0xFF) << 0);
            stFrame.abData[3] |= (uint8_t)(((((uint32_t)BBalancingCell011 & 0x1) >> 0) & 0x1) << 0);
            stFrame.abData[5] |= (uint8_t)(((((uint32_t)(VOpenCell011 / 0.000100000000000001f) & 0xFFFF) >> 8) & 0xFF) << 0);
            stFrame.abData[6] |= (uint8_t)(((((uint32_t)(VOpenCell011 / 0.000100000000000001f) & 0xFFFF) >> 0) & 0xFF) << 0);
            break;
        case 11:
            stFrame.abData[1] |= (uint8_t)(((((uint32_t)(VCell012 / 0.0001f) & 0xFFFF) >> 8) & 0xFF) << 0);
            stFrame.abData[2] |= (uint8_t)(((((uint32_t)(VCell012 / 0.0001f) & 0xFFFF) >> 0) & 0xFF) << 0);
            stFrame.abData[3] |= (uint8_t)(((((uint32_t)(RCell012 / 0.01f) & 0x7FFF) >> 8) & 0x7F) << 0);
            stFrame.abData[4] |= (uint8_t)(((((uint32_t)(RCell012 / 0.01f) & 0x7FFF) >> 0) & 0xFF) << 0);
            stFrame.abData[3] |= (uint8_t)(((((uint32_t)BBalancingCell012 & 0x1) >> 0) & 0x1) << 0);
            stFrame.abData[5] |= (uint8_t)(((((uint32_t)(VOpenCell012 / 0.000100000000000001f) & 0xFFFF) >> 8) & 0xFF) << 0);
            stFrame.abData[6] |= (uint8_t)(((((uint32_t)(VOpenCell012 / 0.000100000000000001f) & 0xFFFF) >> 0) & 0xFF) << 0);
            break;
        case 12:
            stFrame.abData[1] |= (uint8_t)(((((uint32_t)(VCell013 / 0.0001f) & 0xFFFF) >> 8) & 0xFF) << 0);
            stFrame.abData[2] |= (uint8_t)(((((uint32_t)(VCell013 / 0.0001f) & 0xFFFF) >> 0) & 0xFF) << 0);
            stFrame.abData[3] |= (uint8_t)(((((uint32_t)(RCell013 / 0.01f) & 0x7FFF) >> 8) & 0x7F) << 0);
            stFrame.abData[4] |= (uint8_t)(((((uint32_t)(RCell013 / 0.01f) & 0x7FFF) >> 0) & 0xFF) << 0);
            stFrame.abData[3] |= (uint8_t)(((((uint32_t)BBalancingCell013 & 0x1) >> 0) & 0x1) << 0);
            stFrame.abData[5] |= (uint8_t)(((((uint32_t)(VOpenCell013 / 0.000100000000000001f) & 0xFFFF) >> 8) & 0xFF) << 0);
            stFrame.abData[6] |= (uint8_t)(((((uint32_t)(VOpenCell013 / 0.000100000000000001f) & 0xFFFF) >> 0) & 0xFF) << 0);
            break;
        case 13:
            stFrame.abData[1] |= (uint8_t)(((((uint32_t)(VCell014 / 0.0001f) & 0xFFFF) >> 8) & 0xFF) << 0);
            stFrame.abData[2] |= (uint8_t)(((((uint32_t)(VCell014 / 0.0001f) & 0xFFFF) >> 0) & 0xFF) << 0);
            stFrame.abData[3] |= (uint8_t)(((((uint32_t)(RCell014 / 0.01f) & 0x7FFF) >> 8) & 0x7F) << 0);
            stFrame.abData[4] |= (uint8_t)(((((uint32_t)(RCell014 / 0.01f) & 0x7FFF) >> 0) & 0xFF) << 0);
            stFrame.abData[3] |= (uint8_t)(((((uint32_t)BBalancingCell014 & 0x1) >> 0) & 0x1) << 0);
            stFrame.abData[5] |= (uint8_t)(((((uint32_t)(VOpenCell014 / 0.000100000000000001f) & 0xFFFF) >> 8) & 0xFF) << 0);
            stFrame.abData[6] |= (uint8_t)(((((uint32_t)(VOpenCell014 / 0.000100000000000001f) & 0xFFFF) >> 0) & 0xFF) << 0);
            break;
        case 14:
            stFrame.abData[1] |= (uint8_t)(((((uint32_t)(VCell015 / 0.0001f) & 0xFFFF) >> 8) & 0xFF) << 0);
            stFrame.abData[2] |= (uint8_t)(((((uint32_t)(VCell015 / 0.0001f) & 0xFFFF) >> 0) & 0xFF) << 0);
            stFrame.abData[3] |= (uint8_t)(((((uint32_t)(RCell015 / 0.01f) & 0x7FFF) >> 8) & 0x7F) << 0);
            stFrame.abData[4] |= (uint8_t)(((((uint32_t)(RCell015 / 0.01f) & 0x7FFF) >> 0) & 0xFF) << 0);
            stFrame.abData[3] |= (uint8_t)(((((uint32_t)BBalancingCell015 & 0x1) >> 0) & 0x1) << 0);
            stFrame.abData[5] |= (uint8_t)(((((uint32_t)(VOpenCell015 / 0.000100000000000001f) & 0xFFFF) >> 8) & 0xFF) << 0);
            stFrame.abData[6] |= (uint8_t)(((((uint32_t)(VOpenCell015 / 0.000100000000000001f) & 0xFFFF) >> 0) & 0xFF) << 0);
            break;
        case 15:
            stFrame.abData[1] |= (uint8_t)(((((uint32_t)(VCell016 / 0.0001f) & 0xFFFF) >> 8) & 0xFF) << 0);
            stFrame.abData[2] |= (uint8_t)(((((uint32_t)(VCell016 / 0.0001f) & 0xFFFF) >> 0) & 0xFF) << 0);
            stFrame.abData[3] |= (uint8_t)(((((uint32_t)(RCell016 / 0.01f) & 0x7FFF) >> 8) & 0x7F) << 0);
            stFrame.abData[4] |= (uint8_t)(((((uint32_t)(RCell016 / 0.01f) & 0x7FFF) >> 0) & 0xFF) << 0);
            stFrame.abData[3] |= (uint8_t)(((((uint32_t)BBalancingCell016 & 0x1) >> 0) & 0x1) << 0);
            stFrame.abData[5] |= (uint8_t)(((((uint32_t)(VOpenCell016 / 0.000100000000000001f) & 0xFFFF) >> 8) & 0xFF) << 0);
            stFrame.abData[6] |= (uint8_t)(((((uint32_t)(VOpenCell016 / 0.000100000000000001f) & 0xFFFF) >> 0) & 0xFF) << 0);
            break;
        case 16:
            stFrame.abData[1] |= (uint8_t)(((((uint32_t)(VCell017 / 0.0001f) & 0xFFFF) >> 8) & 0xFF) << 0);
            stFrame.abData[2] |= (uint8_t)(((((uint32_t)(VCell017 / 0.0001f) & 0xFFFF) >> 0) & 0xFF) << 0);
            stFrame.abData[3] |= (uint8_t)(((((uint32_t)(RCell017 / 0.01f) & 0x7FFF) >> 8) & 0x7F) << 0);
            stFrame.abData[4] |= (uint8_t)(((((uint32_t)(RCell017 / 0.01f) & 0x7FFF) >> 0) & 0xFF) << 0);
            stFrame.abData[3] |= (uint8_t)(((((uint32_t)BBalancingCell017 & 0x1) >> 0) & 0x1) << 0);
            stFrame.abData[5] |= (uint8_t)(((((uint32_t)(VOpenCell017 / 0.000100000000000001f) & 0xFFFF) >> 8) & 0xFF) << 0);
            stFrame.abData[6] |= (uint8_t)(((((uint32_t)(VOpenCell017 / 0.000100000000000001f) & 0xFFFF) >> 0) & 0xFF) << 0);
            break;
        case 17:
            stFrame.abData[1] |= (uint8_t)(((((uint32_t)(VCell018 / 0.0001f) & 0xFFFF) >> 8) & 0xFF) << 0);
            stFrame.abData[2] |= (uint8_t)(((((uint32_t)(VCell018 / 0.0001f) & 0xFFFF) >> 0) & 0xFF) << 0);
            stFrame.abData[3] |= (uint8_t)(((((uint32_t)(RCell018 / 0.01f) & 0x7FFF) >> 8) & 0x7F) << 0);
            stFrame.abData[4] |= (uint8_t)(((((uint32_t)(RCell018 / 0.01f) & 0x7FFF) >> 0) & 0xFF) << 0);
            stFrame.abData[3] |= (uint8_t)(((((uint32_t)BBalancingCell018 & 0x1) >> 0) & 0x1) << 0);
            stFrame.abData[5] |= (uint8_t)(((((uint32_t)(VOpenCell018 / 0.000100000000000001f) & 0xFFFF) >> 8) & 0xFF) << 0);
            stFrame.abData[6] |= (uint8_t)(((((uint32_t)(VOpenCell018 / 0.000100000000000001f) & 0xFFFF) >> 0) & 0xFF) << 0);
            break;
        case 18:
            stFrame.abData[1] |= (uint8_t)(((((uint32_t)(VCell019 / 0.0001f) & 0xFFFF) >> 8) & 0xFF) << 0);
            stFrame.abData[2] |= (uint8_t)(((((uint32_t)(VCell019 / 0.0001f) & 0xFFFF) >> 0) & 0xFF) << 0);
            stFrame.abData[3] |= (uint8_t)(((((uint32_t)(RCell019 / 0.01f) & 0x7FFF) >> 8) & 0x7F) << 0);
            stFrame.abData[4] |= (uint8_t)(((((uint32_t)(RCell019 / 0.01f) & 0x7FFF) >> 0) & 0xFF) << 0);
            stFrame.abData[3] |= (uint8_t)(((((uint32_t)BBalancingCell019 & 0x1) >> 0) & 0x1) << 0);
            stFrame.abData[5] |= (uint8_t)(((((uint32_t)(VOpenCell019 / 0.000100000000000001f) & 0xFFFF) >> 8) & 0xFF) << 0);
            stFrame.abData[6] |= (uint8_t)(((((uint32_t)(VOpenCell019 / 0.000100000000000001f) & 0xFFFF) >> 0) & 0xFF) << 0);
            break;
        case 19:
            stFrame.abData[1] |= (uint8_t)(((((uint32_t)(VCell020 / 0.0001f) & 0xFFFF) >> 8) & 0xFF) << 0);
            stFrame.abData[2] |= (uint8_t)(((((uint32_t)(VCell020 / 0.0001f) & 0xFFFF) >> 0) & 0xFF) << 0);
            stFrame.abData[3] |= (uint8_t)(((((uint32_t)(RCell020 / 0.01f) & 0x7FFF) >> 8) & 0x7F) << 0);
            stFrame.abData[4] |= (uint8_t)(((((uint32_t)(RCell020 / 0.01f) & 0x7FFF) >> 0) & 0xFF) << 0);
            stFrame.abData[3] |= (uint8_t)(((((uint32_t)BBalancingCell020 & 0x1) >> 0) & 0x1) << 0);
            stFrame.abData[5] |= (uint8_t)(((((uint32_t)(VOpenCell020 / 0.000100000000000001f) & 0xFFFF) >> 8) & 0xFF) << 0);
            stFrame.abData[6] |= (uint8_t)(((((uint32_t)(VOpenCell020 / 0.000100000000000001f) & 0xFFFF) >> 0) & 0xFF) << 0);
            break;
        case 20:
            stFrame.abData[1] |= (uint8_t)(((((uint32_t)(VCell021 / 0.0001f) & 0xFFFF) >> 8) & 0xFF) << 0);
            stFrame.abData[2] |= (uint8_t)(((((uint32_t)(VCell021 / 0.0001f) & 0xFFFF) >> 0) & 0xFF) << 0);
            stFrame.abData[3] |= (uint8_t)(((((uint32_t)(RCell021 / 0.01f) & 0x7FFF) >> 8) & 0x7F) << 0);
            stFrame.abData[4] |= (uint8_t)(((((uint32_t)(RCell021 / 0.01f) & 0x7FFF) >> 0) & 0xFF) << 0);
            stFrame.abData[3] |= (uint8_t)(((((uint32_t)BBalancingCell021 & 0x1) >> 0) & 0x1) << 0);
            stFrame.abData[5] |= (uint8_t)(((((uint32_t)(VOpenCell021 / 0.000100000000000001f) & 0xFFFF) >> 8) & 0xFF) << 0);
            stFrame.abData[6] |= (uint8_t)(((((uint32_t)(VOpenCell021 / 0.000100000000000001f) & 0xFFFF) >> 0) & 0xFF) << 0);
            break;
        case 21:
            stFrame.abData[1] |= (uint8_t)(((((uint32_t)(VCell022 / 0.0001f) & 0xFFFF) >> 8) & 0xFF) << 0);
            stFrame.abData[2] |= (uint8_t)(((((uint32_t)(VCell022 / 0.0001f) & 0xFFFF) >> 0) & 0xFF) << 0);
            stFrame.abData[3] |= (uint8_t)(((((uint32_t)(RCell022 / 0.01f) & 0x7FFF) >> 8) & 0x7F) << 0);
            stFrame.abData[4] |= (uint8_t)(((((uint32_t)(RCell022 / 0.01f) & 0x7FFF) >> 0) & 0xFF) << 0);
            stFrame.abData[3] |= (uint8_t)(((((uint32_t)BBalancingCell022 & 0x1) >> 0) & 0x1) << 0);
            stFrame.abData[5] |= (uint8_t)(((((uint32_t)(VOpenCell022 / 0.000100000000000001f) & 0xFFFF) >> 8) & 0xFF) << 0);
            stFrame.abData[6] |= (uint8_t)(((((uint32_t)(VOpenCell022 / 0.000100000000000001f) & 0xFFFF) >> 0) & 0xFF) << 0);
            break;
        case 22:
            stFrame.abData[1] |= (uint8_t)(((((uint32_t)(VCell023 / 0.0001f) & 0xFFFF) >> 8) & 0xFF) << 0);
            stFrame.abData[2] |= (uint8_t)(((((uint32_t)(VCell023 / 0.0001f) & 0xFFFF) >> 0) & 0xFF) << 0);
            stFrame.abData[3] |= (uint8_t)(((((uint32_t)(RCell023 / 0.01f) & 0x7FFF) >> 8) & 0x7F) << 0);
            stFrame.abData[4] |= (uint8_t)(((((uint32_t)(RCell023 / 0.01f) & 0x7FFF) >> 0) & 0xFF) << 0);
            stFrame.abData[3] |= (uint8_t)(((((uint32_t)BBalancingCell023 & 0x1) >> 0) & 0x1) << 0);
            stFrame.abData[5] |= (uint8_t)(((((uint32_t)(VOpenCell023 / 0.000100000000000001f) & 0xFFFF) >> 8) & 0xFF) << 0);
            stFrame.abData[6] |= (uint8_t)(((((uint32_t)(VOpenCell023 / 0.000100000000000001f) & 0xFFFF) >> 0) & 0xFF) << 0);
            break;
        case 23:
            stFrame.abData[1] |= (uint8_t)(((((uint32_t)(VCell024 / 0.0001f) & 0xFFFF) >> 8) & 0xFF) << 0);
            stFrame.abData[2] |= (uint8_t)(((((uint32_t)(VCell024 / 0.0001f) & 0xFFFF) >> 0) & 0xFF) << 0);
            stFrame.abData[3] |= (uint8_t)(((((uint32_t)(RCell024 / 0.01f) & 0x7FFF) >> 8) & 0x7F) << 0);
            stFrame.abData[4] |= (uint8_t)(((((uint32_t)(RCell024 / 0.01f) & 0x7FFF) >> 0) & 0xFF) << 0);
            stFrame.abData[3] |= (uint8_t)(((((uint32_t)BBalancingCell024 & 0x1) >> 0) & 0x1) << 0);
            stFrame.abData[5] |= (uint8_t)(((((uint32_t)(VOpenCell024 / 0.000100000000000001f) & 0xFFFF) >> 8) & 0xFF) << 0);
            stFrame.abData[6] |= (uint8_t)(((((uint32_t)(VOpenCell024 / 0.000100000000000001f) & 0xFFFF) >> 0) & 0xFF) << 0);
            break;
        case 24:
            stFrame.abData[1] |= (uint8_t)(((((uint32_t)(VCell025 / 0.0001f) & 0xFFFF) >> 8) & 0xFF) << 0);
            stFrame.abData[2] |= (uint8_t)(((((uint32_t)(VCell025 / 0.0001f) & 0xFFFF) >> 0) & 0xFF) << 0);
            stFrame.abData[3] |= (uint8_t)(((((uint32_t)(RCell025 / 0.01f) & 0x7FFF) >> 8) & 0x7F) << 0);
            stFrame.abData[4] |= (uint8_t)(((((uint32_t)(RCell025 / 0.01f) & 0x7FFF) >> 0) & 0xFF) << 0);
            stFrame.abData[3] |= (uint8_t)(((((uint32_t)BBalancingCell025 & 0x1) >> 0) & 0x1) << 0);
            stFrame.abData[5] |= (uint8_t)(((((uint32_t)(VOpenCell025 / 0.000100000000000001f) & 0xFFFF) >> 8) & 0xFF) << 0);
            stFrame.abData[6] |= (uint8_t)(((((uint32_t)(VOpenCell025 / 0.000100000000000001f) & 0xFFFF) >> 0) & 0xFF) << 0);
            break;
        case 25:
            stFrame.abData[1] |= (uint8_t)(((((uint32_t)(VCell026 / 0.0001f) & 0xFFFF) >> 8) & 0xFF) << 0);
            stFrame.abData[2] |= (uint8_t)(((((uint32_t)(VCell026 / 0.0001f) & 0xFFFF) >> 0) & 0xFF) << 0);
            stFrame.abData[3] |= (uint8_t)(((((uint32_t)(RCell026 / 0.01f) & 0x7FFF) >> 8) & 0x7F) << 0);
            stFrame.abData[4] |= (uint8_t)(((((uint32_t)(RCell026 / 0.01f) & 0x7FFF) >> 0) & 0xFF) << 0);
            stFrame.abData[3] |= (uint8_t)(((((uint32_t)BBalancingCell026 & 0x1) >> 0) & 0x1) << 0);
            stFrame.abData[5] |= (uint8_t)(((((uint32_t)(VOpenCell026 / 0.000100000000000001f) & 0xFFFF) >> 8) & 0xFF) << 0);
            stFrame.abData[6] |= (uint8_t)(((((uint32_t)(VOpenCell026 / 0.000100000000000001f) & 0xFFFF) >> 0) & 0xFF) << 0);
            break;
        case 26:
            stFrame.abData[1] |= (uint8_t)(((((uint32_t)(VCell027 / 0.0001f) & 0xFFFF) >> 8) & 0xFF) << 0);
            stFrame.abData[2] |= (uint8_t)(((((uint32_t)(VCell027 / 0.0001f) & 0xFFFF) >> 0) & 0xFF) << 0);
            stFrame.abData[3] |= (uint8_t)(((((uint32_t)(RCell027 / 0.01f) & 0x7FFF) >> 8) & 0x7F) << 0);
            stFrame.abData[4] |= (uint8_t)(((((uint32_t)(RCell027 / 0.01f) & 0x7FFF) >> 0) & 0xFF) << 0);
            stFrame.abData[3] |= (uint8_t)(((((uint32_t)BBalancingCell027 & 0x1) >> 0) & 0x1) << 0);
            stFrame.abData[5] |= (uint8_t)(((((uint32_t)(VOpenCell027 / 0.000100000000000001f) & 0xFFFF) >> 8) & 0xFF) << 0);
            stFrame.abData[6] |= (uint8_t)(((((uint32_t)(VOpenCell027 / 0.000100000000000001f) & 0xFFFF) >> 0) & 0xFF) << 0);
            break;
        case 27:
            stFrame.abData[1] |= (uint8_t)(((((uint32_t)(VCell028 / 0.0001f) & 0xFFFF) >> 8) & 0xFF) << 0);
            stFrame.abData[2] |= (uint8_t)(((((uint32_t)(VCell028 / 0.0001f) & 0xFFFF) >> 0) & 0xFF) << 0);
            stFrame.abData[3] |= (uint8_t)(((((uint32_t)(RCell028 / 0.01f) & 0x7FFF) >> 8) & 0x7F) << 0);
            stFrame.abData[4] |= (uint8_t)(((((uint32_t)(RCell028 / 0.01f) & 0x7FFF) >> 0) & 0xFF) << 0);
            stFrame.abData[3] |= (uint8_t)(((((uint32_t)BBalancingCell028 & 0x1) >> 0) & 0x1) << 0);
            stFrame.abData[5] |= (uint8_t)(((((uint32_t)(VOpenCell028 / 0.000100000000000001f) & 0xFFFF) >> 8) & 0xFF) << 0);
            stFrame.abData[6] |= (uint8_t)(((((uint32_t)(VOpenCell028 / 0.000100000000000001f) & 0xFFFF) >> 0) & 0xFF) << 0);
            break;
        case 28:
            stFrame.abData[1] |= (uint8_t)(((((uint32_t)(VCell029 / 0.0001f) & 0xFFFF) >> 8) & 0xFF) << 0);
            stFrame.abData[2] |= (uint8_t)(((((uint32_t)(VCell029 / 0.0001f) & 0xFFFF) >> 0) & 0xFF) << 0);
            stFrame.abData[3] |= (uint8_t)(((((uint32_t)(RCell029 / 0.01f) & 0x7FFF) >> 8) & 0x7F) << 0);
            stFrame.abData[4] |= (uint8_t)(((((uint32_t)(RCell029 / 0.01f) & 0x7FFF) >> 0) & 0xFF) << 0);
            stFrame.abData[3] |= (uint8_t)(((((uint32_t)BBalancingCell029 & 0x1) >> 0) & 0x1) << 0);
            stFrame.abData[5] |= (uint8_t)(((((uint32_t)(VOpenCell029 / 0.000100000000000001f) & 0xFFFF) >> 8) & 0xFF) << 0);
            stFrame.abData[6] |= (uint8_t)(((((uint32_t)(VOpenCell029 / 0.000100000000000001f) & 0xFFFF) >> 0) & 0xFF) << 0);
            break;
        case 29:
            stFrame.abData[1] |= (uint8_t)(((((uint32_t)(VCell030 / 0.0001f) & 0xFFFF) >> 8) & 0xFF) << 0);
            stFrame.abData[2] |= (uint8_t)(((((uint32_t)(VCell030 / 0.0001f) & 0xFFFF) >> 0) & 0xFF) << 0);
            stFrame.abData[3] |= (uint8_t)(((((uint32_t)(RCell030 / 0.01f) & 0x7FFF) >> 8) & 0x7F) << 0);
            stFrame.abData[4] |= (uint8_t)(((((uint32_t)(RCell030 / 0.01f) & 0x7FFF) >> 0) & 0xFF) << 0);
            stFrame.abData[3] |= (uint8_t)(((((uint32_t)BBalancingCell030 & 0x1) >> 0) & 0x1) << 0);
            stFrame.abData[5] |= (uint8_t)(((((uint32_t)(VOpenCell030 / 0.000100000000000001f) & 0xFFFF) >> 8) & 0xFF) << 0);
            stFrame.abData[6] |= (uint8_t)(((((uint32_t)(VOpenCell030 / 0.000100000000000001f) & 0xFFFF) >> 0) & 0xFF) << 0);
            break;
        case 30:
            stFrame.abData[1] |= (uint8_t)(((((uint32_t)(VCell031 / 0.0001f) & 0xFFFF) >> 8) & 0xFF) << 0);
            stFrame.abData[2] |= (uint8_t)(((((uint32_t)(VCell031 / 0.0001f) & 0xFFFF) >> 0) & 0xFF) << 0);
            stFrame.abData[3] |= (uint8_t)(((((uint32_t)(RCell031 / 0.01f) & 0x7FFF) >> 8) & 0x7F) << 0);
            stFrame.abData[4] |= (uint8_t)(((((uint32_t)(RCell031 / 0.01f) & 0x7FFF) >> 0) & 0xFF) << 0);
            stFrame.abData[3] |= (uint8_t)(((((uint32_t)BBalancingCell031 & 0x1) >> 0) & 0x1) << 0);
            stFrame.abData[5] |= (uint8_t)(((((uint32_t)(VOpenCell031 / 0.000100000000000001f) & 0xFFFF) >> 8) & 0xFF) << 0);
            stFrame.abData[6] |= (uint8_t)(((((uint32_t)(VOpenCell031 / 0.000100000000000001f) & 0xFFFF) >> 0) & 0xFF) << 0);
            break;
        case 31:
            stFrame.abData[1] |= (uint8_t)(((((uint32_t)(VCell032 / 0.0001f) & 0xFFFF) >> 8) & 0xFF) << 0);
            stFrame.abData[2] |= (uint8_t)(((((uint32_t)(VCell032 / 0.0001f) & 0xFFFF) >> 0) & 0xFF) << 0);
            stFrame.abData[3] |= (uint8_t)(((((uint32_t)(RCell032 / 0.01f) & 0x7FFF) >> 8) & 0x7F) << 0);
            stFrame.abData[4] |= (uint8_t)(((((uint32_t)(RCell032 / 0.01f) & 0x7FFF) >> 0) & 0xFF) << 0);
            stFrame.abData[3] |= (uint8_t)(((((uint32_t)BBalancingCell032 & 0x1) >> 0) & 0x1) << 0);
            stFrame.abData[5] |= (uint8_t)(((((uint32_t)(VOpenCell032 / 0.000100000000000001f) & 0xFFFF) >> 8) & 0xFF) << 0);
            stFrame.abData[6] |= (uint8_t)(((((uint32_t)(VOpenCell032 / 0.000100000000000001f) & 0xFFFF) >> 0) & 0xFF) << 0);
            break;
        case 32:
            stFrame.abData[1] |= (uint8_t)(((((uint32_t)(VCell033 / 0.0001f) & 0xFFFF) >> 8) & 0xFF) << 0);
            stFrame.abData[2] |= (uint8_t)(((((uint32_t)(VCell033 / 0.0001f) & 0xFFFF) >> 0) & 0xFF) << 0);
            stFrame.abData[3] |= (uint8_t)(((((uint32_t)(RCell033 / 0.01f) & 0x7FFF) >> 8) & 0x7F) << 0);
            stFrame.abData[4] |= (uint8_t)(((((uint32_t)(RCell033 / 0.01f) & 0x7FFF) >> 0) & 0xFF) << 0);
            stFrame.abData[3] |= (uint8_t)(((((uint32_t)BBalancingCell033 & 0x1) >> 0) & 0x1) << 0);
            stFrame.abData[5] |= (uint8_t)(((((uint32_t)(VOpenCell033 / 0.000100000000000001f) & 0xFFFF) >> 8) & 0xFF) << 0);
            stFrame.abData[6] |= (uint8_t)(((((uint32_t)(VOpenCell033 / 0.000100000000000001f) & 0xFFFF) >> 0) & 0xFF) << 0);
            break;
        case 33:
            stFrame.abData[1] |= (uint8_t)(((((uint32_t)(VCell034 / 0.0001f) & 0xFFFF) >> 8) & 0xFF) << 0);
            stFrame.abData[2] |= (uint8_t)(((((uint32_t)(VCell034 / 0.0001f) & 0xFFFF) >> 0) & 0xFF) << 0);
            stFrame.abData[3] |= (uint8_t)(((((uint32_t)(RCell034 / 0.01f) & 0x7FFF) >> 8) & 0x7F) << 0);
            stFrame.abData[4] |= (uint8_t)(((((uint32_t)(RCell034 / 0.01f) & 0x7FFF) >> 0) & 0xFF) << 0);
            stFrame.abData[3] |= (uint8_t)(((((uint32_t)BBalancingCell034 & 0x1) >> 0) & 0x1) << 0);
            stFrame.abData[5] |= (uint8_t)(((((uint32_t)(VOpenCell034 / 0.000100000000000001f) & 0xFFFF) >> 8) & 0xFF) << 0);
            stFrame.abData[6] |= (uint8_t)(((((uint32_t)(VOpenCell034 / 0.000100000000000001f) & 0xFFFF) >> 0) & 0xFF) << 0);
            break;
        case 34:
            stFrame.abData[1] |= (uint8_t)(((((uint32_t)(VCell035 / 0.0001f) & 0xFFFF) >> 8) & 0xFF) << 0);
            stFrame.abData[2] |= (uint8_t)(((((uint32_t)(VCell035 / 0.0001f) & 0xFFFF) >> 0) & 0xFF) << 0);
            stFrame.abData[3] |= (uint8_t)(((((uint32_t)(RCell035 / 0.01f) & 0x7FFF) >> 8) & 0x7F) << 0);
            stFrame.abData[4] |= (uint8_t)(((((uint32_t)(RCell035 / 0.01f) & 0x7FFF) >> 0) & 0xFF) << 0);
            stFrame.abData[3] |= (uint8_t)(((((uint32_t)BBalancingCell035 & 0x1) >> 0) & 0x1) << 0);
            stFrame.abData[5] |= (uint8_t)(((((uint32_t)(VOpenCell035 / 0.000100000000000001f) & 0xFFFF) >> 8) & 0xFF) << 0);
            stFrame.abData[6] |= (uint8_t)(((((uint32_t)(VOpenCell035 / 0.000100000000000001f) & 0xFFFF) >> 0) & 0xFF) << 0);
            break;
        case 35:
            stFrame.abData[1] |= (uint8_t)(((((uint32_t)(VCell036 / 0.0001f) & 0xFFFF) >> 8) & 0xFF) << 0);
            stFrame.abData[2] |= (uint8_t)(((((uint32_t)(VCell036 / 0.0001f) & 0xFFFF) >> 0) & 0xFF) << 0);
            stFrame.abData[3] |= (uint8_t)(((((uint32_t)(RCell036 / 0.01f) & 0x7FFF) >> 8) & 0x7F) << 0);
            stFrame.abData[4] |= (uint8_t)(((((uint32_t)(RCell036 / 0.01f) & 0x7FFF) >> 0) & 0xFF) << 0);
            stFrame.abData[3] |= (uint8_t)(((((uint32_t)BBalancingCell036 & 0x1) >> 0) & 0x1) << 0);
            stFrame.abData[5] |= (uint8_t)(((((uint32_t)(VOpenCell036 / 0.000100000000000001f) & 0xFFFF) >> 8) & 0xFF) << 0);
            stFrame.abData[6] |= (uint8_t)(((((uint32_t)(VOpenCell036 / 0.000100000000000001f) & 0xFFFF) >> 0) & 0xFF) << 0);
            break;
        case 36:
            stFrame.abData[1] |= (uint8_t)(((((uint32_t)(VCell037 / 0.0001f) & 0xFFFF) >> 8) & 0xFF) << 0);
            stFrame.abData[2] |= (uint8_t)(((((uint32_t)(VCell037 / 0.0001f) & 0xFFFF) >> 0) & 0xFF) << 0);
            stFrame.abData[3] |= (uint8_t)(((((uint32_t)(RCell037 / 0.01f) & 0x7FFF) >> 8) & 0x7F) << 0);
            stFrame.abData[4] |= (uint8_t)(((((uint32_t)(RCell037 / 0.01f) & 0x7FFF) >> 0) & 0xFF) << 0);
            stFrame.abData[3] |= (uint8_t)(((((uint32_t)BBalancingCell037 & 0x1) >> 0) & 0x1) << 0);
            stFrame.abData[5] |= (uint8_t)(((((uint32_t)(VOpenCell037 / 0.000100000000000001f) & 0xFFFF) >> 8) & 0xFF) << 0);
            stFrame.abData[6] |= (uint8_t)(((((uint32_t)(VOpenCell037 / 0.000100000000000001f) & 0xFFFF) >> 0) & 0xFF) << 0);
            break;
        case 37:
            stFrame.abData[1] |= (uint8_t)(((((uint32_t)(VCell038 / 0.0001f) & 0xFFFF) >> 8) & 0xFF) << 0);
            stFrame.abData[2] |= (uint8_t)(((((uint32_t)(VCell038 / 0.0001f) & 0xFFFF) >> 0) & 0xFF) << 0);
            stFrame.abData[3] |= (uint8_t)(((((uint32_t)(RCell038 / 0.01f) & 0x7FFF) >> 8) & 0x7F) << 0);
            stFrame.abData[4] |= (uint8_t)(((((uint32_t)(RCell038 / 0.01f) & 0x7FFF) >> 0) & 0xFF) << 0);
            stFrame.abData[3] |= (uint8_t)(((((uint32_t)BBalancingCell038 & 0x1) >> 0) & 0x1) << 0);
            stFrame.abData[5] |= (uint8_t)(((((uint32_t)(VOpenCell038 / 0.000100000000000001f) & 0xFFFF) >> 8) & 0xFF) << 0);
            stFrame.abData[6] |= (uint8_t)(((((uint32_t)(VOpenCell038 / 0.000100000000000001f) & 0xFFFF) >> 0) & 0xFF) << 0);
            break;
        case 38:
            stFrame.abData[1] |= (uint8_t)(((((uint32_t)(VCell039 / 0.0001f) & 0xFFFF) >> 8) & 0xFF) << 0);
            stFrame.abData[2] |= (uint8_t)(((((uint32_t)(VCell039 / 0.0001f) & 0xFFFF) >> 0) & 0xFF) << 0);
            stFrame.abData[3] |= (uint8_t)(((((uint32_t)(RCell039 / 0.01f) & 0x7FFF) >> 8) & 0x7F) << 0);
            stFrame.abData[4] |= (uint8_t)(((((uint32_t)(RCell039 / 0.01f) & 0x7FFF) >> 0) & 0xFF) << 0);
            stFrame.abData[3] |= (uint8_t)(((((uint32_t)BBalancingCell039 & 0x1) >> 0) & 0x1) << 0);
            stFrame.abData[5] |= (uint8_t)(((((uint32_t)(VOpenCell039 / 0.000100000000000001f) & 0xFFFF) >> 8) & 0xFF) << 0);
            stFrame.abData[6] |= (uint8_t)(((((uint32_t)(VOpenCell039 / 0.000100000000000001f) & 0xFFFF) >> 0) & 0xFF) << 0);
            break;
        case 39:
            stFrame.abData[1] |= (uint8_t)(((((uint32_t)(VCell040 / 0.0001f) & 0xFFFF) >> 8) & 0xFF) << 0);
            stFrame.abData[2] |= (uint8_t)(((((uint32_t)(VCell040 / 0.0001f) & 0xFFFF) >> 0) & 0xFF) << 0);
            stFrame.abData[3] |= (uint8_t)(((((uint32_t)(RCell040 / 0.01f) & 0x7FFF) >> 8) & 0x7F) << 0);
            stFrame.abData[4] |= (uint8_t)(((((uint32_t)(RCell040 / 0.01f) & 0x7FFF) >> 0) & 0xFF) << 0);
            stFrame.abData[3] |= (uint8_t)(((((uint32_t)BBalancingCell040 & 0x1) >> 0) & 0x1) << 0);
            stFrame.abData[5] |= (uint8_t)(((((uint32_t)(VOpenCell040 / 0.000100000000000001f) & 0xFFFF) >> 8) & 0xFF) << 0);
            stFrame.abData[6] |= (uint8_t)(((((uint32_t)(VOpenCell040 / 0.000100000000000001f) & 0xFFFF) >> 0) & 0xFF) << 0);
            break;
        case 40:
            stFrame.abData[1] |= (uint8_t)(((((uint32_t)(VCell041 / 0.0001f) & 0xFFFF) >> 8) & 0xFF) << 0);
            stFrame.abData[2] |= (uint8_t)(((((uint32_t)(VCell041 / 0.0001f) & 0xFFFF) >> 0) & 0xFF) << 0);
            stFrame.abData[3] |= (uint8_t)(((((uint32_t)(RCell041 / 0.01f) & 0x7FFF) >> 8) & 0x7F) << 0);
            stFrame.abData[4] |= (uint8_t)(((((uint32_t)(RCell041 / 0.01f) & 0x7FFF) >> 0) & 0xFF) << 0);
            stFrame.abData[3] |= (uint8_t)(((((uint32_t)BBalancingCell041 & 0x1) >> 0) & 0x1) << 0);
            stFrame.abData[5] |= (uint8_t)(((((uint32_t)(VOpenCell041 / 0.000100000000000001f) & 0xFFFF) >> 8) & 0xFF) << 0);
            stFrame.abData[6] |= (uint8_t)(((((uint32_t)(VOpenCell041 / 0.000100000000000001f) & 0xFFFF) >> 0) & 0xFF) << 0);
            break;
        case 41:
            stFrame.abData[1] |= (uint8_t)(((((uint32_t)(VCell042 / 0.0001f) & 0xFFFF) >> 8) & 0xFF) << 0);
            stFrame.abData[2] |= (uint8_t)(((((uint32_t)(VCell042 / 0.0001f) & 0xFFFF) >> 0) & 0xFF) << 0);
            stFrame.abData[3] |= (uint8_t)(((((uint32_t)(RCell042 / 0.01f) & 0x7FFF) >> 8) & 0x7F) << 0);
            stFrame.abData[4] |= (uint8_t)(((((uint32_t)(RCell042 / 0.01f) & 0x7FFF) >> 0) & 0xFF) << 0);
            stFrame.abData[3] |= (uint8_t)(((((uint32_t)BBalancingCell042 & 0x1) >> 0) & 0x1) << 0);
            stFrame.abData[5] |= (uint8_t)(((((uint32_t)(VOpenCell042 / 0.000100000000000001f) & 0xFFFF) >> 8) & 0xFF) << 0);
            stFrame.abData[6] |= (uint8_t)(((((uint32_t)(VOpenCell042 / 0.000100000000000001f) & 0xFFFF) >> 0) & 0xFF) << 0);
            break;
        case 42:
            stFrame.abData[1] |= (uint8_t)(((((uint32_t)(VCell043 / 0.0001f) & 0xFFFF) >> 8) & 0xFF) << 0);
            stFrame.abData[2] |= (uint8_t)(((((uint32_t)(VCell043 / 0.0001f) & 0xFFFF) >> 0) & 0xFF) << 0);
            stFrame.abData[3] |= (uint8_t)(((((uint32_t)(RCell043 / 0.01f) & 0x7FFF) >> 8) & 0x7F) << 0);
            stFrame.abData[4] |= (uint8_t)(((((uint32_t)(RCell043 / 0.01f) & 0x7FFF) >> 0) & 0xFF) << 0);
            stFrame.abData[3] |= (uint8_t)(((((uint32_t)BBalancingCell043 & 0x1) >> 0) & 0x1) << 0);
            stFrame.abData[5] |= (uint8_t)(((((uint32_t)(VOpenCell043 / 0.000100000000000001f) & 0xFFFF) >> 8) & 0xFF) << 0);
            stFrame.abData[6] |= (uint8_t)(((((uint32_t)(VOpenCell043 / 0.000100000000000001f) & 0xFFFF) >> 0) & 0xFF) << 0);
            break;
        case 43:
            stFrame.abData[1] |= (uint8_t)(((((uint32_t)(VCell044 / 0.0001f) & 0xFFFF) >> 8) & 0xFF) << 0);
            stFrame.abData[2] |= (uint8_t)(((((uint32_t)(VCell044 / 0.0001f) & 0xFFFF) >> 0) & 0xFF) << 0);
            stFrame.abData[3] |= (uint8_t)(((((uint32_t)(RCell044 / 0.01f) & 0x7FFF) >> 8) & 0x7F) << 0);
            stFrame.abData[4] |= (uint8_t)(((((uint32_t)(RCell044 / 0.01f) & 0x7FFF) >> 0) & 0xFF) << 0);
            stFrame.abData[3] |= (uint8_t)(((((uint32_t)BBalancingCell044 & 0x1) >> 0) & 0x1) << 0);
            stFrame.abData[5] |= (uint8_t)(((((uint32_t)(VOpenCell044 / 0.000100000000000001f) & 0xFFFF) >> 8) & 0xFF) << 0);
            stFrame.abData[6] |= (uint8_t)(((((uint32_t)(VOpenCell044 / 0.000100000000000001f) & 0xFFFF) >> 0) & 0xFF) << 0);
            break;
        case 44:
            stFrame.abData[1] |= (uint8_t)(((((uint32_t)(VCell045 / 0.0001f) & 0xFFFF) >> 8) & 0xFF) << 0);
            stFrame.abData[2] |= (uint8_t)(((((uint32_t)(VCell045 / 0.0001f) & 0xFFFF) >> 0) & 0xFF) << 0);
            stFrame.abData[3] |= (uint8_t)(((((uint32_t)(RCell045 / 0.01f) & 0x7FFF) >> 8) & 0x7F) << 0);
            stFrame.abData[4] |= (uint8_t)(((((uint32_t)(RCell045 / 0.01f) & 0x7FFF) >> 0) & 0xFF) << 0);
            stFrame.abData[3] |= (uint8_t)(((((uint32_t)BBalancingCell045 & 0x1) >> 0) & 0x1) << 0);
            stFrame.abData[5] |= (uint8_t)(((((uint32_t)(VOpenCell045 / 0.000100000000000001f) & 0xFFFF) >> 8) & 0xFF) << 0);
            stFrame.abData[6] |= (uint8_t)(((((uint32_t)(VOpenCell045 / 0.000100000000000001f) & 0xFFFF) >> 0) & 0xFF) << 0);
            break;
        case 45:
            stFrame.abData[1] |= (uint8_t)(((((uint32_t)(VCell046 / 0.0001f) & 0xFFFF) >> 8) & 0xFF) << 0);
            stFrame.abData[2] |= (uint8_t)(((((uint32_t)(VCell046 / 0.0001f) & 0xFFFF) >> 0) & 0xFF) << 0);
            stFrame.abData[3] |= (uint8_t)(((((uint32_t)(RCell046 / 0.01f) & 0x7FFF) >> 8) & 0x7F) << 0);
            stFrame.abData[4] |= (uint8_t)(((((uint32_t)(RCell046 / 0.01f) & 0x7FFF) >> 0) & 0xFF) << 0);
            stFrame.abData[3] |= (uint8_t)(((((uint32_t)BBalancingCell046 & 0x1) >> 0) & 0x1) << 0);
            stFrame.abData[5] |= (uint8_t)(((((uint32_t)(VOpenCell046 / 0.000100000000000001f) & 0xFFFF) >> 8) & 0xFF) << 0);
            stFrame.abData[6] |= (uint8_t)(((((uint32_t)(VOpenCell046 / 0.000100000000000001f) & 0xFFFF) >> 0) & 0xFF) << 0);
            break;
        case 46:
            stFrame.abData[1] |= (uint8_t)(((((uint32_t)(VCell047 / 0.0001f) & 0xFFFF) >> 8) & 0xFF) << 0);
            stFrame.abData[2] |= (uint8_t)(((((uint32_t)(VCell047 / 0.0001f) & 0xFFFF) >> 0) & 0xFF) << 0);
            stFrame.abData[3] |= (uint8_t)(((((uint32_t)(RCell047 / 0.01f) & 0x7FFF) >> 8) & 0x7F) << 0);
            stFrame.abData[4] |= (uint8_t)(((((uint32_t)(RCell047 / 0.01f) & 0x7FFF) >> 0) & 0xFF) << 0);
            stFrame.abData[3] |= (uint8_t)(((((uint32_t)BBalancingCell047 & 0x1) >> 0) & 0x1) << 0);
            stFrame.abData[5] |= (uint8_t)(((((uint32_t)(VOpenCell047 / 0.000100000000000001f) & 0xFFFF) >> 8) & 0xFF) << 0);
            stFrame.abData[6] |= (uint8_t)(((((uint32_t)(VOpenCell047 / 0.000100000000000001f) & 0xFFFF) >> 0) & 0xFF) << 0);
            break;
        case 47:
            stFrame.abData[1] |= (uint8_t)(((((uint32_t)(VCell048 / 0.0001f) & 0xFFFF) >> 8) & 0xFF) << 0);
            stFrame.abData[2] |= (uint8_t)(((((uint32_t)(VCell048 / 0.0001f) & 0xFFFF) >> 0) & 0xFF) << 0);
            stFrame.abData[3] |= (uint8_t)(((((uint32_t)(RCell048 / 0.01f) & 0x7FFF) >> 8) & 0x7F) << 0);
            stFrame.abData[4] |= (uint8_t)(((((uint32_t)(RCell048 / 0.01f) & 0x7FFF) >> 0) & 0xFF) << 0);
            stFrame.abData[3] |= (uint8_t)(((((uint32_t)BBalancingCell048 & 0x1) >> 0) & 0x1) << 0);
            stFrame.abData[5] |= (uint8_t)(((((uint32_t)(VOpenCell048 / 0.000100000000000001f) & 0xFFFF) >> 8) & 0xFF) << 0);
            stFrame.abData[6] |= (uint8_t)(((((uint32_t)(VOpenCell048 / 0.000100000000000001f) & 0xFFFF) >> 0) & 0xFF) << 0);
            break;
        case 48:
            stFrame.abData[1] |= (uint8_t)(((((uint32_t)(VCell049 / 0.0001f) & 0xFFFF) >> 8) & 0xFF) << 0);
            stFrame.abData[2] |= (uint8_t)(((((uint32_t)(VCell049 / 0.0001f) & 0xFFFF) >> 0) & 0xFF) << 0);
            stFrame.abData[3] |= (uint8_t)(((((uint32_t)(RCell049 / 0.01f) & 0x7FFF) >> 8) & 0x7F) << 0);
            stFrame.abData[4] |= (uint8_t)(((((uint32_t)(RCell049 / 0.01f) & 0x7FFF) >> 0) & 0xFF) << 0);
            stFrame.abData[3] |= (uint8_t)(((((uint32_t)BBalancingCell049 & 0x1) >> 0) & 0x1) << 0);
            stFrame.abData[5] |= (uint8_t)(((((uint32_t)(VOpenCell049 / 0.000100000000000001f) & 0xFFFF) >> 8) & 0xFF) << 0);
            stFrame.abData[6] |= (uint8_t)(((((uint32_t)(VOpenCell049 / 0.000100000000000001f) & 0xFFFF) >> 0) & 0xFF) << 0);
            break;
        case 49:
            stFrame.abData[1] |= (uint8_t)(((((uint32_t)(VCell050 / 0.0001f) & 0xFFFF) >> 8) & 0xFF) << 0);
            stFrame.abData[2] |= (uint8_t)(((((uint32_t)(VCell050 / 0.0001f) & 0xFFFF) >> 0) & 0xFF) << 0);
            stFrame.abData[3] |= (uint8_t)(((((uint32_t)(RCell050 / 0.01f) & 0x7FFF) >> 8) & 0x7F) << 0);
            stFrame.abData[4] |= (uint8_t)(((((uint32_t)(RCell050 / 0.01f) & 0x7FFF) >> 0) & 0xFF) << 0);
            stFrame.abData[3] |= (uint8_t)(((((uint32_t)BBalancingCell050 & 0x1) >> 0) & 0x1) << 0);
            stFrame.abData[5] |= (uint8_t)(((((uint32_t)(VOpenCell050 / 0.000100000000000001f) & 0xFFFF) >> 8) & 0xFF) << 0);
            stFrame.abData[6] |= (uint8_t)(((((uint32_t)(VOpenCell050 / 0.000100000000000001f) & 0xFFFF) >> 0) & 0xFF) << 0);
            break;
        case 50:
            stFrame.abData[1] |= (uint8_t)(((((uint32_t)(VCell051 / 0.0001f) & 0xFFFF) >> 8) & 0xFF) << 0);
            stFrame.abData[2] |= (uint8_t)(((((uint32_t)(VCell051 / 0.0001f) & 0xFFFF) >> 0) & 0xFF) << 0);
            stFrame.abData[3] |= (uint8_t)(((((uint32_t)(RCell051 / 0.01f) & 0x7FFF) >> 8) & 0x7F) << 0);
            stFrame.abData[4] |= (uint8_t)(((((uint32_t)(RCell051 / 0.01f) & 0x7FFF) >> 0) & 0xFF) << 0);
            stFrame.abData[3] |= (uint8_t)(((((uint32_t)BBalancingCell051 & 0x1) >> 0) & 0x1) << 0);
            stFrame.abData[5] |= (uint8_t)(((((uint32_t)(VOpenCell051 / 0.000100000000000001f) & 0xFFFF) >> 8) & 0xFF) << 0);
            stFrame.abData[6] |= (uint8_t)(((((uint32_t)(VOpenCell051 / 0.000100000000000001f) & 0xFFFF) >> 0) & 0xFF) << 0);
            break;
        case 51:
            stFrame.abData[1] |= (uint8_t)(((((uint32_t)(VCell052 / 0.0001f) & 0xFFFF) >> 8) & 0xFF) << 0);
            stFrame.abData[2] |= (uint8_t)(((((uint32_t)(VCell052 / 0.0001f) & 0xFFFF) >> 0) & 0xFF) << 0);
            stFrame.abData[3] |= (uint8_t)(((((uint32_t)(RCell052 / 0.01f) & 0x7FFF) >> 8) & 0x7F) << 0);
            stFrame.abData[4] |= (uint8_t)(((((uint32_t)(RCell052 / 0.01f) & 0x7FFF) >> 0) & 0xFF) << 0);
            stFrame.abData[3] |= (uint8_t)(((((uint32_t)BBalancingCell052 & 0x1) >> 0) & 0x1) << 0);
            stFrame.abData[5] |= (uint8_t)(((((uint32_t)(VOpenCell052 / 0.000100000000000001f) & 0xFFFF) >> 8) & 0xFF) << 0);
            stFrame.abData[6] |= (uint8_t)(((((uint32_t)(VOpenCell052 / 0.000100000000000001f) & 0xFFFF) >> 0) & 0xFF) << 0);
            break;
        case 52:
            stFrame.abData[1] |= (uint8_t)(((((uint32_t)(VCell053 / 0.0001f) & 0xFFFF) >> 8) & 0xFF) << 0);
            stFrame.abData[2] |= (uint8_t)(((((uint32_t)(VCell053 / 0.0001f) & 0xFFFF) >> 0) & 0xFF) << 0);
            stFrame.abData[3] |= (uint8_t)(((((uint32_t)(RCell053 / 0.01f) & 0x7FFF) >> 8) & 0x7F) << 0);
            stFrame.abData[4] |= (uint8_t)(((((uint32_t)(RCell053 / 0.01f) & 0x7FFF) >> 0) & 0xFF) << 0);
            stFrame.abData[3] |= (uint8_t)(((((uint32_t)BBalancingCell053 & 0x1) >> 0) & 0x1) << 0);
            stFrame.abData[5] |= (uint8_t)(((((uint32_t)(VOpenCell053 / 0.000100000000000001f) & 0xFFFF) >> 8) & 0xFF) << 0);
            stFrame.abData[6] |= (uint8_t)(((((uint32_t)(VOpenCell053 / 0.000100000000000001f) & 0xFFFF) >> 0) & 0xFF) << 0);
            break;
        case 53:
            stFrame.abData[1] |= (uint8_t)(((((uint32_t)(VCell054 / 0.0001f) & 0xFFFF) >> 8) & 0xFF) << 0);
            stFrame.abData[2] |= (uint8_t)(((((uint32_t)(VCell054 / 0.0001f) & 0xFFFF) >> 0) & 0xFF) << 0);
            stFrame.abData[3] |= (uint8_t)(((((uint32_t)(RCell054 / 0.01f) & 0x7FFF) >> 8) & 0x7F) << 0);
            stFrame.abData[4] |= (uint8_t)(((((uint32_t)(RCell054 / 0.01f) & 0x7FFF) >> 0) & 0xFF) << 0);
            stFrame.abData[3] |= (uint8_t)(((((uint32_t)BBalancingCell054 & 0x1) >> 0) & 0x1) << 0);
            stFrame.abData[5] |= (uint8_t)(((((uint32_t)(VOpenCell054 / 0.000100000000000001f) & 0xFFFF) >> 8) & 0xFF) << 0);
            stFrame.abData[6] |= (uint8_t)(((((uint32_t)(VOpenCell054 / 0.000100000000000001f) & 0xFFFF) >> 0) & 0xFF) << 0);
            break;
        case 54:
            stFrame.abData[1] |= (uint8_t)(((((uint32_t)(VCell055 / 0.0001f) & 0xFFFF) >> 8) & 0xFF) << 0);
            stFrame.abData[2] |= (uint8_t)(((((uint32_t)(VCell055 / 0.0001f) & 0xFFFF) >> 0) & 0xFF) << 0);
            stFrame.abData[3] |= (uint8_t)(((((uint32_t)(RCell055 / 0.01f) & 0x7FFF) >> 8) & 0x7F) << 0);
            stFrame.abData[4] |= (uint8_t)(((((uint32_t)(RCell055 / 0.01f) & 0x7FFF) >> 0) & 0xFF) << 0);
            stFrame.abData[3] |= (uint8_t)(((((uint32_t)BBalancingCell055 & 0x1) >> 0) & 0x1) << 0);
            stFrame.abData[5] |= (uint8_t)(((((uint32_t)(VOpenCell055 / 0.000100000000000001f) & 0xFFFF) >> 8) & 0xFF) << 0);
            stFrame.abData[6] |= (uint8_t)(((((uint32_t)(VOpenCell055 / 0.000100000000000001f) & 0xFFFF) >> 0) & 0xFF) << 0);
            break;
        case 55:
            stFrame.abData[1] |= (uint8_t)(((((uint32_t)(VCell056 / 0.0001f) & 0xFFFF) >> 8) & 0xFF) << 0);
            stFrame.abData[2] |= (uint8_t)(((((uint32_t)(VCell056 / 0.0001f) & 0xFFFF) >> 0) & 0xFF) << 0);
            stFrame.abData[3] |= (uint8_t)(((((uint32_t)(RCell056 / 0.01f) & 0x7FFF) >> 8) & 0x7F) << 0);
            stFrame.abData[4] |= (uint8_t)(((((uint32_t)(RCell056 / 0.01f) & 0x7FFF) >> 0) & 0xFF) << 0);
            stFrame.abData[3] |= (uint8_t)(((((uint32_t)BBalancingCell056 & 0x1) >> 0) & 0x1) << 0);
            stFrame.abData[5] |= (uint8_t)(((((uint32_t)(VOpenCell056 / 0.000100000000000001f) & 0xFFFF) >> 8) & 0xFF) << 0);
            stFrame.abData[6] |= (uint8_t)(((((uint32_t)(VOpenCell056 / 0.000100000000000001f) & 0xFFFF) >> 0) & 0xFF) << 0);
            break;
        case 56:
            stFrame.abData[1] |= (uint8_t)(((((uint32_t)(VCell057 / 0.0001f) & 0xFFFF) >> 8) & 0xFF) << 0);
            stFrame.abData[2] |= (uint8_t)(((((uint32_t)(VCell057 / 0.0001f) & 0xFFFF) >> 0) & 0xFF) << 0);
            stFrame.abData[3] |= (uint8_t)(((((uint32_t)(RCell057 / 0.01f) & 0x7FFF) >> 8) & 0x7F) << 0);
            stFrame.abData[4] |= (uint8_t)(((((uint32_t)(RCell057 / 0.01f) & 0x7FFF) >> 0) & 0xFF) << 0);
            stFrame.abData[3] |= (uint8_t)(((((uint32_t)BBalancingCell057 & 0x1) >> 0) & 0x1) << 0);
            stFrame.abData[5] |= (uint8_t)(((((uint32_t)(VOpenCell057 / 0.000100000000000001f) & 0xFFFF) >> 8) & 0xFF) << 0);
            stFrame.abData[6] |= (uint8_t)(((((uint32_t)(VOpenCell057 / 0.000100000000000001f) & 0xFFFF) >> 0) & 0xFF) << 0);
            break;
        case 57:
            stFrame.abData[1] |= (uint8_t)(((((uint32_t)(VCell058 / 0.0001f) & 0xFFFF) >> 8) & 0xFF) << 0);
            stFrame.abData[2] |= (uint8_t)(((((uint32_t)(VCell058 / 0.0001f) & 0xFFFF) >> 0) & 0xFF) << 0);
            stFrame.abData[3] |= (uint8_t)(((((uint32_t)(RCell058 / 0.01f) & 0x7FFF) >> 8) & 0x7F) << 0);
            stFrame.abData[4] |= (uint8_t)(((((uint32_t)(RCell058 / 0.01f) & 0x7FFF) >> 0) & 0xFF) << 0);
            stFrame.abData[3] |= (uint8_t)(((((uint32_t)BBalancingCell058 & 0x1) >> 0) & 0x1) << 0);
            stFrame.abData[5] |= (uint8_t)(((((uint32_t)(VOpenCell058 / 0.000100000000000001f) & 0xFFFF) >> 8) & 0xFF) << 0);
            stFrame.abData[6] |= (uint8_t)(((((uint32_t)(VOpenCell058 / 0.000100000000000001f) & 0xFFFF) >> 0) & 0xFF) << 0);
            break;
        case 58:
            stFrame.abData[1] |= (uint8_t)(((((uint32_t)(VCell059 / 0.0001f) & 0xFFFF) >> 8) & 0xFF) << 0);
            stFrame.abData[2] |= (uint8_t)(((((uint32_t)(VCell059 / 0.0001f) & 0xFFFF) >> 0) & 0xFF) << 0);
            stFrame.abData[3] |= (uint8_t)(((((uint32_t)(RCell059 / 0.01f) & 0x7FFF) >> 8) & 0x7F) << 0);
            stFrame.abData[4] |= (uint8_t)(((((uint32_t)(RCell059 / 0.01f) & 0x7FFF) >> 0) & 0xFF) << 0);
            stFrame.abData[3] |= (uint8_t)(((((uint32_t)BBalancingCell059 & 0x1) >> 0) & 0x1) << 0);
            stFrame.abData[5] |= (uint8_t)(((((uint32_t)(VOpenCell059 / 0.000100000000000001f) & 0xFFFF) >> 8) & 0xFF) << 0);
            stFrame.abData[6] |= (uint8_t)(((((uint32_t)(VOpenCell059 / 0.000100000000000001f) & 0xFFFF) >> 0) & 0xFF) << 0);
            break;
        case 59:
            stFrame.abData[1] |= (uint8_t)(((((uint32_t)(VCell060 / 0.0001f) & 0xFFFF) >> 8) & 0xFF) << 0);
            stFrame.abData[2] |= (uint8_t)(((((uint32_t)(VCell060 / 0.0001f) & 0xFFFF) >> 0) & 0xFF) << 0);
            stFrame.abData[3] |= (uint8_t)(((((uint32_t)(RCell060 / 0.01f) & 0x7FFF) >> 8) & 0x7F) << 0);
            stFrame.abData[4] |= (uint8_t)(((((uint32_t)(RCell060 / 0.01f) & 0x7FFF) >> 0) & 0xFF) << 0);
            stFrame.abData[3] |= (uint8_t)(((((uint32_t)BBalancingCell060 & 0x1) >> 0) & 0x1) << 0);
            stFrame.abData[5] |= (uint8_t)(((((uint32_t)(VOpenCell060 / 0.000100000000000001f) & 0xFFFF) >> 8) & 0xFF) << 0);
            stFrame.abData[6] |= (uint8_t)(((((uint32_t)(VOpenCell060 / 0.000100000000000001f) & 0xFFFF) >> 0) & 0xFF) << 0);
            break;
        case 60:
            stFrame.abData[1] |= (uint8_t)(((((uint32_t)(VCell061 / 0.0001f) & 0xFFFF) >> 8) & 0xFF) << 0);
            stFrame.abData[2] |= (uint8_t)(((((uint32_t)(VCell061 / 0.0001f) & 0xFFFF) >> 0) & 0xFF) << 0);
            stFrame.abData[3] |= (uint8_t)(((((uint32_t)(RCell061 / 0.01f) & 0x7FFF) >> 8) & 0x7F) << 0);
            stFrame.abData[4] |= (uint8_t)(((((uint32_t)(RCell061 / 0.01f) & 0x7FFF) >> 0) & 0xFF) << 0);
            stFrame.abData[3] |= (uint8_t)(((((uint32_t)BBalancingCell061 & 0x1) >> 0) & 0x1) << 0);
            stFrame.abData[5] |= (uint8_t)(((((uint32_t)(VOpenCell061 / 0.000100000000000001f) & 0xFFFF) >> 8) & 0xFF) << 0);
            stFrame.abData[6] |= (uint8_t)(((((uint32_t)(VOpenCell061 / 0.000100000000000001f) & 0xFFFF) >> 0) & 0xFF) << 0);
            break;
        case 61:
            stFrame.abData[1] |= (uint8_t)(((((uint32_t)(VCell062 / 0.0001f) & 0xFFFF) >> 8) & 0xFF) << 0);
            stFrame.abData[2] |= (uint8_t)(((((uint32_t)(VCell062 / 0.0001f) & 0xFFFF) >> 0) & 0xFF) << 0);
            stFrame.abData[3] |= (uint8_t)(((((uint32_t)(RCell062 / 0.01f) & 0x7FFF) >> 8) & 0x7F) << 0);
            stFrame.abData[4] |= (uint8_t)(((((uint32_t)(RCell062 / 0.01f) & 0x7FFF) >> 0) & 0xFF) << 0);
            stFrame.abData[3] |= (uint8_t)(((((uint32_t)BBalancingCell062 & 0x1) >> 0) & 0x1) << 0);
            stFrame.abData[5] |= (uint8_t)(((((uint32_t)(VOpenCell062 / 0.000100000000000001f) & 0xFFFF) >> 8) & 0xFF) << 0);
            stFrame.abData[6] |= (uint8_t)(((((uint32_t)(VOpenCell062 / 0.000100000000000001f) & 0xFFFF) >> 0) & 0xFF) << 0);
            break;
        case 62:
            stFrame.abData[1] |= (uint8_t)(((((uint32_t)(VCell063 / 0.0001f) & 0xFFFF) >> 8) & 0xFF) << 0);
            stFrame.abData[2] |= (uint8_t)(((((uint32_t)(VCell063 / 0.0001f) & 0xFFFF) >> 0) & 0xFF) << 0);
            stFrame.abData[3] |= (uint8_t)(((((uint32_t)(RCell063 / 0.01f) & 0x7FFF) >> 8) & 0x7F) << 0);
            stFrame.abData[4] |= (uint8_t)(((((uint32_t)(RCell063 / 0.01f) & 0x7FFF) >> 0) & 0xFF) << 0);
            stFrame.abData[3] |= (uint8_t)(((((uint32_t)BBalancingCell063 & 0x1) >> 0) & 0x1) << 0);
            stFrame.abData[5] |= (uint8_t)(((((uint32_t)(VOpenCell063 / 0.000100000000000001f) & 0xFFFF) >> 8) & 0xFF) << 0);
            stFrame.abData[6] |= (uint8_t)(((((uint32_t)(VOpenCell063 / 0.000100000000000001f) & 0xFFFF) >> 0) & 0xFF) << 0);
            break;
        case 63:
            stFrame.abData[1] |= (uint8_t)(((((uint32_t)(VCell064 / 0.0001f) & 0xFFFF) >> 8) & 0xFF) << 0);
            stFrame.abData[2] |= (uint8_t)(((((uint32_t)(VCell064 / 0.0001f) & 0xFFFF) >> 0) & 0xFF) << 0);
            stFrame.abData[3] |= (uint8_t)(((((uint32_t)(RCell064 / 0.01f) & 0x7FFF) >> 8) & 0x7F) << 0);
            stFrame.abData[4] |= (uint8_t)(((((uint32_t)(RCell064 / 0.01f) & 0x7FFF) >> 0) & 0xFF) << 0);
            stFrame.abData[3] |= (uint8_t)(((((uint32_t)BBalancingCell064 & 0x1) >> 0) & 0x1) << 0);
            stFrame.abData[5] |= (uint8_t)(((((uint32_t)(VOpenCell064 / 0.000100000000000001f) & 0xFFFF) >> 8) & 0xFF) << 0);
            stFrame.abData[6] |= (uint8_t)(((((uint32_t)(VOpenCell064 / 0.000100000000000001f) & 0xFFFF) >> 0) & 0xFF) << 0);
            break;
        case 64:
            stFrame.abData[1] |= (uint8_t)(((((uint32_t)(VCell065 / 0.0001f) & 0xFFFF) >> 8) & 0xFF) << 0);
            stFrame.abData[2] |= (uint8_t)(((((uint32_t)(VCell065 / 0.0001f) & 0xFFFF) >> 0) & 0xFF) << 0);
            stFrame.abData[3] |= (uint8_t)(((((uint32_t)(RCell065 / 0.01f) & 0x7FFF) >> 8) & 0x7F) << 0);
            stFrame.abData[4] |= (uint8_t)(((((uint32_t)(RCell065 / 0.01f) & 0x7FFF) >> 0) & 0xFF) << 0);
            stFrame.abData[3] |= (uint8_t)(((((uint32_t)BBalancingCell065 & 0x1) >> 0) & 0x1) << 0);
            stFrame.abData[5] |= (uint8_t)(((((uint32_t)(VOpenCell065 / 0.000100000000000001f) & 0xFFFF) >> 8) & 0xFF) << 0);
            stFrame.abData[6] |= (uint8_t)(((((uint32_t)(VOpenCell065 / 0.000100000000000001f) & 0xFFFF) >> 0) & 0xFF) << 0);
            break;
        case 65:
            stFrame.abData[1] |= (uint8_t)(((((uint32_t)(VCell066 / 0.0001f) & 0xFFFF) >> 8) & 0xFF) << 0);
            stFrame.abData[2] |= (uint8_t)(((((uint32_t)(VCell066 / 0.0001f) & 0xFFFF) >> 0) & 0xFF) << 0);
            stFrame.abData[3] |= (uint8_t)(((((uint32_t)(RCell066 / 0.01f) & 0x7FFF) >> 8) & 0x7F) << 0);
            stFrame.abData[4] |= (uint8_t)(((((uint32_t)(RCell066 / 0.01f) & 0x7FFF) >> 0) & 0xFF) << 0);
            stFrame.abData[3] |= (uint8_t)(((((uint32_t)BBalancingCell066 & 0x1) >> 0) & 0x1) << 0);
            stFrame.abData[5] |= (uint8_t)(((((uint32_t)(VOpenCell066 / 0.000100000000000001f) & 0xFFFF) >> 8) & 0xFF) << 0);
            stFrame.abData[6] |= (uint8_t)(((((uint32_t)(VOpenCell066 / 0.000100000000000001f) & 0xFFFF) >> 0) & 0xFF) << 0);
            break;
        case 66:
            stFrame.abData[1] |= (uint8_t)(((((uint32_t)(VCell067 / 0.0001f) & 0xFFFF) >> 8) & 0xFF) << 0);
            stFrame.abData[2] |= (uint8_t)(((((uint32_t)(VCell067 / 0.0001f) & 0xFFFF) >> 0) & 0xFF) << 0);
            stFrame.abData[3] |= (uint8_t)(((((uint32_t)(RCell067 / 0.01f) & 0x7FFF) >> 8) & 0x7F) << 0);
            stFrame.abData[4] |= (uint8_t)(((((uint32_t)(RCell067 / 0.01f) & 0x7FFF) >> 0) & 0xFF) << 0);
            stFrame.abData[3] |= (uint8_t)(((((uint32_t)BBalancingCell067 & 0x1) >> 0) & 0x1) << 0);
            stFrame.abData[5] |= (uint8_t)(((((uint32_t)(VOpenCell067 / 0.000100000000000001f) & 0xFFFF) >> 8) & 0xFF) << 0);
            stFrame.abData[6] |= (uint8_t)(((((uint32_t)(VOpenCell067 / 0.000100000000000001f) & 0xFFFF) >> 0) & 0xFF) << 0);
            break;
        case 67:
            stFrame.abData[1] |= (uint8_t)(((((uint32_t)(VCell068 / 0.0001f) & 0xFFFF) >> 8) & 0xFF) << 0);
            stFrame.abData[2] |= (uint8_t)(((((uint32_t)(VCell068 / 0.0001f) & 0xFFFF) >> 0) & 0xFF) << 0);
            stFrame.abData[3] |= (uint8_t)(((((uint32_t)(RCell068 / 0.01f) & 0x7FFF) >> 8) & 0x7F) << 0);
            stFrame.abData[4] |= (uint8_t)(((((uint32_t)(RCell068 / 0.01f) & 0x7FFF) >> 0) & 0xFF) << 0);
            stFrame.abData[3] |= (uint8_t)(((((uint32_t)BBalancingCell068 & 0x1) >> 0) & 0x1) << 0);
            stFrame.abData[5] |= (uint8_t)(((((uint32_t)(VOpenCell068 / 0.000100000000000001f) & 0xFFFF) >> 8) & 0xFF) << 0);
            stFrame.abData[6] |= (uint8_t)(((((uint32_t)(VOpenCell068 / 0.000100000000000001f) & 0xFFFF) >> 0) & 0xFF) << 0);
            break;
        case 68:
            stFrame.abData[1] |= (uint8_t)(((((uint32_t)(VCell069 / 0.0001f) & 0xFFFF) >> 8) & 0xFF) << 0);
            stFrame.abData[2] |= (uint8_t)(((((uint32_t)(VCell069 / 0.0001f) & 0xFFFF) >> 0) & 0xFF) << 0);
            stFrame.abData[3] |= (uint8_t)(((((uint32_t)(RCell069 / 0.01f) & 0x7FFF) >> 8) & 0x7F) << 0);
            stFrame.abData[4] |= (uint8_t)(((((uint32_t)(RCell069 / 0.01f) & 0x7FFF) >> 0) & 0xFF) << 0);
            stFrame.abData[3] |= (uint8_t)(((((uint32_t)BBalancingCell069 & 0x1) >> 0) & 0x1) << 0);
            stFrame.abData[5] |= (uint8_t)(((((uint32_t)(VOpenCell069 / 0.000100000000000001f) & 0xFFFF) >> 8) & 0xFF) << 0);
            stFrame.abData[6] |= (uint8_t)(((((uint32_t)(VOpenCell069 / 0.000100000000000001f) & 0xFFFF) >> 0) & 0xFF) << 0);
            break;
        case 69:
            stFrame.abData[1] |= (uint8_t)(((((uint32_t)(VCell070 / 0.0001f) & 0xFFFF) >> 8) & 0xFF) << 0);
            stFrame.abData[2] |= (uint8_t)(((((uint32_t)(VCell070 / 0.0001f) & 0xFFFF) >> 0) & 0xFF) << 0);
            stFrame.abData[3] |= (uint8_t)(((((uint32_t)(RCell070 / 0.01f) & 0x7FFF) >> 8) & 0x7F) << 0);
            stFrame.abData[4] |= (uint8_t)(((((uint32_t)(RCell070 / 0.01f) & 0x7FFF) >> 0) & 0xFF) << 0);
            stFrame.abData[3] |= (uint8_t)(((((uint32_t)BBalancingCell070 & 0x1) >> 0) & 0x1) << 0);
            stFrame.abData[5] |= (uint8_t)(((((uint32_t)(VOpenCell070 / 0.000100000000000001f) & 0xFFFF) >> 8) & 0xFF) << 0);
            stFrame.abData[6] |= (uint8_t)(((((uint32_t)(VOpenCell070 / 0.000100000000000001f) & 0xFFFF) >> 0) & 0xFF) << 0);
            break;
        case 70:
            stFrame.abData[1] |= (uint8_t)(((((uint32_t)(VCell071 / 0.0001f) & 0xFFFF) >> 8) & 0xFF) << 0);
            stFrame.abData[2] |= (uint8_t)(((((uint32_t)(VCell071 / 0.0001f) & 0xFFFF) >> 0) & 0xFF) << 0);
            stFrame.abData[3] |= (uint8_t)(((((uint32_t)(RCell071 / 0.01f) & 0x7FFF) >> 8) & 0x7F) << 0);
            stFrame.abData[4] |= (uint8_t)(((((uint32_t)(RCell071 / 0.01f) & 0x7FFF) >> 0) & 0xFF) << 0);
            stFrame.abData[3] |= (uint8_t)(((((uint32_t)BBalancingCell071 & 0x1) >> 0) & 0x1) << 0);
            stFrame.abData[5] |= (uint8_t)(((((uint32_t)(VOpenCell071 / 0.000100000000000001f) & 0xFFFF) >> 8) & 0xFF) << 0);
            stFrame.abData[6] |= (uint8_t)(((((uint32_t)(VOpenCell071 / 0.000100000000000001f) & 0xFFFF) >> 0) & 0xFF) << 0);
            break;
        case 71:
            stFrame.abData[1] |= (uint8_t)(((((uint32_t)(VCell072 / 0.0001f) & 0xFFFF) >> 8) & 0xFF) << 0);
            stFrame.abData[2] |= (uint8_t)(((((uint32_t)(VCell072 / 0.0001f) & 0xFFFF) >> 0) & 0xFF) << 0);
            stFrame.abData[3] |= (uint8_t)(((((uint32_t)(RCell072 / 0.01f) & 0x7FFF) >> 8) & 0x7F) << 0);
            stFrame.abData[4] |= (uint8_t)(((((uint32_t)(RCell072 / 0.01f) & 0x7FFF) >> 0) & 0xFF) << 0);
            stFrame.abData[3] |= (uint8_t)(((((uint32_t)BBalancingCell072 & 0x1) >> 0) & 0x1) << 0);
            stFrame.abData[5] |= (uint8_t)(((((uint32_t)(VOpenCell072 / 0.000100000000000001f) & 0xFFFF) >> 8) & 0xFF) << 0);
            stFrame.abData[6] |= (uint8_t)(((((uint32_t)(VOpenCell072 / 0.000100000000000001f) & 0xFFFF) >> 0) & 0xFF) << 0);
            break;
        case 72:
            stFrame.abData[1] |= (uint8_t)(((((uint32_t)(VCell073 / 0.0001f) & 0xFFFF) >> 8) & 0xFF) << 0);
            stFrame.abData[2] |= (uint8_t)(((((uint32_t)(VCell073 / 0.0001f) & 0xFFFF) >> 0) & 0xFF) << 0);
            stFrame.abData[3] |= (uint8_t)(((((uint32_t)(RCell073 / 0.01f) & 0x7FFF) >> 8) & 0x7F) << 0);
            stFrame.abData[4] |= (uint8_t)(((((uint32_t)(RCell073 / 0.01f) & 0x7FFF) >> 0) & 0xFF) << 0);
            stFrame.abData[3] |= (uint8_t)(((((uint32_t)BBalancingCell073 & 0x1) >> 0) & 0x1) << 0);
            stFrame.abData[5] |= (uint8_t)(((((uint32_t)(VOpenCell073 / 0.000100000000000001f) & 0xFFFF) >> 8) & 0xFF) << 0);
            stFrame.abData[6] |= (uint8_t)(((((uint32_t)(VOpenCell073 / 0.000100000000000001f) & 0xFFFF) >> 0) & 0xFF) << 0);
            break;
        case 73:
            stFrame.abData[1] |= (uint8_t)(((((uint32_t)(VCell074 / 0.0001f) & 0xFFFF) >> 8) & 0xFF) << 0);
            stFrame.abData[2] |= (uint8_t)(((((uint32_t)(VCell074 / 0.0001f) & 0xFFFF) >> 0) & 0xFF) << 0);
            stFrame.abData[3] |= (uint8_t)(((((uint32_t)(RCell074 / 0.01f) & 0x7FFF) >> 8) & 0x7F) << 0);
            stFrame.abData[4] |= (uint8_t)(((((uint32_t)(RCell074 / 0.01f) & 0x7FFF) >> 0) & 0xFF) << 0);
            stFrame.abData[3] |= (uint8_t)(((((uint32_t)BBalancingCell074 & 0x1) >> 0) & 0x1) << 0);
            stFrame.abData[5] |= (uint8_t)(((((uint32_t)(VOpenCell074 / 0.000100000000000001f) & 0xFFFF) >> 8) & 0xFF) << 0);
            stFrame.abData[6] |= (uint8_t)(((((uint32_t)(VOpenCell074 / 0.000100000000000001f) & 0xFFFF) >> 0) & 0xFF) << 0);
            break;
        case 74:
            stFrame.abData[1] |= (uint8_t)(((((uint32_t)(VCell075 / 0.0001f) & 0xFFFF) >> 8) & 0xFF) << 0);
            stFrame.abData[2] |= (uint8_t)(((((uint32_t)(VCell075 / 0.0001f) & 0xFFFF) >> 0) & 0xFF) << 0);
            stFrame.abData[3] |= (uint8_t)(((((uint32_t)(RCell075 / 0.01f) & 0x7FFF) >> 8) & 0x7F) << 0);
            stFrame.abData[4] |= (uint8_t)(((((uint32_t)(RCell075 / 0.01f) & 0x7FFF) >> 0) & 0xFF) << 0);
            stFrame.abData[3] |= (uint8_t)(((((uint32_t)BBalancingCell075 & 0x1) >> 0) & 0x1) << 0);
            stFrame.abData[5] |= (uint8_t)(((((uint32_t)(VOpenCell075 / 0.000100000000000001f) & 0xFFFF) >> 8) & 0xFF) << 0);
            stFrame.abData[6] |= (uint8_t)(((((uint32_t)(VOpenCell075 / 0.000100000000000001f) & 0xFFFF) >> 0) & 0xFF) << 0);
            break;
        case 75:
            stFrame.abData[1] |= (uint8_t)(((((uint32_t)(VCell076 / 0.0001f) & 0xFFFF) >> 8) & 0xFF) << 0);
            stFrame.abData[2] |= (uint8_t)(((((uint32_t)(VCell076 / 0.0001f) & 0xFFFF) >> 0) & 0xFF) << 0);
            stFrame.abData[3] |= (uint8_t)(((((uint32_t)(RCell076 / 0.01f) & 0x7FFF) >> 8) & 0x7F) << 0);
            stFrame.abData[4] |= (uint8_t)(((((uint32_t)(RCell076 / 0.01f) & 0x7FFF) >> 0) & 0xFF) << 0);
            stFrame.abData[3] |= (uint8_t)(((((uint32_t)BBalancingCell076 & 0x1) >> 0) & 0x1) << 0);
            stFrame.abData[5] |= (uint8_t)(((((uint32_t)(VOpenCell076 / 0.000100000000000001f) & 0xFFFF) >> 8) & 0xFF) << 0);
            stFrame.abData[6] |= (uint8_t)(((((uint32_t)(VOpenCell076 / 0.000100000000000001f) & 0xFFFF) >> 0) & 0xFF) << 0);
            break;
        case 76:
            stFrame.abData[1] |= (uint8_t)(((((uint32_t)(VCell077 / 0.0001f) & 0xFFFF) >> 8) & 0xFF) << 0);
            stFrame.abData[2] |= (uint8_t)(((((uint32_t)(VCell077 / 0.0001f) & 0xFFFF) >> 0) & 0xFF) << 0);
            stFrame.abData[3] |= (uint8_t)(((((uint32_t)(RCell077 / 0.01f) & 0x7FFF) >> 8) & 0x7F) << 0);
            stFrame.abData[4] |= (uint8_t)(((((uint32_t)(RCell077 / 0.01f) & 0x7FFF) >> 0) & 0xFF) << 0);
            stFrame.abData[3] |= (uint8_t)(((((uint32_t)BBalancingCell077 & 0x1) >> 0) & 0x1) << 0);
            stFrame.abData[5] |= (uint8_t)(((((uint32_t)(VOpenCell077 / 0.000100000000000001f) & 0xFFFF) >> 8) & 0xFF) << 0);
            stFrame.abData[6] |= (uint8_t)(((((uint32_t)(VOpenCell077 / 0.000100000000000001f) & 0xFFFF) >> 0) & 0xFF) << 0);
            break;
        case 77:
            stFrame.abData[1] |= (uint8_t)(((((uint32_t)(VCell078 / 0.0001f) & 0xFFFF) >> 8) & 0xFF) << 0);
            stFrame.abData[2] |= (uint8_t)(((((uint32_t)(VCell078 / 0.0001f) & 0xFFFF) >> 0) & 0xFF) << 0);
            stFrame.abData[3] |= (uint8_t)(((((uint32_t)(RCell078 / 0.01f) & 0x7FFF) >> 8) & 0x7F) << 0);
            stFrame.abData[4] |= (uint8_t)(((((uint32_t)(RCell078 / 0.01f) & 0x7FFF) >> 0) & 0xFF) << 0);
            stFrame.abData[3] |= (uint8_t)(((((uint32_t)BBalancingCell078 & 0x1) >> 0) & 0x1) << 0);
            stFrame.abData[5] |= (uint8_t)(((((uint32_t)(VOpenCell078 / 0.000100000000000001f) & 0xFFFF) >> 8) & 0xFF) << 0);
            stFrame.abData[6] |= (uint8_t)(((((uint32_t)(VOpenCell078 / 0.000100000000000001f) & 0xFFFF) >> 0) & 0xFF) << 0);
            break;
        case 78:
            stFrame.abData[1] |= (uint8_t)(((((uint32_t)(VCell079 / 0.0001f) & 0xFFFF) >> 8) & 0xFF) << 0);
            stFrame.abData[2] |= (uint8_t)(((((uint32_t)(VCell079 / 0.0001f) & 0xFFFF) >> 0) & 0xFF) << 0);
            stFrame.abData[3] |= (uint8_t)(((((uint32_t)(RCell079 / 0.01f) & 0x7FFF) >> 8) & 0x7F) << 0);
            stFrame.abData[4] |= (uint8_t)(((((uint32_t)(RCell079 / 0.01f) & 0x7FFF) >> 0) & 0xFF) << 0);
            stFrame.abData[3] |= (uint8_t)(((((uint32_t)BBalancingCell079 & 0x1) >> 0) & 0x1) << 0);
            stFrame.abData[5] |= (uint8_t)(((((uint32_t)(VOpenCell079 / 0.000100000000000001f) & 0xFFFF) >> 8) & 0xFF) << 0);
            stFrame.abData[6] |= (uint8_t)(((((uint32_t)(VOpenCell079 / 0.000100000000000001f) & 0xFFFF) >> 0) & 0xFF) << 0);
            break;
        case 79:
            stFrame.abData[1] |= (uint8_t)(((((uint32_t)(VCell080 / 0.0001f) & 0xFFFF) >> 8) & 0xFF) << 0);
            stFrame.abData[2] |= (uint8_t)(((((uint32_t)(VCell080 / 0.0001f) & 0xFFFF) >> 0) & 0xFF) << 0);
            stFrame.abData[3] |= (uint8_t)(((((uint32_t)(RCell080 / 0.01f) & 0x7FFF) >> 8) & 0x7F) << 0);
            stFrame.abData[4] |= (uint8_t)(((((uint32_t)(RCell080 / 0.01f) & 0x7FFF) >> 0) & 0xFF) << 0);
            stFrame.abData[3] |= (uint8_t)(((((uint32_t)BBalancingCell080 & 0x1) >> 0) & 0x1) << 0);
            stFrame.abData[5] |= (uint8_t)(((((uint32_t)(VOpenCell080 / 0.000100000000000001f) & 0xFFFF) >> 8) & 0xFF) << 0);
            stFrame.abData[6] |= (uint8_t)(((((uint32_t)(VOpenCell080 / 0.000100000000000001f) & 0xFFFF) >> 0) & 0xFF) << 0);
            break;
        case 80:
            stFrame.abData[1] |= (uint8_t)(((((uint32_t)(VCell081 / 0.0001f) & 0xFFFF) >> 8) & 0xFF) << 0);
            stFrame.abData[2] |= (uint8_t)(((((uint32_t)(VCell081 / 0.0001f) & 0xFFFF) >> 0) & 0xFF) << 0);
            stFrame.abData[3] |= (uint8_t)(((((uint32_t)(RCell081 / 0.01f) & 0x7FFF) >> 8) & 0x7F) << 0);
            stFrame.abData[4] |= (uint8_t)(((((uint32_t)(RCell081 / 0.01f) & 0x7FFF) >> 0) & 0xFF) << 0);
            stFrame.abData[3] |= (uint8_t)(((((uint32_t)BBalancingCell081 & 0x1) >> 0) & 0x1) << 0);
            stFrame.abData[5] |= (uint8_t)(((((uint32_t)(VOpenCell081 / 0.000100000000000001f) & 0xFFFF) >> 8) & 0xFF) << 0);
            stFrame.abData[6] |= (uint8_t)(((((uint32_t)(VOpenCell081 / 0.000100000000000001f) & 0xFFFF) >> 0) & 0xFF) << 0);
            break;
        case 81:
            stFrame.abData[1] |= (uint8_t)(((((uint32_t)(VCell082 / 0.0001f) & 0xFFFF) >> 8) & 0xFF) << 0);
            stFrame.abData[2] |= (uint8_t)(((((uint32_t)(VCell082 / 0.0001f) & 0xFFFF) >> 0) & 0xFF) << 0);
            stFrame.abData[3] |= (uint8_t)(((((uint32_t)(RCell082 / 0.01f) & 0x7FFF) >> 8) & 0x7F) << 0);
            stFrame.abData[4] |= (uint8_t)(((((uint32_t)(RCell082 / 0.01f) & 0x7FFF) >> 0) & 0xFF) << 0);
            stFrame.abData[3] |= (uint8_t)(((((uint32_t)BBalancingCell082 & 0x1) >> 0) & 0x1) << 0);
            stFrame.abData[5] |= (uint8_t)(((((uint32_t)(VOpenCell082 / 0.000100000000000001f) & 0xFFFF) >> 8) & 0xFF) << 0);
            stFrame.abData[6] |= (uint8_t)(((((uint32_t)(VOpenCell082 / 0.000100000000000001f) & 0xFFFF) >> 0) & 0xFF) << 0);
            break;
        case 82:
            stFrame.abData[1] |= (uint8_t)(((((uint32_t)(VCell083 / 0.0001f) & 0xFFFF) >> 8) & 0xFF) << 0);
            stFrame.abData[2] |= (uint8_t)(((((uint32_t)(VCell083 / 0.0001f) & 0xFFFF) >> 0) & 0xFF) << 0);
            stFrame.abData[3] |= (uint8_t)(((((uint32_t)(RCell083 / 0.01f) & 0x7FFF) >> 8) & 0x7F) << 0);
            stFrame.abData[4] |= (uint8_t)(((((uint32_t)(RCell083 / 0.01f) & 0x7FFF) >> 0) & 0xFF) << 0);
            stFrame.abData[3] |= (uint8_t)(((((uint32_t)BBalancingCell083 & 0x1) >> 0) & 0x1) << 0);
            stFrame.abData[5] |= (uint8_t)(((((uint32_t)(VOpenCell083 / 0.000100000000000001f) & 0xFFFF) >> 8) & 0xFF) << 0);
            stFrame.abData[6] |= (uint8_t)(((((uint32_t)(VOpenCell083 / 0.000100000000000001f) & 0xFFFF) >> 0) & 0xFF) << 0);
            break;
        case 83:
            stFrame.abData[1] |= (uint8_t)(((((uint32_t)(VCell084 / 0.0001f) & 0xFFFF) >> 8) & 0xFF) << 0);
            stFrame.abData[2] |= (uint8_t)(((((uint32_t)(VCell084 / 0.0001f) & 0xFFFF) >> 0) & 0xFF) << 0);
            stFrame.abData[3] |= (uint8_t)(((((uint32_t)(RCell084 / 0.01f) & 0x7FFF) >> 8) & 0x7F) << 0);
            stFrame.abData[4] |= (uint8_t)(((((uint32_t)(RCell084 / 0.01f) & 0x7FFF) >> 0) & 0xFF) << 0);
            stFrame.abData[3] |= (uint8_t)(((((uint32_t)BBalancingCell084 & 0x1) >> 0) & 0x1) << 0);
            stFrame.abData[5] |= (uint8_t)(((((uint32_t)(VOpenCell084 / 0.000100000000000001f) & 0xFFFF) >> 8) & 0xFF) << 0);
            stFrame.abData[6] |= (uint8_t)(((((uint32_t)(VOpenCell084 / 0.000100000000000001f) & 0xFFFF) >> 0) & 0xFF) << 0);
            break;
        case 84:
            stFrame.abData[1] |= (uint8_t)(((((uint32_t)(VCell085 / 0.0001f) & 0xFFFF) >> 8) & 0xFF) << 0);
            stFrame.abData[2] |= (uint8_t)(((((uint32_t)(VCell085 / 0.0001f) & 0xFFFF) >> 0) & 0xFF) << 0);
            stFrame.abData[3] |= (uint8_t)(((((uint32_t)(RCell085 / 0.01f) & 0x7FFF) >> 8) & 0x7F) << 0);
            stFrame.abData[4] |= (uint8_t)(((((uint32_t)(RCell085 / 0.01f) & 0x7FFF) >> 0) & 0xFF) << 0);
            stFrame.abData[3] |= (uint8_t)(((((uint32_t)BBalancingCell085 & 0x1) >> 0) & 0x1) << 0);
            stFrame.abData[5] |= (uint8_t)(((((uint32_t)(VOpenCell085 / 0.000100000000000001f) & 0xFFFF) >> 8) & 0xFF) << 0);
            stFrame.abData[6] |= (uint8_t)(((((uint32_t)(VOpenCell085 / 0.000100000000000001f) & 0xFFFF) >> 0) & 0xFF) << 0);
            break;
        case 85:
            stFrame.abData[1] |= (uint8_t)(((((uint32_t)(VCell086 / 0.0001f) & 0xFFFF) >> 8) & 0xFF) << 0);
            stFrame.abData[2] |= (uint8_t)(((((uint32_t)(VCell086 / 0.0001f) & 0xFFFF) >> 0) & 0xFF) << 0);
            stFrame.abData[3] |= (uint8_t)(((((uint32_t)(RCell086 / 0.01f) & 0x7FFF) >> 8) & 0x7F) << 0);
            stFrame.abData[4] |= (uint8_t)(((((uint32_t)(RCell086 / 0.01f) & 0x7FFF) >> 0) & 0xFF) << 0);
            stFrame.abData[3] |= (uint8_t)(((((uint32_t)BBalancingCell086 & 0x1) >> 0) & 0x1) << 0);
            stFrame.abData[5] |= (uint8_t)(((((uint32_t)(VOpenCell086 / 0.000100000000000001f) & 0xFFFF) >> 8) & 0xFF) << 0);
            stFrame.abData[6] |= (uint8_t)(((((uint32_t)(VOpenCell086 / 0.000100000000000001f) & 0xFFFF) >> 0) & 0xFF) << 0);
            break;
        case 86:
            stFrame.abData[1] |= (uint8_t)(((((uint32_t)(VCell087 / 0.0001f) & 0xFFFF) >> 8) & 0xFF) << 0);
            stFrame.abData[2] |= (uint8_t)(((((uint32_t)(VCell087 / 0.0001f) & 0xFFFF) >> 0) & 0xFF) << 0);
            stFrame.abData[3] |= (uint8_t)(((((uint32_t)(RCell087 / 0.01f) & 0x7FFF) >> 8) & 0x7F) << 0);
            stFrame.abData[4] |= (uint8_t)(((((uint32_t)(RCell087 / 0.01f) & 0x7FFF) >> 0) & 0xFF) << 0);
            stFrame.abData[3] |= (uint8_t)(((((uint32_t)BBalancingCell087 & 0x1) >> 0) & 0x1) << 0);
            stFrame.abData[5] |= (uint8_t)(((((uint32_t)(VOpenCell087 / 0.000100000000000001f) & 0xFFFF) >> 8) & 0xFF) << 0);
            stFrame.abData[6] |= (uint8_t)(((((uint32_t)(VOpenCell087 / 0.000100000000000001f) & 0xFFFF) >> 0) & 0xFF) << 0);
            break;
        case 87:
            stFrame.abData[1] |= (uint8_t)(((((uint32_t)(VCell088 / 0.0001f) & 0xFFFF) >> 8) & 0xFF) << 0);
            stFrame.abData[2] |= (uint8_t)(((((uint32_t)(VCell088 / 0.0001f) & 0xFFFF) >> 0) & 0xFF) << 0);
            stFrame.abData[3] |= (uint8_t)(((((uint32_t)(RCell088 / 0.01f) & 0x7FFF) >> 8) & 0x7F) << 0);
            stFrame.abData[4] |= (uint8_t)(((((uint32_t)(RCell088 / 0.01f) & 0x7FFF) >> 0) & 0xFF) << 0);
            stFrame.abData[3] |= (uint8_t)(((((uint32_t)BBalancingCell088 & 0x1) >> 0) & 0x1) << 0);
            stFrame.abData[5] |= (uint8_t)(((((uint32_t)(VOpenCell088 / 0.000100000000000001f) & 0xFFFF) >> 8) & 0xFF) << 0);
            stFrame.abData[6] |= (uint8_t)(((((uint32_t)(VOpenCell088 / 0.000100000000000001f) & 0xFFFF) >> 0) & 0xFF) << 0);
            break;
        case 88:
            stFrame.abData[1] |= (uint8_t)(((((uint32_t)(VCell089 / 0.0001f) & 0xFFFF) >> 8) & 0xFF) << 0);
            stFrame.abData[2] |= (uint8_t)(((((uint32_t)(VCell089 / 0.0001f) & 0xFFFF) >> 0) & 0xFF) << 0);
            stFrame.abData[3] |= (uint8_t)(((((uint32_t)(RCell089 / 0.01f) & 0x7FFF) >> 8) & 0x7F) << 0);
            stFrame.abData[4] |= (uint8_t)(((((uint32_t)(RCell089 / 0.01f) & 0x7FFF) >> 0) & 0xFF) << 0);
            stFrame.abData[3] |= (uint8_t)(((((uint32_t)BBalancingCell089 & 0x1) >> 0) & 0x1) << 0);
            stFrame.abData[5] |= (uint8_t)(((((uint32_t)(VOpenCell089 / 0.000100000000000001f) & 0xFFFF) >> 8) & 0xFF) << 0);
            stFrame.abData[6] |= (uint8_t)(((((uint32_t)(VOpenCell089 / 0.000100000000000001f) & 0xFFFF) >> 0) & 0xFF) << 0);
            break;
        case 89:
            stFrame.abData[1] |= (uint8_t)(((((uint32_t)(VCell090 / 0.000100000000000001f) & 0xFFFF) >> 8) & 0xFF) << 0);
            stFrame.abData[2] |= (uint8_t)(((((uint32_t)(VCell090 / 0.000100000000000001f) & 0xFFFF) >> 0) & 0xFF) << 0);
            stFrame.abData[3] |= (uint8_t)(((((uint32_t)(RCell090 / 0.01f) & 0x7FFF) >> 8) & 0x7F) << 0);
            stFrame.abData[4] |= (uint8_t)(((((uint32_t)(RCell090 / 0.01f) & 0x7FFF) >> 0) & 0xFF) << 0);
            stFrame.abData[3] |= (uint8_t)(((((uint32_t)BBalancingCell090 & 0x1) >> 0) & 0x1) << 0);
            stFrame.abData[5] |= (uint8_t)(((((uint32_t)(VOpenCell090 / 0.000100000000000001f) & 0xFFFF) >> 8) & 0xFF) << 0);
            stFrame.abData[6] |= (uint8_t)(((((uint32_t)(VOpenCell090 / 0.000100000000000001f) & 0xFFFF) >> 0) & 0xFF) << 0);
            break;
        case 90:
            stFrame.abData[1] |= (uint8_t)(((((uint32_t)(VCell091 / 0.000100000000000001f) & 0xFFFF) >> 8) & 0xFF) << 0);
            stFrame.abData[2] |= (uint8_t)(((((uint32_t)(VCell091 / 0.000100000000000001f) & 0xFFFF) >> 0) & 0xFF) << 0);
            stFrame.abData[3] |= (uint8_t)(((((uint32_t)(RCell091 / 0.01f) & 0x7FFF) >> 8) & 0x7F) << 0);
            stFrame.abData[4] |= (uint8_t)(((((uint32_t)(RCell091 / 0.01f) & 0x7FFF) >> 0) & 0xFF) << 0);
            stFrame.abData[3] |= (uint8_t)(((((uint32_t)BBalancingCell091 & 0x1) >> 0) & 0x1) << 0);
            stFrame.abData[5] |= (uint8_t)(((((uint32_t)(VOpenCell091 / 0.000100000000000001f) & 0xFFFF) >> 8) & 0xFF) << 0);
            stFrame.abData[6] |= (uint8_t)(((((uint32_t)(VOpenCell091 / 0.000100000000000001f) & 0xFFFF) >> 0) & 0xFF) << 0);
            break;
        case 91:
            stFrame.abData[1] |= (uint8_t)(((((uint32_t)(VCell092 / 0.000100000000000001f) & 0xFFFF) >> 8) & 0xFF) << 0);
            stFrame.abData[2] |= (uint8_t)(((((uint32_t)(VCell092 / 0.000100000000000001f) & 0xFFFF) >> 0) & 0xFF) << 0);
            stFrame.abData[3] |= (uint8_t)(((((uint32_t)(RCell092 / 0.01f) & 0x7FFF) >> 8) & 0x7F) << 0);
            stFrame.abData[4] |= (uint8_t)(((((uint32_t)(RCell092 / 0.01f) & 0x7FFF) >> 0) & 0xFF) << 0);
            stFrame.abData[3] |= (uint8_t)(((((uint32_t)BBalancingCell092 & 0x1) >> 0) & 0x1) << 0);
            stFrame.abData[5] |= (uint8_t)(((((uint32_t)(VOpenCell092 / 0.000100000000000001f) & 0xFFFF) >> 8) & 0xFF) << 0);
            stFrame.abData[6] |= (uint8_t)(((((uint32_t)(VOpenCell092 / 0.000100000000000001f) & 0xFFFF) >> 0) & 0xFF) << 0);
            break;
        case 92:
            stFrame.abData[1] |= (uint8_t)(((((uint32_t)(VCell093 / 0.000100000000000001f) & 0xFFFF) >> 8) & 0xFF) << 0);
            stFrame.abData[2] |= (uint8_t)(((((uint32_t)(VCell093 / 0.000100000000000001f) & 0xFFFF) >> 0) & 0xFF) << 0);
            stFrame.abData[3] |= (uint8_t)(((((uint32_t)(RCell093 / 0.01f) & 0x7FFF) >> 8) & 0x7F) << 0);
            stFrame.abData[4] |= (uint8_t)(((((uint32_t)(RCell093 / 0.01f) & 0x7FFF) >> 0) & 0xFF) << 0);
            stFrame.abData[3] |= (uint8_t)(((((uint32_t)BBalancingCell093 & 0x1) >> 0) & 0x1) << 0);
            stFrame.abData[5] |= (uint8_t)(((((uint32_t)(VOpenCell093 / 0.000100000000000001f) & 0xFFFF) >> 8) & 0xFF) << 0);
            stFrame.abData[6] |= (uint8_t)(((((uint32_t)(VOpenCell093 / 0.000100000000000001f) & 0xFFFF) >> 0) & 0xFF) << 0);
            break;
        case 93:
            stFrame.abData[1] |= (uint8_t)(((((uint32_t)(VCell094 / 0.000100000000000001f) & 0xFFFF) >> 8) & 0xFF) << 0);
            stFrame.abData[2] |= (uint8_t)(((((uint32_t)(VCell094 / 0.000100000000000001f) & 0xFFFF) >> 0) & 0xFF) << 0);
            stFrame.abData[3] |= (uint8_t)(((((uint32_t)(RCell094 / 0.01f) & 0x7FFF) >> 8) & 0x7F) << 0);
            stFrame.abData[4] |= (uint8_t)(((((uint32_t)(RCell094 / 0.01f) & 0x7FFF) >> 0) & 0xFF) << 0);
            stFrame.abData[3] |= (uint8_t)(((((uint32_t)BBalancingCell094 & 0x1) >> 0) & 0x1) << 0);
            stFrame.abData[5] |= (uint8_t)(((((uint32_t)(VOpenCell094 / 0.000100000000000001f) & 0xFFFF) >> 8) & 0xFF) << 0);
            stFrame.abData[6] |= (uint8_t)(((((uint32_t)(VOpenCell094 / 0.000100000000000001f) & 0xFFFF) >> 0) & 0xFF) << 0);
            break;
        case 94:
            stFrame.abData[1] |= (uint8_t)(((((uint32_t)(VCell095 / 0.000100000000000001f) & 0xFFFF) >> 8) & 0xFF) << 0);
            stFrame.abData[2] |= (uint8_t)(((((uint32_t)(VCell095 / 0.000100000000000001f) & 0xFFFF) >> 0) & 0xFF) << 0);
            stFrame.abData[3] |= (uint8_t)(((((uint32_t)(RCell095 / 0.01f) & 0x7FFF) >> 8) & 0x7F) << 0);
            stFrame.abData[4] |= (uint8_t)(((((uint32_t)(RCell095 / 0.01f) & 0x7FFF) >> 0) & 0xFF) << 0);
            stFrame.abData[3] |= (uint8_t)(((((uint32_t)BBalancingCell095 & 0x1) >> 0) & 0x1) << 0);
            stFrame.abData[5] |= (uint8_t)(((((uint32_t)(VOpenCell095 / 0.000100000000000001f) & 0xFFFF) >> 8) & 0xFF) << 0);
            stFrame.abData[6] |= (uint8_t)(((((uint32_t)(VOpenCell095 / 0.000100000000000001f) & 0xFFFF) >> 0) & 0xFF) << 0);
            break;
        case 95:
            stFrame.abData[1] |= (uint8_t)(((((uint32_t)(VCell096 / 0.000100000000000001f) & 0xFFFF) >> 8) & 0xFF) << 0);
            stFrame.abData[2] |= (uint8_t)(((((uint32_t)(VCell096 / 0.000100000000000001f) & 0xFFFF) >> 0) & 0xFF) << 0);
            stFrame.abData[3] |= (uint8_t)(((((uint32_t)(RCell096 / 0.01f) & 0x7FFF) >> 8) & 0x7F) << 0);
            stFrame.abData[4] |= (uint8_t)(((((uint32_t)(RCell096 / 0.01f) & 0x7FFF) >> 0) & 0xFF) << 0);
            stFrame.abData[3] |= (uint8_t)(((((uint32_t)BBalancingCell096 & 0x1) >> 0) & 0x1) << 0);
            stFrame.abData[5] |= (uint8_t)(((((uint32_t)(VOpenCell096 / 0.000100000000000001f) & 0xFFFF) >> 8) & 0xFF) << 0);
            stFrame.abData[6] |= (uint8_t)(((((uint32_t)(VOpenCell096 / 0.000100000000000001f) & 0xFFFF) >> 0) & 0xFF) << 0);
            break;
        case 96:
            stFrame.abData[1] |= (uint8_t)(((((uint32_t)(VCell097 / 0.000100000000000001f) & 0xFFFF) >> 8) & 0xFF) << 0);
            stFrame.abData[2] |= (uint8_t)(((((uint32_t)(VCell097 / 0.000100000000000001f) & 0xFFFF) >> 0) & 0xFF) << 0);
            stFrame.abData[3] |= (uint8_t)(((((uint32_t)(RCell097 / 0.01f) & 0x7FFF) >> 8) & 0x7F) << 0);
            stFrame.abData[4] |= (uint8_t)(((((uint32_t)(RCell097 / 0.01f) & 0x7FFF) >> 0) & 0xFF) << 0);
            stFrame.abData[3] |= (uint8_t)(((((uint32_t)BBalancingCell097 & 0x1) >> 0) & 0x1) << 0);
            stFrame.abData[5] |= (uint8_t)(((((uint32_t)(VOpenCell097 / 0.000100000000000001f) & 0xFFFF) >> 8) & 0xFF) << 0);
            stFrame.abData[6] |= (uint8_t)(((((uint32_t)(VOpenCell097 / 0.000100000000000001f) & 0xFFFF) >> 0) & 0xFF) << 0);
            break;
        case 97:
            stFrame.abData[1] |= (uint8_t)(((((uint32_t)(VCell098 / 0.000100000000000001f) & 0xFFFF) >> 8) & 0xFF) << 0);
            stFrame.abData[2] |= (uint8_t)(((((uint32_t)(VCell098 / 0.000100000000000001f) & 0xFFFF) >> 0) & 0xFF) << 0);
            stFrame.abData[3] |= (uint8_t)(((((uint32_t)(RCell098 / 0.01f) & 0x7FFF) >> 8) & 0x7F) << 0);
            stFrame.abData[4] |= (uint8_t)(((((uint32_t)(RCell098 / 0.01f) & 0x7FFF) >> 0) & 0xFF) << 0);
            stFrame.abData[3] |= (uint8_t)(((((uint32_t)BBalancingCell098 & 0x1) >> 0) & 0x1) << 0);
            stFrame.abData[5] |= (uint8_t)(((((uint32_t)(VOpenCell098 / 0.000100000000000001f) & 0xFFFF) >> 8) & 0xFF) << 0);
            stFrame.abData[6] |= (uint8_t)(((((uint32_t)(VOpenCell098 / 0.000100000000000001f) & 0xFFFF) >> 0) & 0xFF) << 0);
            break;
        case 98:
            stFrame.abData[1] |= (uint8_t)(((((uint32_t)(VCell099 / 0.000100000000000001f) & 0xFFFF) >> 8) & 0xFF) << 0);
            stFrame.abData[2] |= (uint8_t)(((((uint32_t)(VCell099 / 0.000100000000000001f) & 0xFFFF) >> 0) & 0xFF) << 0);
            stFrame.abData[3] |= (uint8_t)(((((uint32_t)(RCell099 / 0.01f) & 0x7FFF) >> 8) & 0x7F) << 0);
            stFrame.abData[4] |= (uint8_t)(((((uint32_t)(RCell099 / 0.01f) & 0x7FFF) >> 0) & 0xFF) << 0);
            stFrame.abData[3] |= (uint8_t)(((((uint32_t)BBalancingCell099 & 0x1) >> 0) & 0x1) << 0);
            stFrame.abData[5] |= (uint8_t)(((((uint32_t)(VOpenCell099 / 0.000100000000000001f) & 0xFFFF) >> 8) & 0xFF) << 0);
            stFrame.abData[6] |= (uint8_t)(((((uint32_t)(VOpenCell099 / 0.000100000000000001f) & 0xFFFF) >> 0) & 0xFF) << 0);
            break;
        case 99:
            stFrame.abData[1] |= (uint8_t)(((((uint32_t)(VCell100 / 0.000100000000000001f) & 0xFFFF) >> 8) & 0xFF) << 0);
            stFrame.abData[2] |= (uint8_t)(((((uint32_t)(VCell100 / 0.000100000000000001f) & 0xFFFF) >> 0) & 0xFF) << 0);
            stFrame.abData[3] |= (uint8_t)(((((uint32_t)(RCell100 / 0.01f) & 0x7FFF) >> 8) & 0x7F) << 0);
            stFrame.abData[4] |= (uint8_t)(((((uint32_t)(RCell100 / 0.01f) & 0x7FFF) >> 0) & 0xFF) << 0);
            stFrame.abData[3] |= (uint8_t)(((((uint32_t)BBalancingCell100 & 0x1) >> 0) & 0x1) << 0);
            stFrame.abData[5] |= (uint8_t)(((((uint32_t)(VOpenCell100 / 0.000100000000000001f) & 0xFFFF) >> 8) & 0xFF) << 0);
            stFrame.abData[6] |= (uint8_t)(((((uint32_t)(VOpenCell100 / 0.000100000000000001f) & 0xFFFF) >> 0) & 0xFF) << 0);
            break;
        case 100:
            stFrame.abData[1] |= (uint8_t)(((((uint32_t)(VCell101 / 0.000100000000000001f) & 0xFFFF) >> 8) & 0xFF) << 0);
            stFrame.abData[2] |= (uint8_t)(((((uint32_t)(VCell101 / 0.000100000000000001f) & 0xFFFF) >> 0) & 0xFF) << 0);
            stFrame.abData[3] |= (uint8_t)(((((uint32_t)(RCell101 / 0.01f) & 0x7FFF) >> 8) & 0x7F) << 0);
            stFrame.abData[4] |= (uint8_t)(((((uint32_t)(RCell101 / 0.01f) & 0x7FFF) >> 0) & 0xFF) << 0);
            stFrame.abData[3] |= (uint8_t)(((((uint32_t)BBalancingCell101 & 0x1) >> 0) & 0x1) << 0);
            stFrame.abData[5] |= (uint8_t)(((((uint32_t)(VOpenCell101 / 0.000100000000000001f) & 0xFFFF) >> 8) & 0xFF) << 0);
            stFrame.abData[6] |= (uint8_t)(((((uint32_t)(VOpenCell101 / 0.000100000000000001f) & 0xFFFF) >> 0) & 0xFF) << 0);
            break;
        case 101:
            stFrame.abData[1] |= (uint8_t)(((((uint32_t)(VCell102 / 0.000100000000000001f) & 0xFFFF) >> 8) & 0xFF) << 0);
            stFrame.abData[2] |= (uint8_t)(((((uint32_t)(VCell102 / 0.000100000000000001f) & 0xFFFF) >> 0) & 0xFF) << 0);
            stFrame.abData[3] |= (uint8_t)(((((uint32_t)(RCell102 / 0.01f) & 0x7FFF) >> 8) & 0x7F) << 0);
            stFrame.abData[4] |= (uint8_t)(((((uint32_t)(RCell102 / 0.01f) & 0x7FFF) >> 0) & 0xFF) << 0);
            stFrame.abData[3] |= (uint8_t)(((((uint32_t)BBalancingCell102 & 0x1) >> 0) & 0x1) << 0);
            stFrame.abData[5] |= (uint8_t)(((((uint32_t)(VOpenCell102 / 0.000100000000000001f) & 0xFFFF) >> 8) & 0xFF) << 0);
            stFrame.abData[6] |= (uint8_t)(((((uint32_t)(VOpenCell102 / 0.000100000000000001f) & 0xFFFF) >> 0) & 0xFF) << 0);
            break;
        case 102:
            stFrame.abData[1] |= (uint8_t)(((((uint32_t)(VCell103 / 0.000100000000000001f) & 0xFFFF) >> 8) & 0xFF) << 0);
            stFrame.abData[2] |= (uint8_t)(((((uint32_t)(VCell103 / 0.000100000000000001f) & 0xFFFF) >> 0) & 0xFF) << 0);
            stFrame.abData[3] |= (uint8_t)(((((uint32_t)(RCell103 / 0.01f) & 0x7FFF) >> 8) & 0x7F) << 0);
            stFrame.abData[4] |= (uint8_t)(((((uint32_t)(RCell103 / 0.01f) & 0x7FFF) >> 0) & 0xFF) << 0);
            stFrame.abData[3] |= (uint8_t)(((((uint32_t)BBalancingCell103 & 0x1) >> 0) & 0x1) << 0);
            stFrame.abData[5] |= (uint8_t)(((((uint32_t)(VOpenCell103 / 0.000100000000000001f) & 0xFFFF) >> 8) & 0xFF) << 0);
            stFrame.abData[6] |= (uint8_t)(((((uint32_t)(VOpenCell103 / 0.000100000000000001f) & 0xFFFF) >> 0) & 0xFF) << 0);
            break;
        case 103:
            stFrame.abData[1] |= (uint8_t)(((((uint32_t)(VCell104 / 0.000100000000000001f) & 0xFFFF) >> 8) & 0xFF) << 0);
            stFrame.abData[2] |= (uint8_t)(((((uint32_t)(VCell104 / 0.000100000000000001f) & 0xFFFF) >> 0) & 0xFF) << 0);
            stFrame.abData[3] |= (uint8_t)(((((uint32_t)(RCell104 / 0.01f) & 0x7FFF) >> 8) & 0x7F) << 0);
            stFrame.abData[4] |= (uint8_t)(((((uint32_t)(RCell104 / 0.01f) & 0x7FFF) >> 0) & 0xFF) << 0);
            stFrame.abData[3] |= (uint8_t)(((((uint32_t)BBalancingCell104 & 0x1) >> 0) & 0x1) << 0);
            stFrame.abData[5] |= (uint8_t)(((((uint32_t)(VOpenCell104 / 0.000100000000000001f) & 0xFFFF) >> 8) & 0xFF) << 0);
            stFrame.abData[6] |= (uint8_t)(((((uint32_t)(VOpenCell104 / 0.000100000000000001f) & 0xFFFF) >> 0) & 0xFF) << 0);
            break;
        case 104:
            stFrame.abData[1] |= (uint8_t)(((((uint32_t)(VCell105 / 0.000100000000000001f) & 0xFFFF) >> 8) & 0xFF) << 0);
            stFrame.abData[2] |= (uint8_t)(((((uint32_t)(VCell105 / 0.000100000000000001f) & 0xFFFF) >> 0) & 0xFF) << 0);
            stFrame.abData[3] |= (uint8_t)(((((uint32_t)(RCell105 / 0.01f) & 0x7FFF) >> 8) & 0x7F) << 0);
            stFrame.abData[4] |= (uint8_t)(((((uint32_t)(RCell105 / 0.01f) & 0x7FFF) >> 0) & 0xFF) << 0);
            stFrame.abData[3] |= (uint8_t)(((((uint32_t)BBalancingCell105 & 0x1) >> 0) & 0x1) << 0);
            stFrame.abData[5] |= (uint8_t)(((((uint32_t)(VOpenCell105 / 0.000100000000000001f) & 0xFFFF) >> 8) & 0xFF) << 0);
            stFrame.abData[6] |= (uint8_t)(((((uint32_t)(VOpenCell105 / 0.000100000000000001f) & 0xFFFF) >> 0) & 0xFF) << 0);
            break;
        case 105:
            stFrame.abData[1] |= (uint8_t)(((((uint32_t)(VCell106 / 0.000100000000000001f) & 0xFFFF) >> 8) & 0xFF) << 0);
            stFrame.abData[2] |= (uint8_t)(((((uint32_t)(VCell106 / 0.000100000000000001f) & 0xFFFF) >> 0) & 0xFF) << 0);
            stFrame.abData[3] |= (uint8_t)(((((uint32_t)(RCell106 / 0.01f) & 0x7FFF) >> 8) & 0x7F) << 0);
            stFrame.abData[4] |= (uint8_t)(((((uint32_t)(RCell106 / 0.01f) & 0x7FFF) >> 0) & 0xFF) << 0);
            stFrame.abData[3] |= (uint8_t)(((((uint32_t)BBalancingCell106 & 0x1) >> 0) & 0x1) << 0);
            stFrame.abData[5] |= (uint8_t)(((((uint32_t)(VOpenCell106 / 0.000100000000000001f) & 0xFFFF) >> 8) & 0xFF) << 0);
            stFrame.abData[6] |= (uint8_t)(((((uint32_t)(VOpenCell106 / 0.000100000000000001f) & 0xFFFF) >> 0) & 0xFF) << 0);
            break;
        case 106:
            stFrame.abData[1] |= (uint8_t)(((((uint32_t)(VCell107 / 0.000100000000000001f) & 0xFFFF) >> 8) & 0xFF) << 0);
            stFrame.abData[2] |= (uint8_t)(((((uint32_t)(VCell107 / 0.000100000000000001f) & 0xFFFF) >> 0) & 0xFF) << 0);
            stFrame.abData[3] |= (uint8_t)(((((uint32_t)(RCell107 / 0.01f) & 0x7FFF) >> 8) & 0x7F) << 0);
            stFrame.abData[4] |= (uint8_t)(((((uint32_t)(RCell107 / 0.01f) & 0x7FFF) >> 0) & 0xFF) << 0);
            stFrame.abData[3] |= (uint8_t)(((((uint32_t)BBalancingCell107 & 0x1) >> 0) & 0x1) << 0);
            stFrame.abData[5] |= (uint8_t)(((((uint32_t)(VOpenCell107 / 0.000100000000000001f) & 0xFFFF) >> 8) & 0xFF) << 0);
            stFrame.abData[6] |= (uint8_t)(((((uint32_t)(VOpenCell107 / 0.000100000000000001f) & 0xFFFF) >> 0) & 0xFF) << 0);
            break;
        case 107:
            stFrame.abData[1] |= (uint8_t)(((((uint32_t)(VCell108 / 0.000100000000000001f) & 0xFFFF) >> 8) & 0xFF) << 0);
            stFrame.abData[2] |= (uint8_t)(((((uint32_t)(VCell108 / 0.000100000000000001f) & 0xFFFF) >> 0) & 0xFF) << 0);
            stFrame.abData[3] |= (uint8_t)(((((uint32_t)(RCell108 / 0.01f) & 0x7FFF) >> 8) & 0x7F) << 0);
            stFrame.abData[4] |= (uint8_t)(((((uint32_t)(RCell108 / 0.01f) & 0x7FFF) >> 0) & 0xFF) << 0);
            stFrame.abData[3] |= (uint8_t)(((((uint32_t)BBalancingCell108 & 0x1) >> 0) & 0x1) << 0);
            stFrame.abData[5] |= (uint8_t)(((((uint32_t)(VOpenCell108 / 0.000100000000000001f) & 0xFFFF) >> 8) & 0xFF) << 0);
            stFrame.abData[6] |= (uint8_t)(((((uint32_t)(VOpenCell108 / 0.000100000000000001f) & 0xFFFF) >> 0) & 0xFF) << 0);
            break;
        case 108:
            stFrame.abData[1] |= (uint8_t)(((((uint32_t)(VCell109 / 0.000100000000000001f) & 0xFFFF) >> 8) & 0xFF) << 0);
            stFrame.abData[2] |= (uint8_t)(((((uint32_t)(VCell109 / 0.000100000000000001f) & 0xFFFF) >> 0) & 0xFF) << 0);
            stFrame.abData[3] |= (uint8_t)(((((uint32_t)(RCell109 / 0.01f) & 0x7FFF) >> 8) & 0x7F) << 0);
            stFrame.abData[4] |= (uint8_t)(((((uint32_t)(RCell109 / 0.01f) & 0x7FFF) >> 0) & 0xFF) << 0);
            stFrame.abData[3] |= (uint8_t)(((((uint32_t)BBalancingCell109 & 0x1) >> 0) & 0x1) << 0);
            stFrame.abData[5] |= (uint8_t)(((((uint32_t)(VOpenCell109 / 0.000100000000000001f) & 0xFFFF) >> 8) & 0xFF) << 0);
            stFrame.abData[6] |= (uint8_t)(((((uint32_t)(VOpenCell109 / 0.000100000000000001f) & 0xFFFF) >> 0) & 0xFF) << 0);
            break;
        case 109:
            stFrame.abData[1] |= (uint8_t)(((((uint32_t)(VCell110 / 0.000100000000000001f) & 0xFFFF) >> 8) & 0xFF) << 0);
            stFrame.abData[2] |= (uint8_t)(((((uint32_t)(VCell110 / 0.000100000000000001f) & 0xFFFF) >> 0) & 0xFF) << 0);
            stFrame.abData[3] |= (uint8_t)(((((uint32_t)(RCell110 / 0.01f) & 0x7FFF) >> 8) & 0x7F) << 0);
            stFrame.abData[4] |= (uint8_t)(((((uint32_t)(RCell110 / 0.01f) & 0x7FFF) >> 0) & 0xFF) << 0);
            stFrame.abData[3] |= (uint8_t)(((((uint32_t)BBalancingCell110 & 0x1) >> 0) & 0x1) << 0);
            stFrame.abData[5] |= (uint8_t)(((((uint32_t)(VOpenCell110 / 0.000100000000000001f) & 0xFFFF) >> 8) & 0xFF) << 0);
            stFrame.abData[6] |= (uint8_t)(((((uint32_t)(VOpenCell110 / 0.000100000000000001f) & 0xFFFF) >> 0) & 0xFF) << 0);
            break;
        case 110:
            stFrame.abData[1] |= (uint8_t)(((((uint32_t)(VCell111 / 0.000100000000000001f) & 0xFFFF) >> 8) & 0xFF) << 0);
            stFrame.abData[2] |= (uint8_t)(((((uint32_t)(VCell111 / 0.000100000000000001f) & 0xFFFF) >> 0) & 0xFF) << 0);
            stFrame.abData[3] |= (uint8_t)(((((uint32_t)(RCell111 / 0.01f) & 0x7FFF) >> 8) & 0x7F) << 0);
            stFrame.abData[4] |= (uint8_t)(((((uint32_t)(RCell111 / 0.01f) & 0x7FFF) >> 0) & 0xFF) << 0);
            stFrame.abData[3] |= (uint8_t)(((((uint32_t)BBalancingCell111 & 0x1) >> 0) & 0x1) << 0);
            stFrame.abData[5] |= (uint8_t)(((((uint32_t)(VOpenCell111 / 0.000100000000000001f) & 0xFFFF) >> 8) & 0xFF) << 0);
            stFrame.abData[6] |= (uint8_t)(((((uint32_t)(VOpenCell111 / 0.000100000000000001f) & 0xFFFF) >> 0) & 0xFF) << 0);
            break;
        case 111:
            stFrame.abData[1] |= (uint8_t)(((((uint32_t)(VCell112 / 0.000100000000000001f) & 0xFFFF) >> 8) & 0xFF) << 0);
            stFrame.abData[2] |= (uint8_t)(((((uint32_t)(VCell112 / 0.000100000000000001f) & 0xFFFF) >> 0) & 0xFF) << 0);
            stFrame.abData[3] |= (uint8_t)(((((uint32_t)(RCell112 / 0.01f) & 0x7FFF) >> 8) & 0x7F) << 0);
            stFrame.abData[4] |= (uint8_t)(((((uint32_t)(RCell112 / 0.01f) & 0x7FFF) >> 0) & 0xFF) << 0);
            stFrame.abData[3] |= (uint8_t)(((((uint32_t)BBalancingCell112 & 0x1) >> 0) & 0x1) << 0);
            stFrame.abData[5] |= (uint8_t)(((((uint32_t)(VOpenCell112 / 0.000100000000000001f) & 0xFFFF) >> 8) & 0xFF) << 0);
            stFrame.abData[6] |= (uint8_t)(((((uint32_t)(VOpenCell112 / 0.000100000000000001f) & 0xFFFF) >> 0) & 0xFF) << 0);
            break;
        default:
            break;
    }

    return CAN_transmit(stCANBus, &stFrame);
}

esp_err_t IMDData(CAN_frame_t stFrame)
{
    /*
    *===========================================================================
    *   IMDData
    *   Message: IMDData (0x40)
    *   Description: Bender IMD Measurements
    *   Takes:   stFrame: The CAN frame to decode
    *   Returns: ESP_OK if successful, error code if not.
    *   Autogenerated by decodeCAN.py
    */
    if (stFrame.byDLC != 8) return ESP_ERR_INVALID_SIZE;
    if (stFrame.dwID != 0x40) return ESP_ERR_INVALID_ARG;

    /* Standard Signals */
    BIMDOff = (uint8_t)(((stFrame.abData[0] >> 7) & 0x1));
    BIMDUndervoltage = (uint8_t)(((stFrame.abData[0] >> 6) & 0x1));
    BIMDStarting = (uint8_t)(((stFrame.abData[0] >> 5) & 0x1));
    BIMDSSTGood = (uint8_t)(((stFrame.abData[0] >> 4) & 0x1));
    BIMDDeviceError = (uint8_t)(((stFrame.abData[0] >> 3) & 0x1));
    BIMDGroundConnectionFault = (uint8_t)(((stFrame.abData[0] >> 2) & 0x1));
    BIMDInvalidState = (uint8_t)(((stFrame.abData[0] >> 1) & 0x1));
    RIsolation = (float)((((uint16_t)((stFrame.abData[0] >> 0) & 0x1)) << 15) | (((uint16_t)((stFrame.abData[1] >> 0) & 0xFF)) << 7) | ((uint16_t)((stFrame.abData[2] >> 1) & 0x7F))) * 200.0f;
    return ESP_OK;
}

esp_err_t IMDDataTx(twai_node_handle_t stCANBus)
{
    /*
    *===========================================================================
    *   IMDDataTx
    *   Encodes and Transmits Message: IMDData (0x40)
    *   Uses global signal variables.
    *   Takes:   stCANBus: Handle to CAN bus to transmit on
    *   Returns: ESP_OK if successful, error code if not.
    */
    CAN_frame_t stFrame;
    stFrame.dwID = 0x40;
    stFrame.byDLC = 8;
    memset(stFrame.abData, 0, 8);

    stFrame.abData[0] |= (uint8_t)(((((uint32_t)BIMDOff & 0x1) >> 0) & 0x1) << 7);
    stFrame.abData[0] |= (uint8_t)(((((uint32_t)BIMDUndervoltage & 0x1) >> 0) & 0x1) << 6);
    stFrame.abData[0] |= (uint8_t)(((((uint32_t)BIMDStarting & 0x1) >> 0) & 0x1) << 5);
    stFrame.abData[0] |= (uint8_t)(((((uint32_t)BIMDSSTGood & 0x1) >> 0) & 0x1) << 4);
    stFrame.abData[0] |= (uint8_t)(((((uint32_t)BIMDDeviceError & 0x1) >> 0) & 0x1) << 3);
    stFrame.abData[0] |= (uint8_t)(((((uint32_t)BIMDGroundConnectionFault & 0x1) >> 0) & 0x1) << 2);
    stFrame.abData[0] |= (uint8_t)(((((uint32_t)BIMDInvalidState & 0x1) >> 0) & 0x1) << 1);
    stFrame.abData[0] |= (uint8_t)(((((uint32_t)(RIsolation / 200.0f) & 0xFFFF) >> 15) & 0x1) << 0);
    stFrame.abData[1] |= (uint8_t)(((((uint32_t)(RIsolation / 200.0f) & 0xFFFF) >> 7) & 0xFF) << 0);
    stFrame.abData[2] |= (uint8_t)(((((uint32_t)(RIsolation / 200.0f) & 0xFFFF) >> 0) & 0x7F) << 1);

    return CAN_transmit(stCANBus, &stFrame);
}

esp_err_t SetBrakeCurrent(CAN_frame_t stFrame)
{
    /*
    *===========================================================================
    *   SetBrakeCurrent
    *   Message: SetBrakeCurrent (0x44)
    *   Description: Node ID: 4 (decimal)
    *   Takes:   stFrame: The CAN frame to decode
    *   Returns: ESP_OK if successful, error code if not.
    *   Autogenerated by decodeCAN.py
    */
    if (stFrame.byDLC != 8) return ESP_ERR_INVALID_SIZE;
    if (stFrame.dwID != 0x44) return ESP_ERR_INVALID_ARG;

    /* Standard Signals */
    CMD_TargetBrakeCurrent = (float)((((uint16_t)((stFrame.abData[0] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[1] >> 0) & 0xFF))) * 0.1f;
    return ESP_OK;
}

esp_err_t SetBrakeCurrentTx(twai_node_handle_t stCANBus)
{
    /*
    *===========================================================================
    *   SetBrakeCurrentTx
    *   Encodes and Transmits Message: SetBrakeCurrent (0x44)
    *   Uses global signal variables.
    *   Takes:   stCANBus: Handle to CAN bus to transmit on
    *   Returns: ESP_OK if successful, error code if not.
    */
    CAN_frame_t stFrame;
    stFrame.dwID = 0x44;
    stFrame.byDLC = 8;
    memset(stFrame.abData, 0, 8);

    stFrame.abData[0] |= (uint8_t)(((((uint32_t)(CMD_TargetBrakeCurrent / 0.1f) & 0xFFFF) >> 8) & 0xFF) << 0);
    stFrame.abData[1] |= (uint8_t)(((((uint32_t)(CMD_TargetBrakeCurrent / 0.1f) & 0xFFFF) >> 0) & 0xFF) << 0);

    return CAN_transmit(stCANBus, &stFrame);
}

esp_err_t SetERPM(CAN_frame_t stFrame)
{
    /*
    *===========================================================================
    *   SetERPM
    *   Message: SetERPM (0x64)
    *   Description: Node ID: 4 (decimal)
    *   Takes:   stFrame: The CAN frame to decode
    *   Returns: ESP_OK if successful, error code if not.
    *   Autogenerated by decodeCAN.py
    */
    if (stFrame.byDLC != 8) return ESP_ERR_INVALID_SIZE;
    if (stFrame.dwID != 0x64) return ESP_ERR_INVALID_ARG;

    /* Standard Signals */
    CMD_TargetSpeed = (int32_t)((((uint32_t)((stFrame.abData[0] >> 0) & 0xFF)) << 24) | (((uint32_t)((stFrame.abData[1] >> 0) & 0xFF)) << 16) | (((uint32_t)((stFrame.abData[2] >> 0) & 0xFF)) << 8) | ((uint32_t)((stFrame.abData[3] >> 0) & 0xFF)));
    return ESP_OK;
}

esp_err_t SetERPMTx(twai_node_handle_t stCANBus)
{
    /*
    *===========================================================================
    *   SetERPMTx
    *   Encodes and Transmits Message: SetERPM (0x64)
    *   Uses global signal variables.
    *   Takes:   stCANBus: Handle to CAN bus to transmit on
    *   Returns: ESP_OK if successful, error code if not.
    */
    CAN_frame_t stFrame;
    stFrame.dwID = 0x64;
    stFrame.byDLC = 8;
    memset(stFrame.abData, 0, 8);

    stFrame.abData[0] |= (uint8_t)(((((uint32_t)CMD_TargetSpeed & 0xFFFFFFFF) >> 24) & 0xFF) << 0);
    stFrame.abData[1] |= (uint8_t)(((((uint32_t)CMD_TargetSpeed & 0xFFFFFFFF) >> 16) & 0xFF) << 0);
    stFrame.abData[2] |= (uint8_t)(((((uint32_t)CMD_TargetSpeed & 0xFFFFFFFF) >> 8) & 0xFF) << 0);
    stFrame.abData[3] |= (uint8_t)(((((uint32_t)CMD_TargetSpeed & 0xFFFFFFFF) >> 0) & 0xFF) << 0);

    return CAN_transmit(stCANBus, &stFrame);
}

esp_err_t StatusAPPSSensor(CAN_frame_t stFrame)
{
    /*
    *===========================================================================
    *   StatusAPPSSensor
    *   Message: StatusAPPSSensor (0x81)
    *   Description: APPS Sensor Status
    *   Takes:   stFrame: The CAN frame to decode
    *   Returns: ESP_OK if successful, error code if not.
    *   Autogenerated by decodeCAN.py
    */
    if (stFrame.byDLC != 8) return ESP_ERR_INVALID_SIZE;
    if (stFrame.dwID != 0x81) return ESP_ERR_INVALID_ARG;

    /* Standard Signals */
    rAPPs1 = (int8_t)(((stFrame.abData[0] >> 0) & 0xFF));
    rAPPs2 = (int8_t)(((stFrame.abData[1] >> 0) & 0xFF));
    rAPPsFinal = (int8_t)(((stFrame.abData[2] >> 0) & 0xFF));
    BThrottleOK = (uint8_t)(((stFrame.abData[3] >> 3) & 0x1));
    BAPPS1Fail = (uint8_t)(((stFrame.abData[3] >> 2) & 0x1));
    BAPPS2Fail = (uint8_t)(((stFrame.abData[3] >> 1) & 0x1));
    BAPPSDrift = (uint8_t)(((stFrame.abData[3] >> 0) & 0x1));
    return ESP_OK;
}

esp_err_t StatusAPPSSensorTx(twai_node_handle_t stCANBus)
{
    /*
    *===========================================================================
    *   StatusAPPSSensorTx
    *   Encodes and Transmits Message: StatusAPPSSensor (0x81)
    *   Uses global signal variables.
    *   Takes:   stCANBus: Handle to CAN bus to transmit on
    *   Returns: ESP_OK if successful, error code if not.
    */
    CAN_frame_t stFrame;
    stFrame.dwID = 0x81;
    stFrame.byDLC = 8;
    memset(stFrame.abData, 0, 8);

    stFrame.abData[0] |= (uint8_t)(((((uint32_t)rAPPs1 & 0xFF) >> 0) & 0xFF) << 0);
    stFrame.abData[1] |= (uint8_t)(((((uint32_t)rAPPs2 & 0xFF) >> 0) & 0xFF) << 0);
    stFrame.abData[2] |= (uint8_t)(((((uint32_t)rAPPsFinal & 0xFF) >> 0) & 0xFF) << 0);
    stFrame.abData[3] |= (uint8_t)(((((uint32_t)BThrottleOK & 0x1) >> 0) & 0x1) << 3);
    stFrame.abData[3] |= (uint8_t)(((((uint32_t)BAPPS1Fail & 0x1) >> 0) & 0x1) << 2);
    stFrame.abData[3] |= (uint8_t)(((((uint32_t)BAPPS2Fail & 0x1) >> 0) & 0x1) << 1);
    stFrame.abData[3] |= (uint8_t)(((((uint32_t)BAPPSDrift & 0x1) >> 0) & 0x1) << 0);

    return CAN_transmit(stCANBus, &stFrame);
}

esp_err_t SetPosition(CAN_frame_t stFrame)
{
    /*
    *===========================================================================
    *   SetPosition
    *   Message: SetPosition (0x84)
    *   Description: Node ID: 4 (decimal)
    *   Takes:   stFrame: The CAN frame to decode
    *   Returns: ESP_OK if successful, error code if not.
    *   Autogenerated by decodeCAN.py
    */
    if (stFrame.byDLC != 8) return ESP_ERR_INVALID_SIZE;
    if (stFrame.dwID != 0x84) return ESP_ERR_INVALID_ARG;

    /* Standard Signals */
    CMD_TargetPosition = (float)((((uint16_t)((stFrame.abData[0] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[1] >> 0) & 0xFF))) * 0.1f;
    return ESP_OK;
}

esp_err_t SetPositionTx(twai_node_handle_t stCANBus)
{
    /*
    *===========================================================================
    *   SetPositionTx
    *   Encodes and Transmits Message: SetPosition (0x84)
    *   Uses global signal variables.
    *   Takes:   stCANBus: Handle to CAN bus to transmit on
    *   Returns: ESP_OK if successful, error code if not.
    */
    CAN_frame_t stFrame;
    stFrame.dwID = 0x84;
    stFrame.byDLC = 8;
    memset(stFrame.abData, 0, 8);

    stFrame.abData[0] |= (uint8_t)(((((uint32_t)(CMD_TargetPosition / 0.1f) & 0xFFFF) >> 8) & 0xFF) << 0);
    stFrame.abData[1] |= (uint8_t)(((((uint32_t)(CMD_TargetPosition / 0.1f) & 0xFFFF) >> 0) & 0xFF) << 0);

    return CAN_transmit(stCANBus, &stFrame);
}

esp_err_t DynoPressuresRaw(CAN_frame_t stFrame)
{
    /*
    *===========================================================================
    *   DynoPressuresRaw
    *   Message: DynoPressuresRaw (0x90)
    *   Description: Sensor data from the data. Raw input voltage.
    *   Takes:   stFrame: The CAN frame to decode
    *   Returns: ESP_OK if successful, error code if not.
    *   Autogenerated by decodeCAN.py
    */
    if (stFrame.byDLC != 8) return ESP_ERR_INVALID_SIZE;
    if (stFrame.dwID != 0x90) return ESP_ERR_INVALID_ARG;

    /* Standard Signals */
    VDynoPressure1Raw = (float)((((uint16_t)((stFrame.abData[0] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[1] >> 0) & 0xFF))) * 0.0001f;
    VDynoPressure2Raw = (float)((((uint16_t)((stFrame.abData[2] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[3] >> 0) & 0xFF))) * 0.0001f;
    VDynoPressure3Raw = (float)((((uint16_t)((stFrame.abData[4] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[5] >> 0) & 0xFF))) * 0.0001f;
    VDynoCoolantFlowRaw = (float)((((uint16_t)((stFrame.abData[6] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[7] >> 0) & 0xFF))) * 0.0001f;
    return ESP_OK;
}

esp_err_t DynoPressuresRawTx(twai_node_handle_t stCANBus)
{
    /*
    *===========================================================================
    *   DynoPressuresRawTx
    *   Encodes and Transmits Message: DynoPressuresRaw (0x90)
    *   Uses global signal variables.
    *   Takes:   stCANBus: Handle to CAN bus to transmit on
    *   Returns: ESP_OK if successful, error code if not.
    */
    CAN_frame_t stFrame;
    stFrame.dwID = 0x90;
    stFrame.byDLC = 8;
    memset(stFrame.abData, 0, 8);

    stFrame.abData[0] |= (uint8_t)(((((uint32_t)(VDynoPressure1Raw / 0.0001f) & 0xFFFF) >> 8) & 0xFF) << 0);
    stFrame.abData[1] |= (uint8_t)(((((uint32_t)(VDynoPressure1Raw / 0.0001f) & 0xFFFF) >> 0) & 0xFF) << 0);
    stFrame.abData[2] |= (uint8_t)(((((uint32_t)(VDynoPressure2Raw / 0.0001f) & 0xFFFF) >> 8) & 0xFF) << 0);
    stFrame.abData[3] |= (uint8_t)(((((uint32_t)(VDynoPressure2Raw / 0.0001f) & 0xFFFF) >> 0) & 0xFF) << 0);
    stFrame.abData[4] |= (uint8_t)(((((uint32_t)(VDynoPressure3Raw / 0.0001f) & 0xFFFF) >> 8) & 0xFF) << 0);
    stFrame.abData[5] |= (uint8_t)(((((uint32_t)(VDynoPressure3Raw / 0.0001f) & 0xFFFF) >> 0) & 0xFF) << 0);
    stFrame.abData[6] |= (uint8_t)(((((uint32_t)(VDynoCoolantFlowRaw / 0.0001f) & 0xFFFF) >> 8) & 0xFF) << 0);
    stFrame.abData[7] |= (uint8_t)(((((uint32_t)(VDynoCoolantFlowRaw / 0.0001f) & 0xFFFF) >> 0) & 0xFF) << 0);

    return CAN_transmit(stCANBus, &stFrame);
}

esp_err_t DynoTempsRaw(CAN_frame_t stFrame)
{
    /*
    *===========================================================================
    *   DynoTempsRaw
    *   Message: DynoTempsRaw (0x91)
    *   Description: Sensor data from the data. Raw input voltage.
    *   Takes:   stFrame: The CAN frame to decode
    *   Returns: ESP_OK if successful, error code if not.
    *   Autogenerated by decodeCAN.py
    */
    if (stFrame.byDLC != 8) return ESP_ERR_INVALID_SIZE;
    if (stFrame.dwID != 0x91) return ESP_ERR_INVALID_ARG;

    /* Standard Signals */
    VDynoTemp1Raw = (float)((((uint16_t)((stFrame.abData[0] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[1] >> 0) & 0xFF))) * 0.0001f;
    VDynoTemp2Raw = (float)((((uint16_t)((stFrame.abData[2] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[3] >> 0) & 0xFF))) * 0.0001f;
    VDynoTemp3Raw = (float)((((uint16_t)((stFrame.abData[4] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[5] >> 0) & 0xFF))) * 0.0001f;
    return ESP_OK;
}

esp_err_t DynoTempsRawTx(twai_node_handle_t stCANBus)
{
    /*
    *===========================================================================
    *   DynoTempsRawTx
    *   Encodes and Transmits Message: DynoTempsRaw (0x91)
    *   Uses global signal variables.
    *   Takes:   stCANBus: Handle to CAN bus to transmit on
    *   Returns: ESP_OK if successful, error code if not.
    */
    CAN_frame_t stFrame;
    stFrame.dwID = 0x91;
    stFrame.byDLC = 8;
    memset(stFrame.abData, 0, 8);

    stFrame.abData[0] |= (uint8_t)(((((uint32_t)(VDynoTemp1Raw / 0.0001f) & 0xFFFF) >> 8) & 0xFF) << 0);
    stFrame.abData[1] |= (uint8_t)(((((uint32_t)(VDynoTemp1Raw / 0.0001f) & 0xFFFF) >> 0) & 0xFF) << 0);
    stFrame.abData[2] |= (uint8_t)(((((uint32_t)(VDynoTemp2Raw / 0.0001f) & 0xFFFF) >> 8) & 0xFF) << 0);
    stFrame.abData[3] |= (uint8_t)(((((uint32_t)(VDynoTemp2Raw / 0.0001f) & 0xFFFF) >> 0) & 0xFF) << 0);
    stFrame.abData[4] |= (uint8_t)(((((uint32_t)(VDynoTemp3Raw / 0.0001f) & 0xFFFF) >> 8) & 0xFF) << 0);
    stFrame.abData[5] |= (uint8_t)(((((uint32_t)(VDynoTemp3Raw / 0.0001f) & 0xFFFF) >> 0) & 0xFF) << 0);

    return CAN_transmit(stCANBus, &stFrame);
}

esp_err_t DynoPressures(CAN_frame_t stFrame)
{
    /*
    *===========================================================================
    *   DynoPressures
    *   Message: DynoPressures (0x92)
    *   Description: Sensor data from the dyno.
    *   Takes:   stFrame: The CAN frame to decode
    *   Returns: ESP_OK if successful, error code if not.
    *   Autogenerated by decodeCAN.py
    */
    if (stFrame.byDLC != 8) return ESP_ERR_INVALID_SIZE;
    if (stFrame.dwID != 0x92) return ESP_ERR_INVALID_ARG;

    /* Standard Signals */
    pDynoPressure1 = (float)((((uint16_t)((stFrame.abData[0] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[1] >> 0) & 0xFF))) * 0.0005f + -2000.0f;
    pDynoPressure2 = (float)((((uint16_t)((stFrame.abData[2] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[3] >> 0) & 0xFF))) * 0.0005f + -2000.0f;
    pDynoPressure3 = (float)((((uint16_t)((stFrame.abData[4] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[5] >> 0) & 0xFF))) * 0.0005f + -2000.0f;
    VDynoCoolantFlow = (float)((((uint16_t)((stFrame.abData[6] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[7] >> 0) & 0xFF))) * 1e-05f;
    return ESP_OK;
}

esp_err_t DynoPressuresTx(twai_node_handle_t stCANBus)
{
    /*
    *===========================================================================
    *   DynoPressuresTx
    *   Encodes and Transmits Message: DynoPressures (0x92)
    *   Uses global signal variables.
    *   Takes:   stCANBus: Handle to CAN bus to transmit on
    *   Returns: ESP_OK if successful, error code if not.
    */
    CAN_frame_t stFrame;
    stFrame.dwID = 0x92;
    stFrame.byDLC = 8;
    memset(stFrame.abData, 0, 8);

    stFrame.abData[0] |= (uint8_t)(((((uint32_t)((pDynoPressure1 - -2000.0f) / 0.0005f) & 0xFFFF) >> 8) & 0xFF) << 0);
    stFrame.abData[1] |= (uint8_t)(((((uint32_t)((pDynoPressure1 - -2000.0f) / 0.0005f) & 0xFFFF) >> 0) & 0xFF) << 0);
    stFrame.abData[2] |= (uint8_t)(((((uint32_t)((pDynoPressure2 - -2000.0f) / 0.0005f) & 0xFFFF) >> 8) & 0xFF) << 0);
    stFrame.abData[3] |= (uint8_t)(((((uint32_t)((pDynoPressure2 - -2000.0f) / 0.0005f) & 0xFFFF) >> 0) & 0xFF) << 0);
    stFrame.abData[4] |= (uint8_t)(((((uint32_t)((pDynoPressure3 - -2000.0f) / 0.0005f) & 0xFFFF) >> 8) & 0xFF) << 0);
    stFrame.abData[5] |= (uint8_t)(((((uint32_t)((pDynoPressure3 - -2000.0f) / 0.0005f) & 0xFFFF) >> 0) & 0xFF) << 0);
    stFrame.abData[6] |= (uint8_t)(((((uint32_t)(VDynoCoolantFlow / 1e-05f) & 0xFFFF) >> 8) & 0xFF) << 0);
    stFrame.abData[7] |= (uint8_t)(((((uint32_t)(VDynoCoolantFlow / 1e-05f) & 0xFFFF) >> 0) & 0xFF) << 0);

    return CAN_transmit(stCANBus, &stFrame);
}

esp_err_t DynoTemps(CAN_frame_t stFrame)
{
    /*
    *===========================================================================
    *   DynoTemps
    *   Message: DynoTemps (0x93)
    *   Description: Sensor data from the dyno.
    *   Takes:   stFrame: The CAN frame to decode
    *   Returns: ESP_OK if successful, error code if not.
    *   Autogenerated by decodeCAN.py
    */
    if (stFrame.byDLC != 8) return ESP_ERR_INVALID_SIZE;
    if (stFrame.dwID != 0x93) return ESP_ERR_INVALID_ARG;

    /* Standard Signals */
    TDynoTemp1 = (float)((((uint16_t)((stFrame.abData[0] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[1] >> 0) & 0xFF))) * 0.005f + -10000.0f;
    TDynoTemp2 = (float)((((uint16_t)((stFrame.abData[2] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[3] >> 0) & 0xFF))) * 0.005f + -10000.0f;
    TDynoTemp3 = (float)((((uint16_t)((stFrame.abData[4] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[5] >> 0) & 0xFF))) * 0.005f + -10000.0f;
    return ESP_OK;
}

esp_err_t DynoTempsTx(twai_node_handle_t stCANBus)
{
    /*
    *===========================================================================
    *   DynoTempsTx
    *   Encodes and Transmits Message: DynoTemps (0x93)
    *   Uses global signal variables.
    *   Takes:   stCANBus: Handle to CAN bus to transmit on
    *   Returns: ESP_OK if successful, error code if not.
    */
    CAN_frame_t stFrame;
    stFrame.dwID = 0x93;
    stFrame.byDLC = 8;
    memset(stFrame.abData, 0, 8);

    stFrame.abData[0] |= (uint8_t)(((((uint32_t)((TDynoTemp1 - -10000.0f) / 0.005f) & 0xFFFF) >> 8) & 0xFF) << 0);
    stFrame.abData[1] |= (uint8_t)(((((uint32_t)((TDynoTemp1 - -10000.0f) / 0.005f) & 0xFFFF) >> 0) & 0xFF) << 0);
    stFrame.abData[2] |= (uint8_t)(((((uint32_t)((TDynoTemp2 - -10000.0f) / 0.005f) & 0xFFFF) >> 8) & 0xFF) << 0);
    stFrame.abData[3] |= (uint8_t)(((((uint32_t)((TDynoTemp2 - -10000.0f) / 0.005f) & 0xFFFF) >> 0) & 0xFF) << 0);
    stFrame.abData[4] |= (uint8_t)(((((uint32_t)((TDynoTemp3 - -10000.0f) / 0.005f) & 0xFFFF) >> 8) & 0xFF) << 0);
    stFrame.abData[5] |= (uint8_t)(((((uint32_t)((TDynoTemp3 - -10000.0f) / 0.005f) & 0xFFFF) >> 0) & 0xFF) << 0);

    return CAN_transmit(stCANBus, &stFrame);
}

esp_err_t SetRelCurrent(CAN_frame_t stFrame)
{
    /*
    *===========================================================================
    *   SetRelCurrent
    *   Message: SetRelCurrent (0xA4)
    *   Description: Node ID: 4 (decimal)
    *   Takes:   stFrame: The CAN frame to decode
    *   Returns: ESP_OK if successful, error code if not.
    *   Autogenerated by decodeCAN.py
    */
    if (stFrame.byDLC != 8) return ESP_ERR_INVALID_SIZE;
    if (stFrame.dwID != 0xA4) return ESP_ERR_INVALID_ARG;

    /* Standard Signals */
    CMD_TargetRelativeCurrent = (float)((((uint16_t)((stFrame.abData[0] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[1] >> 0) & 0xFF))) * 0.1f;
    return ESP_OK;
}

esp_err_t SetRelCurrentTx(twai_node_handle_t stCANBus)
{
    /*
    *===========================================================================
    *   SetRelCurrentTx
    *   Encodes and Transmits Message: SetRelCurrent (0xA4)
    *   Uses global signal variables.
    *   Takes:   stCANBus: Handle to CAN bus to transmit on
    *   Returns: ESP_OK if successful, error code if not.
    */
    CAN_frame_t stFrame;
    stFrame.dwID = 0xA4;
    stFrame.byDLC = 8;
    memset(stFrame.abData, 0, 8);

    stFrame.abData[0] |= (uint8_t)(((((uint32_t)(CMD_TargetRelativeCurrent / 0.1f) & 0xFFFF) >> 8) & 0xFF) << 0);
    stFrame.abData[1] |= (uint8_t)(((((uint32_t)(CMD_TargetRelativeCurrent / 0.1f) & 0xFFFF) >> 0) & 0xFF) << 0);

    return CAN_transmit(stCANBus, &stFrame);
}

esp_err_t SetRelBrakeCurrent(CAN_frame_t stFrame)
{
    /*
    *===========================================================================
    *   SetRelBrakeCurrent
    *   Message: SetRelBrakeCurrent (0xC4)
    *   Description: Node ID: 4 (decimal)
    *   Takes:   stFrame: The CAN frame to decode
    *   Returns: ESP_OK if successful, error code if not.
    *   Autogenerated by decodeCAN.py
    */
    if (stFrame.byDLC != 8) return ESP_ERR_INVALID_SIZE;
    if (stFrame.dwID != 0xC4) return ESP_ERR_INVALID_ARG;

    /* Standard Signals */
    CMD_TargeRelativeBrakeCurrent = (float)((((uint16_t)((stFrame.abData[0] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[1] >> 0) & 0xFF))) * 0.1f;
    return ESP_OK;
}

esp_err_t SetRelBrakeCurrentTx(twai_node_handle_t stCANBus)
{
    /*
    *===========================================================================
    *   SetRelBrakeCurrentTx
    *   Encodes and Transmits Message: SetRelBrakeCurrent (0xC4)
    *   Uses global signal variables.
    *   Takes:   stCANBus: Handle to CAN bus to transmit on
    *   Returns: ESP_OK if successful, error code if not.
    */
    CAN_frame_t stFrame;
    stFrame.dwID = 0xC4;
    stFrame.byDLC = 8;
    memset(stFrame.abData, 0, 8);

    stFrame.abData[0] |= (uint8_t)(((((uint32_t)(CMD_TargeRelativeBrakeCurrent / 0.1f) & 0xFFFF) >> 8) & 0xFF) << 0);
    stFrame.abData[1] |= (uint8_t)(((((uint32_t)(CMD_TargeRelativeBrakeCurrent / 0.1f) & 0xFFFF) >> 0) & 0xFF) << 0);

    return CAN_transmit(stCANBus, &stFrame);
}

esp_err_t SetDigOutput(CAN_frame_t stFrame)
{
    /*
    *===========================================================================
    *   SetDigOutput
    *   Message: SetDigOutput (0xE4)
    *   Description: Node ID: 4 (decimal)
    *   Takes:   stFrame: The CAN frame to decode
    *   Returns: ESP_OK if successful, error code if not.
    *   Autogenerated by decodeCAN.py
    */
    if (stFrame.byDLC != 8) return ESP_ERR_INVALID_SIZE;
    if (stFrame.dwID != 0xE4) return ESP_ERR_INVALID_ARG;

    /* Standard Signals */
    CMD_SetDigOutput4 = (uint8_t)(((stFrame.abData[0] >> 3) & 0x1));
    CMD_SetDigOutput3 = (uint8_t)(((stFrame.abData[0] >> 2) & 0x1));
    CMD_SetDigOutput2 = (uint8_t)(((stFrame.abData[0] >> 1) & 0x1));
    CMD_SetDigOutput1 = (uint8_t)(((stFrame.abData[0] >> 0) & 0x1));
    return ESP_OK;
}

esp_err_t SetDigOutputTx(twai_node_handle_t stCANBus)
{
    /*
    *===========================================================================
    *   SetDigOutputTx
    *   Encodes and Transmits Message: SetDigOutput (0xE4)
    *   Uses global signal variables.
    *   Takes:   stCANBus: Handle to CAN bus to transmit on
    *   Returns: ESP_OK if successful, error code if not.
    */
    CAN_frame_t stFrame;
    stFrame.dwID = 0xE4;
    stFrame.byDLC = 8;
    memset(stFrame.abData, 0, 8);

    stFrame.abData[0] |= (uint8_t)(((((uint32_t)CMD_SetDigOutput4 & 0x1) >> 0) & 0x1) << 3);
    stFrame.abData[0] |= (uint8_t)(((((uint32_t)CMD_SetDigOutput3 & 0x1) >> 0) & 0x1) << 2);
    stFrame.abData[0] |= (uint8_t)(((((uint32_t)CMD_SetDigOutput2 & 0x1) >> 0) & 0x1) << 1);
    stFrame.abData[0] |= (uint8_t)(((((uint32_t)CMD_SetDigOutput1 & 0x1) >> 0) & 0x1) << 0);

    return CAN_transmit(stCANBus, &stFrame);
}

esp_err_t SetMaxAcCurrent(CAN_frame_t stFrame)
{
    /*
    *===========================================================================
    *   SetMaxAcCurrent
    *   Message: SetMaxAcCurrent (0x104)
    *   Description: Node ID: 4 (decimal)
    *   Takes:   stFrame: The CAN frame to decode
    *   Returns: ESP_OK if successful, error code if not.
    *   Autogenerated by decodeCAN.py
    */
    if (stFrame.byDLC != 8) return ESP_ERR_INVALID_SIZE;
    if (stFrame.dwID != 0x104) return ESP_ERR_INVALID_ARG;

    /* Standard Signals */
    CMD_MaxAcCurrent = (float)((((uint16_t)((stFrame.abData[0] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[1] >> 0) & 0xFF))) * 0.1f;
    return ESP_OK;
}

esp_err_t SetMaxAcCurrentTx(twai_node_handle_t stCANBus)
{
    /*
    *===========================================================================
    *   SetMaxAcCurrentTx
    *   Encodes and Transmits Message: SetMaxAcCurrent (0x104)
    *   Uses global signal variables.
    *   Takes:   stCANBus: Handle to CAN bus to transmit on
    *   Returns: ESP_OK if successful, error code if not.
    */
    CAN_frame_t stFrame;
    stFrame.dwID = 0x104;
    stFrame.byDLC = 8;
    memset(stFrame.abData, 0, 8);

    stFrame.abData[0] |= (uint8_t)(((((uint32_t)(CMD_MaxAcCurrent / 0.1f) & 0xFFFF) >> 8) & 0xFF) << 0);
    stFrame.abData[1] |= (uint8_t)(((((uint32_t)(CMD_MaxAcCurrent / 0.1f) & 0xFFFF) >> 0) & 0xFF) << 0);

    return CAN_transmit(stCANBus, &stFrame);
}

esp_err_t SetMaxAcBrakeCurrent(CAN_frame_t stFrame)
{
    /*
    *===========================================================================
    *   SetMaxAcBrakeCurrent
    *   Message: SetMaxAcBrakeCurrent (0x124)
    *   Description: Node ID: 4 (decimal)
    *   Takes:   stFrame: The CAN frame to decode
    *   Returns: ESP_OK if successful, error code if not.
    *   Autogenerated by decodeCAN.py
    */
    if (stFrame.byDLC != 8) return ESP_ERR_INVALID_SIZE;
    if (stFrame.dwID != 0x124) return ESP_ERR_INVALID_ARG;

    /* Standard Signals */
    CMD_MaxAcBrakeCurrent = (float)((((uint16_t)((stFrame.abData[0] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[1] >> 0) & 0xFF))) * 0.1f;
    return ESP_OK;
}

esp_err_t SetMaxAcBrakeCurrentTx(twai_node_handle_t stCANBus)
{
    /*
    *===========================================================================
    *   SetMaxAcBrakeCurrentTx
    *   Encodes and Transmits Message: SetMaxAcBrakeCurrent (0x124)
    *   Uses global signal variables.
    *   Takes:   stCANBus: Handle to CAN bus to transmit on
    *   Returns: ESP_OK if successful, error code if not.
    */
    CAN_frame_t stFrame;
    stFrame.dwID = 0x124;
    stFrame.byDLC = 8;
    memset(stFrame.abData, 0, 8);

    stFrame.abData[0] |= (uint8_t)(((((uint32_t)(CMD_MaxAcBrakeCurrent / 0.1f) & 0xFFFF) >> 8) & 0xFF) << 0);
    stFrame.abData[1] |= (uint8_t)(((((uint32_t)(CMD_MaxAcBrakeCurrent / 0.1f) & 0xFFFF) >> 0) & 0xFF) << 0);

    return CAN_transmit(stCANBus, &stFrame);
}

esp_err_t SetMaxDcCurrent(CAN_frame_t stFrame)
{
    /*
    *===========================================================================
    *   SetMaxDcCurrent
    *   Message: SetMaxDcCurrent (0x144)
    *   Description: Node ID: 4 (decimal)
    *   Takes:   stFrame: The CAN frame to decode
    *   Returns: ESP_OK if successful, error code if not.
    *   Autogenerated by decodeCAN.py
    */
    if (stFrame.byDLC != 8) return ESP_ERR_INVALID_SIZE;
    if (stFrame.dwID != 0x144) return ESP_ERR_INVALID_ARG;

    /* Standard Signals */
    CMD_MaxDcCurrent = (float)((((uint16_t)((stFrame.abData[0] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[1] >> 0) & 0xFF))) * 0.1f;
    return ESP_OK;
}

esp_err_t SetMaxDcCurrentTx(twai_node_handle_t stCANBus)
{
    /*
    *===========================================================================
    *   SetMaxDcCurrentTx
    *   Encodes and Transmits Message: SetMaxDcCurrent (0x144)
    *   Uses global signal variables.
    *   Takes:   stCANBus: Handle to CAN bus to transmit on
    *   Returns: ESP_OK if successful, error code if not.
    */
    CAN_frame_t stFrame;
    stFrame.dwID = 0x144;
    stFrame.byDLC = 8;
    memset(stFrame.abData, 0, 8);

    stFrame.abData[0] |= (uint8_t)(((((uint32_t)(CMD_MaxDcCurrent / 0.1f) & 0xFFFF) >> 8) & 0xFF) << 0);
    stFrame.abData[1] |= (uint8_t)(((((uint32_t)(CMD_MaxDcCurrent / 0.1f) & 0xFFFF) >> 0) & 0xFF) << 0);

    return CAN_transmit(stCANBus, &stFrame);
}

esp_err_t SetMaxDcBrakeCurrent(CAN_frame_t stFrame)
{
    /*
    *===========================================================================
    *   SetMaxDcBrakeCurrent
    *   Message: SetMaxDcBrakeCurrent (0x164)
    *   Description: Node ID: 4 (decimal)
    *   Takes:   stFrame: The CAN frame to decode
    *   Returns: ESP_OK if successful, error code if not.
    *   Autogenerated by decodeCAN.py
    */
    if (stFrame.byDLC != 8) return ESP_ERR_INVALID_SIZE;
    if (stFrame.dwID != 0x164) return ESP_ERR_INVALID_ARG;

    /* Standard Signals */
    CMD_MaxDcBrakeCurrent = (float)((((uint16_t)((stFrame.abData[0] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[1] >> 0) & 0xFF))) * 0.1f;
    return ESP_OK;
}

esp_err_t SetMaxDcBrakeCurrentTx(twai_node_handle_t stCANBus)
{
    /*
    *===========================================================================
    *   SetMaxDcBrakeCurrentTx
    *   Encodes and Transmits Message: SetMaxDcBrakeCurrent (0x164)
    *   Uses global signal variables.
    *   Takes:   stCANBus: Handle to CAN bus to transmit on
    *   Returns: ESP_OK if successful, error code if not.
    */
    CAN_frame_t stFrame;
    stFrame.dwID = 0x164;
    stFrame.byDLC = 8;
    memset(stFrame.abData, 0, 8);

    stFrame.abData[0] |= (uint8_t)(((((uint32_t)(CMD_MaxDcBrakeCurrent / 0.1f) & 0xFFFF) >> 8) & 0xFF) << 0);
    stFrame.abData[1] |= (uint8_t)(((((uint32_t)(CMD_MaxDcBrakeCurrent / 0.1f) & 0xFFFF) >> 0) & 0xFF) << 0);

    return CAN_transmit(stCANBus, &stFrame);
}

esp_err_t SetDriveEnable(CAN_frame_t stFrame)
{
    /*
    *===========================================================================
    *   SetDriveEnable
    *   Message: SetDriveEnable (0x184)
    *   Description: Node ID: 4 (decimal)
    *   Takes:   stFrame: The CAN frame to decode
    *   Returns: ESP_OK if successful, error code if not.
    *   Autogenerated by decodeCAN.py
    */
    if (stFrame.byDLC != 8) return ESP_ERR_INVALID_SIZE;
    if (stFrame.dwID != 0x184) return ESP_ERR_INVALID_ARG;

    /* Standard Signals */
    CMD_DriveEnable = (uint8_t)(((stFrame.abData[0] >> 0) & 0xFF));
    return ESP_OK;
}

esp_err_t SetDriveEnableTx(twai_node_handle_t stCANBus)
{
    /*
    *===========================================================================
    *   SetDriveEnableTx
    *   Encodes and Transmits Message: SetDriveEnable (0x184)
    *   Uses global signal variables.
    *   Takes:   stCANBus: Handle to CAN bus to transmit on
    *   Returns: ESP_OK if successful, error code if not.
    */
    CAN_frame_t stFrame;
    stFrame.dwID = 0x184;
    stFrame.byDLC = 8;
    memset(stFrame.abData, 0, 8);

    stFrame.abData[0] |= (uint8_t)(((((uint32_t)CMD_DriveEnable & 0xFF) >> 0) & 0xFF) << 0);

    return CAN_transmit(stCANBus, &stFrame);
}

esp_err_t FRTireTemp1(CAN_frame_t stFrame)
{
    /*
    *===========================================================================
    *   FRTireTemp1
    *   Message: FRTireTemp1 (0x200)
    *   Description: Front Right Tire temperature sensor channels 1-4
    *   Takes:   stFrame: The CAN frame to decode
    *   Returns: ESP_OK if successful, error code if not.
    *   Autogenerated by decodeCAN.py
    */
    if (stFrame.byDLC != 8) return ESP_ERR_INVALID_SIZE;
    if (stFrame.dwID != 0x200) return ESP_ERR_INVALID_ARG;

    /* Standard Signals */
    TFRTireChannel01 = (float)((((uint16_t)((stFrame.abData[0] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[1] >> 0) & 0xFF))) * 0.1f + -100.0f;
    TFRTireChannel02 = (float)((((uint16_t)((stFrame.abData[2] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[3] >> 0) & 0xFF))) * 0.1f + -100.0f;
    TFRTireChannel03 = (float)((((uint16_t)((stFrame.abData[4] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[5] >> 0) & 0xFF))) * 0.1f + -100.0f;
    TFRTireChannel04 = (float)((((uint16_t)((stFrame.abData[6] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[7] >> 0) & 0xFF))) * 0.1f + -100.0f;
    return ESP_OK;
}

esp_err_t FRTireTemp1Tx(twai_node_handle_t stCANBus)
{
    /*
    *===========================================================================
    *   FRTireTemp1Tx
    *   Encodes and Transmits Message: FRTireTemp1 (0x200)
    *   Uses global signal variables.
    *   Takes:   stCANBus: Handle to CAN bus to transmit on
    *   Returns: ESP_OK if successful, error code if not.
    */
    CAN_frame_t stFrame;
    stFrame.dwID = 0x200;
    stFrame.byDLC = 8;
    memset(stFrame.abData, 0, 8);

    stFrame.abData[0] |= (uint8_t)(((((uint32_t)((TFRTireChannel01 - -100.0f) / 0.1f) & 0xFFFF) >> 8) & 0xFF) << 0);
    stFrame.abData[1] |= (uint8_t)(((((uint32_t)((TFRTireChannel01 - -100.0f) / 0.1f) & 0xFFFF) >> 0) & 0xFF) << 0);
    stFrame.abData[2] |= (uint8_t)(((((uint32_t)((TFRTireChannel02 - -100.0f) / 0.1f) & 0xFFFF) >> 8) & 0xFF) << 0);
    stFrame.abData[3] |= (uint8_t)(((((uint32_t)((TFRTireChannel02 - -100.0f) / 0.1f) & 0xFFFF) >> 0) & 0xFF) << 0);
    stFrame.abData[4] |= (uint8_t)(((((uint32_t)((TFRTireChannel03 - -100.0f) / 0.1f) & 0xFFFF) >> 8) & 0xFF) << 0);
    stFrame.abData[5] |= (uint8_t)(((((uint32_t)((TFRTireChannel03 - -100.0f) / 0.1f) & 0xFFFF) >> 0) & 0xFF) << 0);
    stFrame.abData[6] |= (uint8_t)(((((uint32_t)((TFRTireChannel04 - -100.0f) / 0.1f) & 0xFFFF) >> 8) & 0xFF) << 0);
    stFrame.abData[7] |= (uint8_t)(((((uint32_t)((TFRTireChannel04 - -100.0f) / 0.1f) & 0xFFFF) >> 0) & 0xFF) << 0);

    return CAN_transmit(stCANBus, &stFrame);
}

esp_err_t FRTireTemp2(CAN_frame_t stFrame)
{
    /*
    *===========================================================================
    *   FRTireTemp2
    *   Message: FRTireTemp2 (0x201)
    *   Description: Front Right Tire temperature sensor channels 5-8
    *   Takes:   stFrame: The CAN frame to decode
    *   Returns: ESP_OK if successful, error code if not.
    *   Autogenerated by decodeCAN.py
    */
    if (stFrame.byDLC != 8) return ESP_ERR_INVALID_SIZE;
    if (stFrame.dwID != 0x201) return ESP_ERR_INVALID_ARG;

    /* Standard Signals */
    TFRTireChannel05 = (float)((((uint16_t)((stFrame.abData[0] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[1] >> 0) & 0xFF))) * 0.1f + -100.0f;
    TFRTireChannel06 = (float)((((uint16_t)((stFrame.abData[2] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[3] >> 0) & 0xFF))) * 0.1f + -100.0f;
    TFRTireChannel07 = (float)((((uint16_t)((stFrame.abData[4] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[5] >> 0) & 0xFF))) * 0.1f + -100.0f;
    TFRTireChannel08 = (float)((((uint16_t)((stFrame.abData[6] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[7] >> 0) & 0xFF))) * 0.1f + -100.0f;
    return ESP_OK;
}

esp_err_t FRTireTemp2Tx(twai_node_handle_t stCANBus)
{
    /*
    *===========================================================================
    *   FRTireTemp2Tx
    *   Encodes and Transmits Message: FRTireTemp2 (0x201)
    *   Uses global signal variables.
    *   Takes:   stCANBus: Handle to CAN bus to transmit on
    *   Returns: ESP_OK if successful, error code if not.
    */
    CAN_frame_t stFrame;
    stFrame.dwID = 0x201;
    stFrame.byDLC = 8;
    memset(stFrame.abData, 0, 8);

    stFrame.abData[0] |= (uint8_t)(((((uint32_t)((TFRTireChannel05 - -100.0f) / 0.1f) & 0xFFFF) >> 8) & 0xFF) << 0);
    stFrame.abData[1] |= (uint8_t)(((((uint32_t)((TFRTireChannel05 - -100.0f) / 0.1f) & 0xFFFF) >> 0) & 0xFF) << 0);
    stFrame.abData[2] |= (uint8_t)(((((uint32_t)((TFRTireChannel06 - -100.0f) / 0.1f) & 0xFFFF) >> 8) & 0xFF) << 0);
    stFrame.abData[3] |= (uint8_t)(((((uint32_t)((TFRTireChannel06 - -100.0f) / 0.1f) & 0xFFFF) >> 0) & 0xFF) << 0);
    stFrame.abData[4] |= (uint8_t)(((((uint32_t)((TFRTireChannel07 - -100.0f) / 0.1f) & 0xFFFF) >> 8) & 0xFF) << 0);
    stFrame.abData[5] |= (uint8_t)(((((uint32_t)((TFRTireChannel07 - -100.0f) / 0.1f) & 0xFFFF) >> 0) & 0xFF) << 0);
    stFrame.abData[6] |= (uint8_t)(((((uint32_t)((TFRTireChannel08 - -100.0f) / 0.1f) & 0xFFFF) >> 8) & 0xFF) << 0);
    stFrame.abData[7] |= (uint8_t)(((((uint32_t)((TFRTireChannel08 - -100.0f) / 0.1f) & 0xFFFF) >> 0) & 0xFF) << 0);

    return CAN_transmit(stCANBus, &stFrame);
}

esp_err_t FRTireTemp3(CAN_frame_t stFrame)
{
    /*
    *===========================================================================
    *   FRTireTemp3
    *   Message: FRTireTemp3 (0x202)
    *   Description: Front Right Tire temperature sensor channels 9-12
    *   Takes:   stFrame: The CAN frame to decode
    *   Returns: ESP_OK if successful, error code if not.
    *   Autogenerated by decodeCAN.py
    */
    if (stFrame.byDLC != 8) return ESP_ERR_INVALID_SIZE;
    if (stFrame.dwID != 0x202) return ESP_ERR_INVALID_ARG;

    /* Standard Signals */
    TFRTireChannel09 = (float)((((uint16_t)((stFrame.abData[0] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[1] >> 0) & 0xFF))) * 0.1f + -100.0f;
    TFRTireChannel10 = (float)((((uint16_t)((stFrame.abData[2] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[3] >> 0) & 0xFF))) * 0.1f + -100.0f;
    TFRTireChannel11 = (float)((((uint16_t)((stFrame.abData[4] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[5] >> 0) & 0xFF))) * 0.1f + -100.0f;
    TFRTireChannel12 = (float)((((uint16_t)((stFrame.abData[6] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[7] >> 0) & 0xFF))) * 0.1f + -100.0f;
    return ESP_OK;
}

esp_err_t FRTireTemp3Tx(twai_node_handle_t stCANBus)
{
    /*
    *===========================================================================
    *   FRTireTemp3Tx
    *   Encodes and Transmits Message: FRTireTemp3 (0x202)
    *   Uses global signal variables.
    *   Takes:   stCANBus: Handle to CAN bus to transmit on
    *   Returns: ESP_OK if successful, error code if not.
    */
    CAN_frame_t stFrame;
    stFrame.dwID = 0x202;
    stFrame.byDLC = 8;
    memset(stFrame.abData, 0, 8);

    stFrame.abData[0] |= (uint8_t)(((((uint32_t)((TFRTireChannel09 - -100.0f) / 0.1f) & 0xFFFF) >> 8) & 0xFF) << 0);
    stFrame.abData[1] |= (uint8_t)(((((uint32_t)((TFRTireChannel09 - -100.0f) / 0.1f) & 0xFFFF) >> 0) & 0xFF) << 0);
    stFrame.abData[2] |= (uint8_t)(((((uint32_t)((TFRTireChannel10 - -100.0f) / 0.1f) & 0xFFFF) >> 8) & 0xFF) << 0);
    stFrame.abData[3] |= (uint8_t)(((((uint32_t)((TFRTireChannel10 - -100.0f) / 0.1f) & 0xFFFF) >> 0) & 0xFF) << 0);
    stFrame.abData[4] |= (uint8_t)(((((uint32_t)((TFRTireChannel11 - -100.0f) / 0.1f) & 0xFFFF) >> 8) & 0xFF) << 0);
    stFrame.abData[5] |= (uint8_t)(((((uint32_t)((TFRTireChannel11 - -100.0f) / 0.1f) & 0xFFFF) >> 0) & 0xFF) << 0);
    stFrame.abData[6] |= (uint8_t)(((((uint32_t)((TFRTireChannel12 - -100.0f) / 0.1f) & 0xFFFF) >> 8) & 0xFF) << 0);
    stFrame.abData[7] |= (uint8_t)(((((uint32_t)((TFRTireChannel12 - -100.0f) / 0.1f) & 0xFFFF) >> 0) & 0xFF) << 0);

    return CAN_transmit(stCANBus, &stFrame);
}

esp_err_t FRTireTemp4(CAN_frame_t stFrame)
{
    /*
    *===========================================================================
    *   FRTireTemp4
    *   Message: FRTireTemp4 (0x203)
    *   Description: Front Right Tire temperature sensor channels 13-16
    *   Takes:   stFrame: The CAN frame to decode
    *   Returns: ESP_OK if successful, error code if not.
    *   Autogenerated by decodeCAN.py
    */
    if (stFrame.byDLC != 8) return ESP_ERR_INVALID_SIZE;
    if (stFrame.dwID != 0x203) return ESP_ERR_INVALID_ARG;

    /* Standard Signals */
    TFRTireChannel13 = (float)((((uint16_t)((stFrame.abData[0] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[1] >> 0) & 0xFF))) * 0.1f + -100.0f;
    TFRTireChannel14 = (float)((((uint16_t)((stFrame.abData[2] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[3] >> 0) & 0xFF))) * 0.1f + -100.0f;
    TFRTireChannel15 = (float)((((uint16_t)((stFrame.abData[4] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[5] >> 0) & 0xFF))) * 0.1f + -100.0f;
    TFRTireChannel16 = (float)((((uint16_t)((stFrame.abData[6] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[7] >> 0) & 0xFF))) * 0.1f + -100.0f;
    return ESP_OK;
}

esp_err_t FRTireTemp4Tx(twai_node_handle_t stCANBus)
{
    /*
    *===========================================================================
    *   FRTireTemp4Tx
    *   Encodes and Transmits Message: FRTireTemp4 (0x203)
    *   Uses global signal variables.
    *   Takes:   stCANBus: Handle to CAN bus to transmit on
    *   Returns: ESP_OK if successful, error code if not.
    */
    CAN_frame_t stFrame;
    stFrame.dwID = 0x203;
    stFrame.byDLC = 8;
    memset(stFrame.abData, 0, 8);

    stFrame.abData[0] |= (uint8_t)(((((uint32_t)((TFRTireChannel13 - -100.0f) / 0.1f) & 0xFFFF) >> 8) & 0xFF) << 0);
    stFrame.abData[1] |= (uint8_t)(((((uint32_t)((TFRTireChannel13 - -100.0f) / 0.1f) & 0xFFFF) >> 0) & 0xFF) << 0);
    stFrame.abData[2] |= (uint8_t)(((((uint32_t)((TFRTireChannel14 - -100.0f) / 0.1f) & 0xFFFF) >> 8) & 0xFF) << 0);
    stFrame.abData[3] |= (uint8_t)(((((uint32_t)((TFRTireChannel14 - -100.0f) / 0.1f) & 0xFFFF) >> 0) & 0xFF) << 0);
    stFrame.abData[4] |= (uint8_t)(((((uint32_t)((TFRTireChannel15 - -100.0f) / 0.1f) & 0xFFFF) >> 8) & 0xFF) << 0);
    stFrame.abData[5] |= (uint8_t)(((((uint32_t)((TFRTireChannel15 - -100.0f) / 0.1f) & 0xFFFF) >> 0) & 0xFF) << 0);
    stFrame.abData[6] |= (uint8_t)(((((uint32_t)((TFRTireChannel16 - -100.0f) / 0.1f) & 0xFFFF) >> 8) & 0xFF) << 0);
    stFrame.abData[7] |= (uint8_t)(((((uint32_t)((TFRTireChannel16 - -100.0f) / 0.1f) & 0xFFFF) >> 0) & 0xFF) << 0);

    return CAN_transmit(stCANBus, &stFrame);
}

esp_err_t FLTireTemp1(CAN_frame_t stFrame)
{
    /*
    *===========================================================================
    *   FLTireTemp1
    *   Message: FLTireTemp1 (0x204)
    *   Description: Front Left Tire temperature sensor channels 1-4
    *   Takes:   stFrame: The CAN frame to decode
    *   Returns: ESP_OK if successful, error code if not.
    *   Autogenerated by decodeCAN.py
    */
    if (stFrame.byDLC != 8) return ESP_ERR_INVALID_SIZE;
    if (stFrame.dwID != 0x204) return ESP_ERR_INVALID_ARG;

    /* Standard Signals */
    TFLTireChannel01 = (float)((((uint16_t)((stFrame.abData[0] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[1] >> 0) & 0xFF))) * 0.1f + -100.0f;
    TFLTireChannel02 = (float)((((uint16_t)((stFrame.abData[2] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[3] >> 0) & 0xFF))) * 0.1f + -100.0f;
    TFLTireChannel03 = (float)((((uint16_t)((stFrame.abData[4] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[5] >> 0) & 0xFF))) * 0.1f + -100.0f;
    TFLTireChannel04 = (float)((((uint16_t)((stFrame.abData[6] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[7] >> 0) & 0xFF))) * 0.1f + -100.0f;
    return ESP_OK;
}

esp_err_t FLTireTemp1Tx(twai_node_handle_t stCANBus)
{
    /*
    *===========================================================================
    *   FLTireTemp1Tx
    *   Encodes and Transmits Message: FLTireTemp1 (0x204)
    *   Uses global signal variables.
    *   Takes:   stCANBus: Handle to CAN bus to transmit on
    *   Returns: ESP_OK if successful, error code if not.
    */
    CAN_frame_t stFrame;
    stFrame.dwID = 0x204;
    stFrame.byDLC = 8;
    memset(stFrame.abData, 0, 8);

    stFrame.abData[0] |= (uint8_t)(((((uint32_t)((TFLTireChannel01 - -100.0f) / 0.1f) & 0xFFFF) >> 8) & 0xFF) << 0);
    stFrame.abData[1] |= (uint8_t)(((((uint32_t)((TFLTireChannel01 - -100.0f) / 0.1f) & 0xFFFF) >> 0) & 0xFF) << 0);
    stFrame.abData[2] |= (uint8_t)(((((uint32_t)((TFLTireChannel02 - -100.0f) / 0.1f) & 0xFFFF) >> 8) & 0xFF) << 0);
    stFrame.abData[3] |= (uint8_t)(((((uint32_t)((TFLTireChannel02 - -100.0f) / 0.1f) & 0xFFFF) >> 0) & 0xFF) << 0);
    stFrame.abData[4] |= (uint8_t)(((((uint32_t)((TFLTireChannel03 - -100.0f) / 0.1f) & 0xFFFF) >> 8) & 0xFF) << 0);
    stFrame.abData[5] |= (uint8_t)(((((uint32_t)((TFLTireChannel03 - -100.0f) / 0.1f) & 0xFFFF) >> 0) & 0xFF) << 0);
    stFrame.abData[6] |= (uint8_t)(((((uint32_t)((TFLTireChannel04 - -100.0f) / 0.1f) & 0xFFFF) >> 8) & 0xFF) << 0);
    stFrame.abData[7] |= (uint8_t)(((((uint32_t)((TFLTireChannel04 - -100.0f) / 0.1f) & 0xFFFF) >> 0) & 0xFF) << 0);

    return CAN_transmit(stCANBus, &stFrame);
}

esp_err_t FLTireTemp2(CAN_frame_t stFrame)
{
    /*
    *===========================================================================
    *   FLTireTemp2
    *   Message: FLTireTemp2 (0x205)
    *   Description: Front Left Tire temperature sensor channels 5-8
    *   Takes:   stFrame: The CAN frame to decode
    *   Returns: ESP_OK if successful, error code if not.
    *   Autogenerated by decodeCAN.py
    */
    if (stFrame.byDLC != 8) return ESP_ERR_INVALID_SIZE;
    if (stFrame.dwID != 0x205) return ESP_ERR_INVALID_ARG;

    /* Standard Signals */
    TFLTireChannel05 = (float)((((uint16_t)((stFrame.abData[0] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[1] >> 0) & 0xFF))) * 0.1f + -100.0f;
    TFLTireChannel06 = (float)((((uint16_t)((stFrame.abData[2] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[3] >> 0) & 0xFF))) * 0.1f + -100.0f;
    TFLTireChannel07 = (float)((((uint16_t)((stFrame.abData[4] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[5] >> 0) & 0xFF))) * 0.1f + -100.0f;
    TFLTireChannel08 = (float)((((uint16_t)((stFrame.abData[6] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[7] >> 0) & 0xFF))) * 0.1f + -100.0f;
    return ESP_OK;
}

esp_err_t FLTireTemp2Tx(twai_node_handle_t stCANBus)
{
    /*
    *===========================================================================
    *   FLTireTemp2Tx
    *   Encodes and Transmits Message: FLTireTemp2 (0x205)
    *   Uses global signal variables.
    *   Takes:   stCANBus: Handle to CAN bus to transmit on
    *   Returns: ESP_OK if successful, error code if not.
    */
    CAN_frame_t stFrame;
    stFrame.dwID = 0x205;
    stFrame.byDLC = 8;
    memset(stFrame.abData, 0, 8);

    stFrame.abData[0] |= (uint8_t)(((((uint32_t)((TFLTireChannel05 - -100.0f) / 0.1f) & 0xFFFF) >> 8) & 0xFF) << 0);
    stFrame.abData[1] |= (uint8_t)(((((uint32_t)((TFLTireChannel05 - -100.0f) / 0.1f) & 0xFFFF) >> 0) & 0xFF) << 0);
    stFrame.abData[2] |= (uint8_t)(((((uint32_t)((TFLTireChannel06 - -100.0f) / 0.1f) & 0xFFFF) >> 8) & 0xFF) << 0);
    stFrame.abData[3] |= (uint8_t)(((((uint32_t)((TFLTireChannel06 - -100.0f) / 0.1f) & 0xFFFF) >> 0) & 0xFF) << 0);
    stFrame.abData[4] |= (uint8_t)(((((uint32_t)((TFLTireChannel07 - -100.0f) / 0.1f) & 0xFFFF) >> 8) & 0xFF) << 0);
    stFrame.abData[5] |= (uint8_t)(((((uint32_t)((TFLTireChannel07 - -100.0f) / 0.1f) & 0xFFFF) >> 0) & 0xFF) << 0);
    stFrame.abData[6] |= (uint8_t)(((((uint32_t)((TFLTireChannel08 - -100.0f) / 0.1f) & 0xFFFF) >> 8) & 0xFF) << 0);
    stFrame.abData[7] |= (uint8_t)(((((uint32_t)((TFLTireChannel08 - -100.0f) / 0.1f) & 0xFFFF) >> 0) & 0xFF) << 0);

    return CAN_transmit(stCANBus, &stFrame);
}

esp_err_t FLTireTemp3(CAN_frame_t stFrame)
{
    /*
    *===========================================================================
    *   FLTireTemp3
    *   Message: FLTireTemp3 (0x206)
    *   Description: Front Left Tire temperature sensor channels 9-12
    *   Takes:   stFrame: The CAN frame to decode
    *   Returns: ESP_OK if successful, error code if not.
    *   Autogenerated by decodeCAN.py
    */
    if (stFrame.byDLC != 8) return ESP_ERR_INVALID_SIZE;
    if (stFrame.dwID != 0x206) return ESP_ERR_INVALID_ARG;

    /* Standard Signals */
    TFLTireChannel09 = (float)((((uint16_t)((stFrame.abData[0] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[1] >> 0) & 0xFF))) * 0.1f + -100.0f;
    TFLTireChannel10 = (float)((((uint16_t)((stFrame.abData[2] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[3] >> 0) & 0xFF))) * 0.1f + -100.0f;
    TFLTireChannel11 = (float)((((uint16_t)((stFrame.abData[4] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[5] >> 0) & 0xFF))) * 0.1f + -100.0f;
    TFLTireChannel12 = (float)((((uint16_t)((stFrame.abData[6] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[7] >> 0) & 0xFF))) * 0.1f + -100.0f;
    return ESP_OK;
}

esp_err_t FLTireTemp3Tx(twai_node_handle_t stCANBus)
{
    /*
    *===========================================================================
    *   FLTireTemp3Tx
    *   Encodes and Transmits Message: FLTireTemp3 (0x206)
    *   Uses global signal variables.
    *   Takes:   stCANBus: Handle to CAN bus to transmit on
    *   Returns: ESP_OK if successful, error code if not.
    */
    CAN_frame_t stFrame;
    stFrame.dwID = 0x206;
    stFrame.byDLC = 8;
    memset(stFrame.abData, 0, 8);

    stFrame.abData[0] |= (uint8_t)(((((uint32_t)((TFLTireChannel09 - -100.0f) / 0.1f) & 0xFFFF) >> 8) & 0xFF) << 0);
    stFrame.abData[1] |= (uint8_t)(((((uint32_t)((TFLTireChannel09 - -100.0f) / 0.1f) & 0xFFFF) >> 0) & 0xFF) << 0);
    stFrame.abData[2] |= (uint8_t)(((((uint32_t)((TFLTireChannel10 - -100.0f) / 0.1f) & 0xFFFF) >> 8) & 0xFF) << 0);
    stFrame.abData[3] |= (uint8_t)(((((uint32_t)((TFLTireChannel10 - -100.0f) / 0.1f) & 0xFFFF) >> 0) & 0xFF) << 0);
    stFrame.abData[4] |= (uint8_t)(((((uint32_t)((TFLTireChannel11 - -100.0f) / 0.1f) & 0xFFFF) >> 8) & 0xFF) << 0);
    stFrame.abData[5] |= (uint8_t)(((((uint32_t)((TFLTireChannel11 - -100.0f) / 0.1f) & 0xFFFF) >> 0) & 0xFF) << 0);
    stFrame.abData[6] |= (uint8_t)(((((uint32_t)((TFLTireChannel12 - -100.0f) / 0.1f) & 0xFFFF) >> 8) & 0xFF) << 0);
    stFrame.abData[7] |= (uint8_t)(((((uint32_t)((TFLTireChannel12 - -100.0f) / 0.1f) & 0xFFFF) >> 0) & 0xFF) << 0);

    return CAN_transmit(stCANBus, &stFrame);
}

esp_err_t FLTireTemp4(CAN_frame_t stFrame)
{
    /*
    *===========================================================================
    *   FLTireTemp4
    *   Message: FLTireTemp4 (0x207)
    *   Description: Front Left Tire temperature sensor channels 13-16
    *   Takes:   stFrame: The CAN frame to decode
    *   Returns: ESP_OK if successful, error code if not.
    *   Autogenerated by decodeCAN.py
    */
    if (stFrame.byDLC != 8) return ESP_ERR_INVALID_SIZE;
    if (stFrame.dwID != 0x207) return ESP_ERR_INVALID_ARG;

    /* Standard Signals */
    TFLTireChannel13 = (float)((((uint16_t)((stFrame.abData[0] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[1] >> 0) & 0xFF))) * 0.1f + -100.0f;
    TFLTireChannel14 = (float)((((uint16_t)((stFrame.abData[2] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[3] >> 0) & 0xFF))) * 0.1f + -100.0f;
    TFLTireChannel15 = (float)((((uint16_t)((stFrame.abData[4] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[5] >> 0) & 0xFF))) * 0.1f + -100.0f;
    TFLTireChannel16 = (float)((((uint16_t)((stFrame.abData[6] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[7] >> 0) & 0xFF))) * 0.1f + -100.0f;
    return ESP_OK;
}

esp_err_t FLTireTemp4Tx(twai_node_handle_t stCANBus)
{
    /*
    *===========================================================================
    *   FLTireTemp4Tx
    *   Encodes and Transmits Message: FLTireTemp4 (0x207)
    *   Uses global signal variables.
    *   Takes:   stCANBus: Handle to CAN bus to transmit on
    *   Returns: ESP_OK if successful, error code if not.
    */
    CAN_frame_t stFrame;
    stFrame.dwID = 0x207;
    stFrame.byDLC = 8;
    memset(stFrame.abData, 0, 8);

    stFrame.abData[0] |= (uint8_t)(((((uint32_t)((TFLTireChannel13 - -100.0f) / 0.1f) & 0xFFFF) >> 8) & 0xFF) << 0);
    stFrame.abData[1] |= (uint8_t)(((((uint32_t)((TFLTireChannel13 - -100.0f) / 0.1f) & 0xFFFF) >> 0) & 0xFF) << 0);
    stFrame.abData[2] |= (uint8_t)(((((uint32_t)((TFLTireChannel14 - -100.0f) / 0.1f) & 0xFFFF) >> 8) & 0xFF) << 0);
    stFrame.abData[3] |= (uint8_t)(((((uint32_t)((TFLTireChannel14 - -100.0f) / 0.1f) & 0xFFFF) >> 0) & 0xFF) << 0);
    stFrame.abData[4] |= (uint8_t)(((((uint32_t)((TFLTireChannel15 - -100.0f) / 0.1f) & 0xFFFF) >> 8) & 0xFF) << 0);
    stFrame.abData[5] |= (uint8_t)(((((uint32_t)((TFLTireChannel15 - -100.0f) / 0.1f) & 0xFFFF) >> 0) & 0xFF) << 0);
    stFrame.abData[6] |= (uint8_t)(((((uint32_t)((TFLTireChannel16 - -100.0f) / 0.1f) & 0xFFFF) >> 8) & 0xFF) << 0);
    stFrame.abData[7] |= (uint8_t)(((((uint32_t)((TFLTireChannel16 - -100.0f) / 0.1f) & 0xFFFF) >> 0) & 0xFF) << 0);

    return CAN_transmit(stCANBus, &stFrame);
}

esp_err_t RRTireTemp1(CAN_frame_t stFrame)
{
    /*
    *===========================================================================
    *   RRTireTemp1
    *   Message: RRTireTemp1 (0x208)
    *   Description: Rear Right Tire temperature sensor channels 1-4
    *   Takes:   stFrame: The CAN frame to decode
    *   Returns: ESP_OK if successful, error code if not.
    *   Autogenerated by decodeCAN.py
    */
    if (stFrame.byDLC != 8) return ESP_ERR_INVALID_SIZE;
    if (stFrame.dwID != 0x208) return ESP_ERR_INVALID_ARG;

    /* Standard Signals */
    TRRTireChannel01 = (float)((((uint16_t)((stFrame.abData[0] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[1] >> 0) & 0xFF))) * 0.1f + -100.0f;
    TRRTireChannel02 = (float)((((uint16_t)((stFrame.abData[2] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[3] >> 0) & 0xFF))) * 0.1f + -100.0f;
    TRRTireChannel03 = (float)((((uint16_t)((stFrame.abData[4] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[5] >> 0) & 0xFF))) * 0.1f + -100.0f;
    TRRTireChannel04 = (float)((((uint16_t)((stFrame.abData[6] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[7] >> 0) & 0xFF))) * 0.1f + -100.0f;
    return ESP_OK;
}

esp_err_t RRTireTemp1Tx(twai_node_handle_t stCANBus)
{
    /*
    *===========================================================================
    *   RRTireTemp1Tx
    *   Encodes and Transmits Message: RRTireTemp1 (0x208)
    *   Uses global signal variables.
    *   Takes:   stCANBus: Handle to CAN bus to transmit on
    *   Returns: ESP_OK if successful, error code if not.
    */
    CAN_frame_t stFrame;
    stFrame.dwID = 0x208;
    stFrame.byDLC = 8;
    memset(stFrame.abData, 0, 8);

    stFrame.abData[0] |= (uint8_t)(((((uint32_t)((TRRTireChannel01 - -100.0f) / 0.1f) & 0xFFFF) >> 8) & 0xFF) << 0);
    stFrame.abData[1] |= (uint8_t)(((((uint32_t)((TRRTireChannel01 - -100.0f) / 0.1f) & 0xFFFF) >> 0) & 0xFF) << 0);
    stFrame.abData[2] |= (uint8_t)(((((uint32_t)((TRRTireChannel02 - -100.0f) / 0.1f) & 0xFFFF) >> 8) & 0xFF) << 0);
    stFrame.abData[3] |= (uint8_t)(((((uint32_t)((TRRTireChannel02 - -100.0f) / 0.1f) & 0xFFFF) >> 0) & 0xFF) << 0);
    stFrame.abData[4] |= (uint8_t)(((((uint32_t)((TRRTireChannel03 - -100.0f) / 0.1f) & 0xFFFF) >> 8) & 0xFF) << 0);
    stFrame.abData[5] |= (uint8_t)(((((uint32_t)((TRRTireChannel03 - -100.0f) / 0.1f) & 0xFFFF) >> 0) & 0xFF) << 0);
    stFrame.abData[6] |= (uint8_t)(((((uint32_t)((TRRTireChannel04 - -100.0f) / 0.1f) & 0xFFFF) >> 8) & 0xFF) << 0);
    stFrame.abData[7] |= (uint8_t)(((((uint32_t)((TRRTireChannel04 - -100.0f) / 0.1f) & 0xFFFF) >> 0) & 0xFF) << 0);

    return CAN_transmit(stCANBus, &stFrame);
}

esp_err_t RRTireTemp2(CAN_frame_t stFrame)
{
    /*
    *===========================================================================
    *   RRTireTemp2
    *   Message: RRTireTemp2 (0x209)
    *   Description: Rear Right Tire temperature sensor channels 5-8
    *   Takes:   stFrame: The CAN frame to decode
    *   Returns: ESP_OK if successful, error code if not.
    *   Autogenerated by decodeCAN.py
    */
    if (stFrame.byDLC != 8) return ESP_ERR_INVALID_SIZE;
    if (stFrame.dwID != 0x209) return ESP_ERR_INVALID_ARG;

    /* Standard Signals */
    TRRTireChannel05 = (float)((((uint16_t)((stFrame.abData[0] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[1] >> 0) & 0xFF))) * 0.1f + -100.0f;
    TRRTireChannel06 = (float)((((uint16_t)((stFrame.abData[2] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[3] >> 0) & 0xFF))) * 0.1f + -100.0f;
    TRRTireChannel07 = (float)((((uint16_t)((stFrame.abData[4] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[5] >> 0) & 0xFF))) * 0.1f + -100.0f;
    TRRTireChannel08 = (float)((((uint16_t)((stFrame.abData[6] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[7] >> 0) & 0xFF))) * 0.1f + -100.0f;
    return ESP_OK;
}

esp_err_t RRTireTemp2Tx(twai_node_handle_t stCANBus)
{
    /*
    *===========================================================================
    *   RRTireTemp2Tx
    *   Encodes and Transmits Message: RRTireTemp2 (0x209)
    *   Uses global signal variables.
    *   Takes:   stCANBus: Handle to CAN bus to transmit on
    *   Returns: ESP_OK if successful, error code if not.
    */
    CAN_frame_t stFrame;
    stFrame.dwID = 0x209;
    stFrame.byDLC = 8;
    memset(stFrame.abData, 0, 8);

    stFrame.abData[0] |= (uint8_t)(((((uint32_t)((TRRTireChannel05 - -100.0f) / 0.1f) & 0xFFFF) >> 8) & 0xFF) << 0);
    stFrame.abData[1] |= (uint8_t)(((((uint32_t)((TRRTireChannel05 - -100.0f) / 0.1f) & 0xFFFF) >> 0) & 0xFF) << 0);
    stFrame.abData[2] |= (uint8_t)(((((uint32_t)((TRRTireChannel06 - -100.0f) / 0.1f) & 0xFFFF) >> 8) & 0xFF) << 0);
    stFrame.abData[3] |= (uint8_t)(((((uint32_t)((TRRTireChannel06 - -100.0f) / 0.1f) & 0xFFFF) >> 0) & 0xFF) << 0);
    stFrame.abData[4] |= (uint8_t)(((((uint32_t)((TRRTireChannel07 - -100.0f) / 0.1f) & 0xFFFF) >> 8) & 0xFF) << 0);
    stFrame.abData[5] |= (uint8_t)(((((uint32_t)((TRRTireChannel07 - -100.0f) / 0.1f) & 0xFFFF) >> 0) & 0xFF) << 0);
    stFrame.abData[6] |= (uint8_t)(((((uint32_t)((TRRTireChannel08 - -100.0f) / 0.1f) & 0xFFFF) >> 8) & 0xFF) << 0);
    stFrame.abData[7] |= (uint8_t)(((((uint32_t)((TRRTireChannel08 - -100.0f) / 0.1f) & 0xFFFF) >> 0) & 0xFF) << 0);

    return CAN_transmit(stCANBus, &stFrame);
}

esp_err_t RRTireTemp3(CAN_frame_t stFrame)
{
    /*
    *===========================================================================
    *   RRTireTemp3
    *   Message: RRTireTemp3 (0x20A)
    *   Description: Rear Right Tire temperature sensor channels 9-12
    *   Takes:   stFrame: The CAN frame to decode
    *   Returns: ESP_OK if successful, error code if not.
    *   Autogenerated by decodeCAN.py
    */
    if (stFrame.byDLC != 8) return ESP_ERR_INVALID_SIZE;
    if (stFrame.dwID != 0x20A) return ESP_ERR_INVALID_ARG;

    /* Standard Signals */
    TRRTireChannel09 = (float)((((uint16_t)((stFrame.abData[0] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[1] >> 0) & 0xFF))) * 0.1f + -100.0f;
    TRRTireChannel10 = (float)((((uint16_t)((stFrame.abData[2] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[3] >> 0) & 0xFF))) * 0.1f + -100.0f;
    TRRTireChannel11 = (float)((((uint16_t)((stFrame.abData[4] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[5] >> 0) & 0xFF))) * 0.1f + -100.0f;
    TRRTireChannel12 = (float)((((uint16_t)((stFrame.abData[6] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[7] >> 0) & 0xFF))) * 0.1f + -100.0f;
    return ESP_OK;
}

esp_err_t RRTireTemp3Tx(twai_node_handle_t stCANBus)
{
    /*
    *===========================================================================
    *   RRTireTemp3Tx
    *   Encodes and Transmits Message: RRTireTemp3 (0x20A)
    *   Uses global signal variables.
    *   Takes:   stCANBus: Handle to CAN bus to transmit on
    *   Returns: ESP_OK if successful, error code if not.
    */
    CAN_frame_t stFrame;
    stFrame.dwID = 0x20A;
    stFrame.byDLC = 8;
    memset(stFrame.abData, 0, 8);

    stFrame.abData[0] |= (uint8_t)(((((uint32_t)((TRRTireChannel09 - -100.0f) / 0.1f) & 0xFFFF) >> 8) & 0xFF) << 0);
    stFrame.abData[1] |= (uint8_t)(((((uint32_t)((TRRTireChannel09 - -100.0f) / 0.1f) & 0xFFFF) >> 0) & 0xFF) << 0);
    stFrame.abData[2] |= (uint8_t)(((((uint32_t)((TRRTireChannel10 - -100.0f) / 0.1f) & 0xFFFF) >> 8) & 0xFF) << 0);
    stFrame.abData[3] |= (uint8_t)(((((uint32_t)((TRRTireChannel10 - -100.0f) / 0.1f) & 0xFFFF) >> 0) & 0xFF) << 0);
    stFrame.abData[4] |= (uint8_t)(((((uint32_t)((TRRTireChannel11 - -100.0f) / 0.1f) & 0xFFFF) >> 8) & 0xFF) << 0);
    stFrame.abData[5] |= (uint8_t)(((((uint32_t)((TRRTireChannel11 - -100.0f) / 0.1f) & 0xFFFF) >> 0) & 0xFF) << 0);
    stFrame.abData[6] |= (uint8_t)(((((uint32_t)((TRRTireChannel12 - -100.0f) / 0.1f) & 0xFFFF) >> 8) & 0xFF) << 0);
    stFrame.abData[7] |= (uint8_t)(((((uint32_t)((TRRTireChannel12 - -100.0f) / 0.1f) & 0xFFFF) >> 0) & 0xFF) << 0);

    return CAN_transmit(stCANBus, &stFrame);
}

esp_err_t RRTireTemp4(CAN_frame_t stFrame)
{
    /*
    *===========================================================================
    *   RRTireTemp4
    *   Message: RRTireTemp4 (0x20B)
    *   Description: Rear Right Tire temperature sensor channels 13-16
    *   Takes:   stFrame: The CAN frame to decode
    *   Returns: ESP_OK if successful, error code if not.
    *   Autogenerated by decodeCAN.py
    */
    if (stFrame.byDLC != 8) return ESP_ERR_INVALID_SIZE;
    if (stFrame.dwID != 0x20B) return ESP_ERR_INVALID_ARG;

    /* Standard Signals */
    TRRTireChannel13 = (float)((((uint16_t)((stFrame.abData[0] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[1] >> 0) & 0xFF))) * 0.1f + -100.0f;
    TRRTireChannel14 = (float)((((uint16_t)((stFrame.abData[2] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[3] >> 0) & 0xFF))) * 0.1f + -100.0f;
    TRRTireChannel15 = (float)((((uint16_t)((stFrame.abData[4] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[5] >> 0) & 0xFF))) * 0.1f + -100.0f;
    TRRTireChannel16 = (float)((((uint16_t)((stFrame.abData[6] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[7] >> 0) & 0xFF))) * 0.1f + -100.0f;
    return ESP_OK;
}

esp_err_t RRTireTemp4Tx(twai_node_handle_t stCANBus)
{
    /*
    *===========================================================================
    *   RRTireTemp4Tx
    *   Encodes and Transmits Message: RRTireTemp4 (0x20B)
    *   Uses global signal variables.
    *   Takes:   stCANBus: Handle to CAN bus to transmit on
    *   Returns: ESP_OK if successful, error code if not.
    */
    CAN_frame_t stFrame;
    stFrame.dwID = 0x20B;
    stFrame.byDLC = 8;
    memset(stFrame.abData, 0, 8);

    stFrame.abData[0] |= (uint8_t)(((((uint32_t)((TRRTireChannel13 - -100.0f) / 0.1f) & 0xFFFF) >> 8) & 0xFF) << 0);
    stFrame.abData[1] |= (uint8_t)(((((uint32_t)((TRRTireChannel13 - -100.0f) / 0.1f) & 0xFFFF) >> 0) & 0xFF) << 0);
    stFrame.abData[2] |= (uint8_t)(((((uint32_t)((TRRTireChannel14 - -100.0f) / 0.1f) & 0xFFFF) >> 8) & 0xFF) << 0);
    stFrame.abData[3] |= (uint8_t)(((((uint32_t)((TRRTireChannel14 - -100.0f) / 0.1f) & 0xFFFF) >> 0) & 0xFF) << 0);
    stFrame.abData[4] |= (uint8_t)(((((uint32_t)((TRRTireChannel15 - -100.0f) / 0.1f) & 0xFFFF) >> 8) & 0xFF) << 0);
    stFrame.abData[5] |= (uint8_t)(((((uint32_t)((TRRTireChannel15 - -100.0f) / 0.1f) & 0xFFFF) >> 0) & 0xFF) << 0);
    stFrame.abData[6] |= (uint8_t)(((((uint32_t)((TRRTireChannel16 - -100.0f) / 0.1f) & 0xFFFF) >> 8) & 0xFF) << 0);
    stFrame.abData[7] |= (uint8_t)(((((uint32_t)((TRRTireChannel16 - -100.0f) / 0.1f) & 0xFFFF) >> 0) & 0xFF) << 0);

    return CAN_transmit(stCANBus, &stFrame);
}

esp_err_t RLTireTemp1(CAN_frame_t stFrame)
{
    /*
    *===========================================================================
    *   RLTireTemp1
    *   Message: RLTireTemp1 (0x20C)
    *   Description: Rear Left Tire temperature sensor channels 1-4
    *   Takes:   stFrame: The CAN frame to decode
    *   Returns: ESP_OK if successful, error code if not.
    *   Autogenerated by decodeCAN.py
    */
    if (stFrame.byDLC != 8) return ESP_ERR_INVALID_SIZE;
    if (stFrame.dwID != 0x20C) return ESP_ERR_INVALID_ARG;

    /* Standard Signals */
    TRLTireChannel01 = (float)((((uint16_t)((stFrame.abData[0] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[1] >> 0) & 0xFF))) * 0.1f + -100.0f;
    TRLTireChannel02 = (float)((((uint16_t)((stFrame.abData[2] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[3] >> 0) & 0xFF))) * 0.1f + -100.0f;
    TRLTireChannel03 = (float)((((uint16_t)((stFrame.abData[4] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[5] >> 0) & 0xFF))) * 0.1f + -100.0f;
    TRLTireChannel04 = (float)((((uint16_t)((stFrame.abData[6] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[7] >> 0) & 0xFF))) * 0.1f + -100.0f;
    return ESP_OK;
}

esp_err_t RLTireTemp1Tx(twai_node_handle_t stCANBus)
{
    /*
    *===========================================================================
    *   RLTireTemp1Tx
    *   Encodes and Transmits Message: RLTireTemp1 (0x20C)
    *   Uses global signal variables.
    *   Takes:   stCANBus: Handle to CAN bus to transmit on
    *   Returns: ESP_OK if successful, error code if not.
    */
    CAN_frame_t stFrame;
    stFrame.dwID = 0x20C;
    stFrame.byDLC = 8;
    memset(stFrame.abData, 0, 8);

    stFrame.abData[0] |= (uint8_t)(((((uint32_t)((TRLTireChannel01 - -100.0f) / 0.1f) & 0xFFFF) >> 8) & 0xFF) << 0);
    stFrame.abData[1] |= (uint8_t)(((((uint32_t)((TRLTireChannel01 - -100.0f) / 0.1f) & 0xFFFF) >> 0) & 0xFF) << 0);
    stFrame.abData[2] |= (uint8_t)(((((uint32_t)((TRLTireChannel02 - -100.0f) / 0.1f) & 0xFFFF) >> 8) & 0xFF) << 0);
    stFrame.abData[3] |= (uint8_t)(((((uint32_t)((TRLTireChannel02 - -100.0f) / 0.1f) & 0xFFFF) >> 0) & 0xFF) << 0);
    stFrame.abData[4] |= (uint8_t)(((((uint32_t)((TRLTireChannel03 - -100.0f) / 0.1f) & 0xFFFF) >> 8) & 0xFF) << 0);
    stFrame.abData[5] |= (uint8_t)(((((uint32_t)((TRLTireChannel03 - -100.0f) / 0.1f) & 0xFFFF) >> 0) & 0xFF) << 0);
    stFrame.abData[6] |= (uint8_t)(((((uint32_t)((TRLTireChannel04 - -100.0f) / 0.1f) & 0xFFFF) >> 8) & 0xFF) << 0);
    stFrame.abData[7] |= (uint8_t)(((((uint32_t)((TRLTireChannel04 - -100.0f) / 0.1f) & 0xFFFF) >> 0) & 0xFF) << 0);

    return CAN_transmit(stCANBus, &stFrame);
}

esp_err_t RLTireTemp2(CAN_frame_t stFrame)
{
    /*
    *===========================================================================
    *   RLTireTemp2
    *   Message: RLTireTemp2 (0x20D)
    *   Description: Rear Left Tire temperature sensor channels 5-8
    *   Takes:   stFrame: The CAN frame to decode
    *   Returns: ESP_OK if successful, error code if not.
    *   Autogenerated by decodeCAN.py
    */
    if (stFrame.byDLC != 8) return ESP_ERR_INVALID_SIZE;
    if (stFrame.dwID != 0x20D) return ESP_ERR_INVALID_ARG;

    /* Standard Signals */
    TRLTireChannel05 = (float)((((uint16_t)((stFrame.abData[0] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[1] >> 0) & 0xFF))) * 0.1f + -100.0f;
    TRLTireChannel06 = (float)((((uint16_t)((stFrame.abData[2] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[3] >> 0) & 0xFF))) * 0.1f + -100.0f;
    TRLTireChannel07 = (float)((((uint16_t)((stFrame.abData[4] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[5] >> 0) & 0xFF))) * 0.1f + -100.0f;
    TRLTireChannel08 = (float)((((uint16_t)((stFrame.abData[6] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[7] >> 0) & 0xFF))) * 0.1f + -100.0f;
    return ESP_OK;
}

esp_err_t RLTireTemp2Tx(twai_node_handle_t stCANBus)
{
    /*
    *===========================================================================
    *   RLTireTemp2Tx
    *   Encodes and Transmits Message: RLTireTemp2 (0x20D)
    *   Uses global signal variables.
    *   Takes:   stCANBus: Handle to CAN bus to transmit on
    *   Returns: ESP_OK if successful, error code if not.
    */
    CAN_frame_t stFrame;
    stFrame.dwID = 0x20D;
    stFrame.byDLC = 8;
    memset(stFrame.abData, 0, 8);

    stFrame.abData[0] |= (uint8_t)(((((uint32_t)((TRLTireChannel05 - -100.0f) / 0.1f) & 0xFFFF) >> 8) & 0xFF) << 0);
    stFrame.abData[1] |= (uint8_t)(((((uint32_t)((TRLTireChannel05 - -100.0f) / 0.1f) & 0xFFFF) >> 0) & 0xFF) << 0);
    stFrame.abData[2] |= (uint8_t)(((((uint32_t)((TRLTireChannel06 - -100.0f) / 0.1f) & 0xFFFF) >> 8) & 0xFF) << 0);
    stFrame.abData[3] |= (uint8_t)(((((uint32_t)((TRLTireChannel06 - -100.0f) / 0.1f) & 0xFFFF) >> 0) & 0xFF) << 0);
    stFrame.abData[4] |= (uint8_t)(((((uint32_t)((TRLTireChannel07 - -100.0f) / 0.1f) & 0xFFFF) >> 8) & 0xFF) << 0);
    stFrame.abData[5] |= (uint8_t)(((((uint32_t)((TRLTireChannel07 - -100.0f) / 0.1f) & 0xFFFF) >> 0) & 0xFF) << 0);
    stFrame.abData[6] |= (uint8_t)(((((uint32_t)((TRLTireChannel08 - -100.0f) / 0.1f) & 0xFFFF) >> 8) & 0xFF) << 0);
    stFrame.abData[7] |= (uint8_t)(((((uint32_t)((TRLTireChannel08 - -100.0f) / 0.1f) & 0xFFFF) >> 0) & 0xFF) << 0);

    return CAN_transmit(stCANBus, &stFrame);
}

esp_err_t RLTireTemp3(CAN_frame_t stFrame)
{
    /*
    *===========================================================================
    *   RLTireTemp3
    *   Message: RLTireTemp3 (0x20E)
    *   Description: Rear Left Tire temperature sensor channels 9-12
    *   Takes:   stFrame: The CAN frame to decode
    *   Returns: ESP_OK if successful, error code if not.
    *   Autogenerated by decodeCAN.py
    */
    if (stFrame.byDLC != 8) return ESP_ERR_INVALID_SIZE;
    if (stFrame.dwID != 0x20E) return ESP_ERR_INVALID_ARG;

    /* Standard Signals */
    TRLTireChannel09 = (float)((((uint16_t)((stFrame.abData[0] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[1] >> 0) & 0xFF))) * 0.1f + -100.0f;
    TRLTireChannel10 = (float)((((uint16_t)((stFrame.abData[2] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[3] >> 0) & 0xFF))) * 0.1f + -100.0f;
    TRLTireChannel11 = (float)((((uint16_t)((stFrame.abData[4] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[5] >> 0) & 0xFF))) * 0.1f + -100.0f;
    TRLTireChannel12 = (float)((((uint16_t)((stFrame.abData[6] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[7] >> 0) & 0xFF))) * 0.1f + -100.0f;
    return ESP_OK;
}

esp_err_t RLTireTemp3Tx(twai_node_handle_t stCANBus)
{
    /*
    *===========================================================================
    *   RLTireTemp3Tx
    *   Encodes and Transmits Message: RLTireTemp3 (0x20E)
    *   Uses global signal variables.
    *   Takes:   stCANBus: Handle to CAN bus to transmit on
    *   Returns: ESP_OK if successful, error code if not.
    */
    CAN_frame_t stFrame;
    stFrame.dwID = 0x20E;
    stFrame.byDLC = 8;
    memset(stFrame.abData, 0, 8);

    stFrame.abData[0] |= (uint8_t)(((((uint32_t)((TRLTireChannel09 - -100.0f) / 0.1f) & 0xFFFF) >> 8) & 0xFF) << 0);
    stFrame.abData[1] |= (uint8_t)(((((uint32_t)((TRLTireChannel09 - -100.0f) / 0.1f) & 0xFFFF) >> 0) & 0xFF) << 0);
    stFrame.abData[2] |= (uint8_t)(((((uint32_t)((TRLTireChannel10 - -100.0f) / 0.1f) & 0xFFFF) >> 8) & 0xFF) << 0);
    stFrame.abData[3] |= (uint8_t)(((((uint32_t)((TRLTireChannel10 - -100.0f) / 0.1f) & 0xFFFF) >> 0) & 0xFF) << 0);
    stFrame.abData[4] |= (uint8_t)(((((uint32_t)((TRLTireChannel11 - -100.0f) / 0.1f) & 0xFFFF) >> 8) & 0xFF) << 0);
    stFrame.abData[5] |= (uint8_t)(((((uint32_t)((TRLTireChannel11 - -100.0f) / 0.1f) & 0xFFFF) >> 0) & 0xFF) << 0);
    stFrame.abData[6] |= (uint8_t)(((((uint32_t)((TRLTireChannel12 - -100.0f) / 0.1f) & 0xFFFF) >> 8) & 0xFF) << 0);
    stFrame.abData[7] |= (uint8_t)(((((uint32_t)((TRLTireChannel12 - -100.0f) / 0.1f) & 0xFFFF) >> 0) & 0xFF) << 0);

    return CAN_transmit(stCANBus, &stFrame);
}

esp_err_t RLTireTemp4(CAN_frame_t stFrame)
{
    /*
    *===========================================================================
    *   RLTireTemp4
    *   Message: RLTireTemp4 (0x20F)
    *   Description: Rear Left Tire temperature sensor channels 13-16
    *   Takes:   stFrame: The CAN frame to decode
    *   Returns: ESP_OK if successful, error code if not.
    *   Autogenerated by decodeCAN.py
    */
    if (stFrame.byDLC != 8) return ESP_ERR_INVALID_SIZE;
    if (stFrame.dwID != 0x20F) return ESP_ERR_INVALID_ARG;

    /* Standard Signals */
    TRLTireChannel13 = (float)((((uint16_t)((stFrame.abData[0] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[1] >> 0) & 0xFF))) * 0.1f + -100.0f;
    TRLTireChannel14 = (float)((((uint16_t)((stFrame.abData[2] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[3] >> 0) & 0xFF))) * 0.1f + -100.0f;
    TRLTireChannel15 = (float)((((uint16_t)((stFrame.abData[4] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[5] >> 0) & 0xFF))) * 0.1f + -100.0f;
    TRLTireChannel16 = (float)((((uint16_t)((stFrame.abData[6] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[7] >> 0) & 0xFF))) * 0.1f + -100.0f;
    return ESP_OK;
}

esp_err_t RLTireTemp4Tx(twai_node_handle_t stCANBus)
{
    /*
    *===========================================================================
    *   RLTireTemp4Tx
    *   Encodes and Transmits Message: RLTireTemp4 (0x20F)
    *   Uses global signal variables.
    *   Takes:   stCANBus: Handle to CAN bus to transmit on
    *   Returns: ESP_OK if successful, error code if not.
    */
    CAN_frame_t stFrame;
    stFrame.dwID = 0x20F;
    stFrame.byDLC = 8;
    memset(stFrame.abData, 0, 8);

    stFrame.abData[0] |= (uint8_t)(((((uint32_t)((TRLTireChannel13 - -100.0f) / 0.1f) & 0xFFFF) >> 8) & 0xFF) << 0);
    stFrame.abData[1] |= (uint8_t)(((((uint32_t)((TRLTireChannel13 - -100.0f) / 0.1f) & 0xFFFF) >> 0) & 0xFF) << 0);
    stFrame.abData[2] |= (uint8_t)(((((uint32_t)((TRLTireChannel14 - -100.0f) / 0.1f) & 0xFFFF) >> 8) & 0xFF) << 0);
    stFrame.abData[3] |= (uint8_t)(((((uint32_t)((TRLTireChannel14 - -100.0f) / 0.1f) & 0xFFFF) >> 0) & 0xFF) << 0);
    stFrame.abData[4] |= (uint8_t)(((((uint32_t)((TRLTireChannel15 - -100.0f) / 0.1f) & 0xFFFF) >> 8) & 0xFF) << 0);
    stFrame.abData[5] |= (uint8_t)(((((uint32_t)((TRLTireChannel15 - -100.0f) / 0.1f) & 0xFFFF) >> 0) & 0xFF) << 0);
    stFrame.abData[6] |= (uint8_t)(((((uint32_t)((TRLTireChannel16 - -100.0f) / 0.1f) & 0xFFFF) >> 8) & 0xFF) << 0);
    stFrame.abData[7] |= (uint8_t)(((((uint32_t)((TRLTireChannel16 - -100.0f) / 0.1f) & 0xFFFF) >> 0) & 0xFF) << 0);

    return CAN_transmit(stCANBus, &stFrame);
}

esp_err_t TargetIqInfo(CAN_frame_t stFrame)
{
    /*
    *===========================================================================
    *   TargetIqInfo
    *   Message: TargetIqInfo (0x3E4)
    *   Description: Node ID: 4 (decimal)
    *   Takes:   stFrame: The CAN frame to decode
    *   Returns: ESP_OK if successful, error code if not.
    *   Autogenerated by decodeCAN.py
    */
    if (stFrame.byDLC != 8) return ESP_ERR_INVALID_SIZE;
    if (stFrame.dwID != 0x3E4) return ESP_ERR_INVALID_ARG;

    /* Standard Signals */
    ControlMode = (uint8_t)(((stFrame.abData[0] >> 0) & 0xFF));
    TargetIq = (float)((((uint16_t)((stFrame.abData[1] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[2] >> 0) & 0xFF))) * 0.1f;
    MotorPosition = (float)((((uint16_t)((stFrame.abData[3] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[4] >> 0) & 0xFF))) * 0.1f;
    isMotorStill = (uint8_t)(((stFrame.abData[5] >> 0) & 0xFF));
    return ESP_OK;
}

esp_err_t TargetIqInfoTx(twai_node_handle_t stCANBus)
{
    /*
    *===========================================================================
    *   TargetIqInfoTx
    *   Encodes and Transmits Message: TargetIqInfo (0x3E4)
    *   Uses global signal variables.
    *   Takes:   stCANBus: Handle to CAN bus to transmit on
    *   Returns: ESP_OK if successful, error code if not.
    */
    CAN_frame_t stFrame;
    stFrame.dwID = 0x3E4;
    stFrame.byDLC = 8;
    memset(stFrame.abData, 0, 8);

    stFrame.abData[0] |= (uint8_t)(((((uint32_t)ControlMode & 0xFF) >> 0) & 0xFF) << 0);
    stFrame.abData[1] |= (uint8_t)(((((uint32_t)(TargetIq / 0.1f) & 0xFFFF) >> 8) & 0xFF) << 0);
    stFrame.abData[2] |= (uint8_t)(((((uint32_t)(TargetIq / 0.1f) & 0xFFFF) >> 0) & 0xFF) << 0);
    stFrame.abData[3] |= (uint8_t)(((((uint32_t)(MotorPosition / 0.1f) & 0xFFFF) >> 8) & 0xFF) << 0);
    stFrame.abData[4] |= (uint8_t)(((((uint32_t)(MotorPosition / 0.1f) & 0xFFFF) >> 0) & 0xFF) << 0);
    stFrame.abData[5] |= (uint8_t)(((((uint32_t)isMotorStill & 0xFF) >> 0) & 0xFF) << 0);

    return CAN_transmit(stCANBus, &stFrame);
}

esp_err_t ERPM_DUTY_VOLTAGE(CAN_frame_t stFrame)
{
    /*
    *===========================================================================
    *   ERPM_DUTY_VOLTAGE
    *   Message: ERPM_DUTY_VOLTAGE (0x404)
    *   Description: Node ID: 4 (decimal)
    *   Takes:   stFrame: The CAN frame to decode
    *   Returns: ESP_OK if successful, error code if not.
    *   Autogenerated by decodeCAN.py
    */
    if (stFrame.byDLC != 8) return ESP_ERR_INVALID_SIZE;
    if (stFrame.dwID != 0x404) return ESP_ERR_INVALID_ARG;

    /* Standard Signals */
    Actual_ERPM = (int32_t)((((uint32_t)((stFrame.abData[0] >> 0) & 0xFF)) << 24) | (((uint32_t)((stFrame.abData[1] >> 0) & 0xFF)) << 16) | (((uint32_t)((stFrame.abData[2] >> 0) & 0xFF)) << 8) | ((uint32_t)((stFrame.abData[3] >> 0) & 0xFF)));
    Actual_Duty = (float)((((uint16_t)((stFrame.abData[4] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[5] >> 0) & 0xFF))) * 0.1f;
    Actual_InputVoltage = (int16_t)((((uint16_t)((stFrame.abData[6] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[7] >> 0) & 0xFF)));
    return ESP_OK;
}

esp_err_t ERPM_DUTY_VOLTAGETx(twai_node_handle_t stCANBus)
{
    /*
    *===========================================================================
    *   ERPM_DUTY_VOLTAGETx
    *   Encodes and Transmits Message: ERPM_DUTY_VOLTAGE (0x404)
    *   Uses global signal variables.
    *   Takes:   stCANBus: Handle to CAN bus to transmit on
    *   Returns: ESP_OK if successful, error code if not.
    */
    CAN_frame_t stFrame;
    stFrame.dwID = 0x404;
    stFrame.byDLC = 8;
    memset(stFrame.abData, 0, 8);

    stFrame.abData[0] |= (uint8_t)(((((uint32_t)Actual_ERPM & 0xFFFFFFFF) >> 24) & 0xFF) << 0);
    stFrame.abData[1] |= (uint8_t)(((((uint32_t)Actual_ERPM & 0xFFFFFFFF) >> 16) & 0xFF) << 0);
    stFrame.abData[2] |= (uint8_t)(((((uint32_t)Actual_ERPM & 0xFFFFFFFF) >> 8) & 0xFF) << 0);
    stFrame.abData[3] |= (uint8_t)(((((uint32_t)Actual_ERPM & 0xFFFFFFFF) >> 0) & 0xFF) << 0);
    stFrame.abData[4] |= (uint8_t)(((((uint32_t)(Actual_Duty / 0.1f) & 0xFFFF) >> 8) & 0xFF) << 0);
    stFrame.abData[5] |= (uint8_t)(((((uint32_t)(Actual_Duty / 0.1f) & 0xFFFF) >> 0) & 0xFF) << 0);
    stFrame.abData[6] |= (uint8_t)(((((uint32_t)Actual_InputVoltage & 0xFFFF) >> 8) & 0xFF) << 0);
    stFrame.abData[7] |= (uint8_t)(((((uint32_t)Actual_InputVoltage & 0xFFFF) >> 0) & 0xFF) << 0);

    return CAN_transmit(stCANBus, &stFrame);
}

esp_err_t AC_DC_current(CAN_frame_t stFrame)
{
    /*
    *===========================================================================
    *   AC_DC_current
    *   Message: AC_DC_current (0x424)
    *   Description: Node ID: 4 (decimal)
    *   Takes:   stFrame: The CAN frame to decode
    *   Returns: ESP_OK if successful, error code if not.
    *   Autogenerated by decodeCAN.py
    */
    if (stFrame.byDLC != 8) return ESP_ERR_INVALID_SIZE;
    if (stFrame.dwID != 0x424) return ESP_ERR_INVALID_ARG;

    /* Standard Signals */
    Actual_ACCurrent = (float)((((uint16_t)((stFrame.abData[0] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[1] >> 0) & 0xFF))) * 0.1f;
    Actual_DCCurrent = (float)((((uint16_t)((stFrame.abData[2] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[3] >> 0) & 0xFF))) * 0.1f;
    return ESP_OK;
}

esp_err_t AC_DC_currentTx(twai_node_handle_t stCANBus)
{
    /*
    *===========================================================================
    *   AC_DC_currentTx
    *   Encodes and Transmits Message: AC_DC_current (0x424)
    *   Uses global signal variables.
    *   Takes:   stCANBus: Handle to CAN bus to transmit on
    *   Returns: ESP_OK if successful, error code if not.
    */
    CAN_frame_t stFrame;
    stFrame.dwID = 0x424;
    stFrame.byDLC = 8;
    memset(stFrame.abData, 0, 8);

    stFrame.abData[0] |= (uint8_t)(((((uint32_t)(Actual_ACCurrent / 0.1f) & 0xFFFF) >> 8) & 0xFF) << 0);
    stFrame.abData[1] |= (uint8_t)(((((uint32_t)(Actual_ACCurrent / 0.1f) & 0xFFFF) >> 0) & 0xFF) << 0);
    stFrame.abData[2] |= (uint8_t)(((((uint32_t)(Actual_DCCurrent / 0.1f) & 0xFFFF) >> 8) & 0xFF) << 0);
    stFrame.abData[3] |= (uint8_t)(((((uint32_t)(Actual_DCCurrent / 0.1f) & 0xFFFF) >> 0) & 0xFF) << 0);

    return CAN_transmit(stCANBus, &stFrame);
}

esp_err_t Temperatures(CAN_frame_t stFrame)
{
    /*
    *===========================================================================
    *   Temperatures
    *   Message: Temperatures (0x444)
    *   Description: Node ID: 4 (decimal)
    *   Takes:   stFrame: The CAN frame to decode
    *   Returns: ESP_OK if successful, error code if not.
    *   Autogenerated by decodeCAN.py
    */
    if (stFrame.byDLC != 8) return ESP_ERR_INVALID_SIZE;
    if (stFrame.dwID != 0x444) return ESP_ERR_INVALID_ARG;

    /* Standard Signals */
    Actual_TempController = (float)((((uint16_t)((stFrame.abData[0] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[1] >> 0) & 0xFF))) * 0.1f;
    Actual_TempMotor = (float)((((uint16_t)((stFrame.abData[2] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[3] >> 0) & 0xFF))) * 0.1f;
    Actual_FaultCode = (uint8_t)(((stFrame.abData[4] >> 0) & 0xFF));
    return ESP_OK;
}

esp_err_t TemperaturesTx(twai_node_handle_t stCANBus)
{
    /*
    *===========================================================================
    *   TemperaturesTx
    *   Encodes and Transmits Message: Temperatures (0x444)
    *   Uses global signal variables.
    *   Takes:   stCANBus: Handle to CAN bus to transmit on
    *   Returns: ESP_OK if successful, error code if not.
    */
    CAN_frame_t stFrame;
    stFrame.dwID = 0x444;
    stFrame.byDLC = 8;
    memset(stFrame.abData, 0, 8);

    stFrame.abData[0] |= (uint8_t)(((((uint32_t)(Actual_TempController / 0.1f) & 0xFFFF) >> 8) & 0xFF) << 0);
    stFrame.abData[1] |= (uint8_t)(((((uint32_t)(Actual_TempController / 0.1f) & 0xFFFF) >> 0) & 0xFF) << 0);
    stFrame.abData[2] |= (uint8_t)(((((uint32_t)(Actual_TempMotor / 0.1f) & 0xFFFF) >> 8) & 0xFF) << 0);
    stFrame.abData[3] |= (uint8_t)(((((uint32_t)(Actual_TempMotor / 0.1f) & 0xFFFF) >> 0) & 0xFF) << 0);
    stFrame.abData[4] |= (uint8_t)(((((uint32_t)Actual_FaultCode & 0xFF) >> 0) & 0xFF) << 0);

    return CAN_transmit(stCANBus, &stFrame);
}

esp_err_t FOC(CAN_frame_t stFrame)
{
    /*
    *===========================================================================
    *   FOC
    *   Message: FOC (0x464)
    *   Description: Node ID: 4 (decimal)
    *   Takes:   stFrame: The CAN frame to decode
    *   Returns: ESP_OK if successful, error code if not.
    *   Autogenerated by decodeCAN.py
    */
    if (stFrame.byDLC != 8) return ESP_ERR_INVALID_SIZE;
    if (stFrame.dwID != 0x464) return ESP_ERR_INVALID_ARG;

    /* Standard Signals */
    Actual_FOC_id = (float)((((uint32_t)((stFrame.abData[0] >> 0) & 0xFF)) << 24) | (((uint32_t)((stFrame.abData[1] >> 0) & 0xFF)) << 16) | (((uint32_t)((stFrame.abData[2] >> 0) & 0xFF)) << 8) | ((uint32_t)((stFrame.abData[3] >> 0) & 0xFF))) * 0.01f;
    Actual_FOC_iq = (float)((((uint32_t)((stFrame.abData[4] >> 0) & 0xFF)) << 24) | (((uint32_t)((stFrame.abData[5] >> 0) & 0xFF)) << 16) | (((uint32_t)((stFrame.abData[6] >> 0) & 0xFF)) << 8) | ((uint32_t)((stFrame.abData[7] >> 0) & 0xFF))) * 0.01f;
    return ESP_OK;
}

esp_err_t FOCTx(twai_node_handle_t stCANBus)
{
    /*
    *===========================================================================
    *   FOCTx
    *   Encodes and Transmits Message: FOC (0x464)
    *   Uses global signal variables.
    *   Takes:   stCANBus: Handle to CAN bus to transmit on
    *   Returns: ESP_OK if successful, error code if not.
    */
    CAN_frame_t stFrame;
    stFrame.dwID = 0x464;
    stFrame.byDLC = 8;
    memset(stFrame.abData, 0, 8);

    stFrame.abData[0] |= (uint8_t)(((((uint32_t)(Actual_FOC_id / 0.01f) & 0xFFFFFFFF) >> 24) & 0xFF) << 0);
    stFrame.abData[1] |= (uint8_t)(((((uint32_t)(Actual_FOC_id / 0.01f) & 0xFFFFFFFF) >> 16) & 0xFF) << 0);
    stFrame.abData[2] |= (uint8_t)(((((uint32_t)(Actual_FOC_id / 0.01f) & 0xFFFFFFFF) >> 8) & 0xFF) << 0);
    stFrame.abData[3] |= (uint8_t)(((((uint32_t)(Actual_FOC_id / 0.01f) & 0xFFFFFFFF) >> 0) & 0xFF) << 0);
    stFrame.abData[4] |= (uint8_t)(((((uint32_t)(Actual_FOC_iq / 0.01f) & 0xFFFFFFFF) >> 24) & 0xFF) << 0);
    stFrame.abData[5] |= (uint8_t)(((((uint32_t)(Actual_FOC_iq / 0.01f) & 0xFFFFFFFF) >> 16) & 0xFF) << 0);
    stFrame.abData[6] |= (uint8_t)(((((uint32_t)(Actual_FOC_iq / 0.01f) & 0xFFFFFFFF) >> 8) & 0xFF) << 0);
    stFrame.abData[7] |= (uint8_t)(((((uint32_t)(Actual_FOC_iq / 0.01f) & 0xFFFFFFFF) >> 0) & 0xFF) << 0);

    return CAN_transmit(stCANBus, &stFrame);
}

esp_err_t Inverter_MISC(CAN_frame_t stFrame)
{
    /*
    *===========================================================================
    *   Inverter_MISC
    *   Message: Inverter_MISC (0x484)
    *   Description: Node ID: 4 (decimal)
    *   Takes:   stFrame: The CAN frame to decode
    *   Returns: ESP_OK if successful, error code if not.
    *   Autogenerated by decodeCAN.py
    */
    if (stFrame.byDLC != 8) return ESP_ERR_INVALID_SIZE;
    if (stFrame.dwID != 0x484) return ESP_ERR_INVALID_ARG;

    /* Standard Signals */
    Actual_Throttle = (int8_t)(((stFrame.abData[0] >> 0) & 0xFF));
    Actual_Brake = (int8_t)(((stFrame.abData[1] >> 0) & 0xFF));
    Digital_output_4 = (uint8_t)(((stFrame.abData[2] >> 7) & 0x1));
    Digital_output_3 = (uint8_t)(((stFrame.abData[2] >> 6) & 0x1));
    Digital_output_2 = (uint8_t)(((stFrame.abData[2] >> 5) & 0x1));
    Digital_output_1 = (uint8_t)(((stFrame.abData[2] >> 4) & 0x1));
    Digital_input_4 = (uint8_t)(((stFrame.abData[2] >> 3) & 0x1));
    Digital_input_3 = (uint8_t)(((stFrame.abData[2] >> 2) & 0x1));
    Digital_input_2 = (uint8_t)(((stFrame.abData[2] >> 1) & 0x1));
    Digital_input_1 = (uint8_t)(((stFrame.abData[2] >> 0) & 0x1));
    Drive_enable = (uint8_t)(((stFrame.abData[3] >> 0) & 0xFF));
    Motor_temp_limit = (uint8_t)(((stFrame.abData[4] >> 7) & 0x1));
    Motor_accel_limit = (uint8_t)(((stFrame.abData[4] >> 6) & 0x1));
    Input_voltage_limit = (uint8_t)(((stFrame.abData[4] >> 5) & 0x1));
    IGBT_temp_limit = (uint8_t)(((stFrame.abData[4] >> 4) & 0x1));
    IGBT_accel_limit = (uint8_t)(((stFrame.abData[4] >> 3) & 0x1));
    Drive_enable_limit = (uint8_t)(((stFrame.abData[4] >> 2) & 0x1));
    DC_current_limit = (uint8_t)(((stFrame.abData[4] >> 1) & 0x1));
    Capacitor_temp_limit = (uint8_t)(((stFrame.abData[4] >> 0) & 0x1));
    Power_limit = (uint8_t)(((stFrame.abData[5] >> 2) & 0x1));
    RPM_max_limit = (uint8_t)(((stFrame.abData[5] >> 1) & 0x1));
    RPM_min_limit = (uint8_t)(((stFrame.abData[5] >> 0) & 0x1));
    CAN_map_version = (float)(((stFrame.abData[7] >> 0) & 0xFF)) * 0.1f;
    return ESP_OK;
}

esp_err_t Inverter_MISCTx(twai_node_handle_t stCANBus)
{
    /*
    *===========================================================================
    *   Inverter_MISCTx
    *   Encodes and Transmits Message: Inverter_MISC (0x484)
    *   Uses global signal variables.
    *   Takes:   stCANBus: Handle to CAN bus to transmit on
    *   Returns: ESP_OK if successful, error code if not.
    */
    CAN_frame_t stFrame;
    stFrame.dwID = 0x484;
    stFrame.byDLC = 8;
    memset(stFrame.abData, 0, 8);

    stFrame.abData[0] |= (uint8_t)(((((uint32_t)Actual_Throttle & 0xFF) >> 0) & 0xFF) << 0);
    stFrame.abData[1] |= (uint8_t)(((((uint32_t)Actual_Brake & 0xFF) >> 0) & 0xFF) << 0);
    stFrame.abData[2] |= (uint8_t)(((((uint32_t)Digital_output_4 & 0x1) >> 0) & 0x1) << 7);
    stFrame.abData[2] |= (uint8_t)(((((uint32_t)Digital_output_3 & 0x1) >> 0) & 0x1) << 6);
    stFrame.abData[2] |= (uint8_t)(((((uint32_t)Digital_output_2 & 0x1) >> 0) & 0x1) << 5);
    stFrame.abData[2] |= (uint8_t)(((((uint32_t)Digital_output_1 & 0x1) >> 0) & 0x1) << 4);
    stFrame.abData[2] |= (uint8_t)(((((uint32_t)Digital_input_4 & 0x1) >> 0) & 0x1) << 3);
    stFrame.abData[2] |= (uint8_t)(((((uint32_t)Digital_input_3 & 0x1) >> 0) & 0x1) << 2);
    stFrame.abData[2] |= (uint8_t)(((((uint32_t)Digital_input_2 & 0x1) >> 0) & 0x1) << 1);
    stFrame.abData[2] |= (uint8_t)(((((uint32_t)Digital_input_1 & 0x1) >> 0) & 0x1) << 0);
    stFrame.abData[3] |= (uint8_t)(((((uint32_t)Drive_enable & 0xFF) >> 0) & 0xFF) << 0);
    stFrame.abData[4] |= (uint8_t)(((((uint32_t)Motor_temp_limit & 0x1) >> 0) & 0x1) << 7);
    stFrame.abData[4] |= (uint8_t)(((((uint32_t)Motor_accel_limit & 0x1) >> 0) & 0x1) << 6);
    stFrame.abData[4] |= (uint8_t)(((((uint32_t)Input_voltage_limit & 0x1) >> 0) & 0x1) << 5);
    stFrame.abData[4] |= (uint8_t)(((((uint32_t)IGBT_temp_limit & 0x1) >> 0) & 0x1) << 4);
    stFrame.abData[4] |= (uint8_t)(((((uint32_t)IGBT_accel_limit & 0x1) >> 0) & 0x1) << 3);
    stFrame.abData[4] |= (uint8_t)(((((uint32_t)Drive_enable_limit & 0x1) >> 0) & 0x1) << 2);
    stFrame.abData[4] |= (uint8_t)(((((uint32_t)DC_current_limit & 0x1) >> 0) & 0x1) << 1);
    stFrame.abData[4] |= (uint8_t)(((((uint32_t)Capacitor_temp_limit & 0x1) >> 0) & 0x1) << 0);
    stFrame.abData[5] |= (uint8_t)(((((uint32_t)Power_limit & 0x1) >> 0) & 0x1) << 2);
    stFrame.abData[5] |= (uint8_t)(((((uint32_t)RPM_max_limit & 0x1) >> 0) & 0x1) << 1);
    stFrame.abData[5] |= (uint8_t)(((((uint32_t)RPM_min_limit & 0x1) >> 0) & 0x1) << 0);
    stFrame.abData[7] |= (uint8_t)(((((uint32_t)(CAN_map_version / 0.1f) & 0xFF) >> 0) & 0xFF) << 0);

    return CAN_transmit(stCANBus, &stFrame);
}

esp_err_t MinMaxAcCurrent(CAN_frame_t stFrame)
{
    /*
    *===========================================================================
    *   MinMaxAcCurrent
    *   Message: MinMaxAcCurrent (0x4A4)
    *   Description: Node ID: 4 (decimal)
    *   Takes:   stFrame: The CAN frame to decode
    *   Returns: ESP_OK if successful, error code if not.
    *   Autogenerated by decodeCAN.py
    */
    if (stFrame.byDLC != 8) return ESP_ERR_INVALID_SIZE;
    if (stFrame.dwID != 0x4A4) return ESP_ERR_INVALID_ARG;

    /* Standard Signals */
    MaxAcCurrent = (float)((((uint16_t)((stFrame.abData[0] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[1] >> 0) & 0xFF))) * 0.1f;
    AvailableMaxAcCurrent = (float)((((uint16_t)((stFrame.abData[2] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[3] >> 0) & 0xFF))) * 0.1f;
    MinAcCurrent = (float)((((uint16_t)((stFrame.abData[4] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[5] >> 0) & 0xFF))) * 0.1f;
    AvailableMinAcCurrent = (float)((((uint16_t)((stFrame.abData[6] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[7] >> 0) & 0xFF))) * 0.1f;
    return ESP_OK;
}

esp_err_t MinMaxAcCurrentTx(twai_node_handle_t stCANBus)
{
    /*
    *===========================================================================
    *   MinMaxAcCurrentTx
    *   Encodes and Transmits Message: MinMaxAcCurrent (0x4A4)
    *   Uses global signal variables.
    *   Takes:   stCANBus: Handle to CAN bus to transmit on
    *   Returns: ESP_OK if successful, error code if not.
    */
    CAN_frame_t stFrame;
    stFrame.dwID = 0x4A4;
    stFrame.byDLC = 8;
    memset(stFrame.abData, 0, 8);

    stFrame.abData[0] |= (uint8_t)(((((uint32_t)(MaxAcCurrent / 0.1f) & 0xFFFF) >> 8) & 0xFF) << 0);
    stFrame.abData[1] |= (uint8_t)(((((uint32_t)(MaxAcCurrent / 0.1f) & 0xFFFF) >> 0) & 0xFF) << 0);
    stFrame.abData[2] |= (uint8_t)(((((uint32_t)(AvailableMaxAcCurrent / 0.1f) & 0xFFFF) >> 8) & 0xFF) << 0);
    stFrame.abData[3] |= (uint8_t)(((((uint32_t)(AvailableMaxAcCurrent / 0.1f) & 0xFFFF) >> 0) & 0xFF) << 0);
    stFrame.abData[4] |= (uint8_t)(((((uint32_t)(MinAcCurrent / 0.1f) & 0xFFFF) >> 8) & 0xFF) << 0);
    stFrame.abData[5] |= (uint8_t)(((((uint32_t)(MinAcCurrent / 0.1f) & 0xFFFF) >> 0) & 0xFF) << 0);
    stFrame.abData[6] |= (uint8_t)(((((uint32_t)(AvailableMinAcCurrent / 0.1f) & 0xFFFF) >> 8) & 0xFF) << 0);
    stFrame.abData[7] |= (uint8_t)(((((uint32_t)(AvailableMinAcCurrent / 0.1f) & 0xFFFF) >> 0) & 0xFF) << 0);

    return CAN_transmit(stCANBus, &stFrame);
}

esp_err_t MinMaxDcCurrent(CAN_frame_t stFrame)
{
    /*
    *===========================================================================
    *   MinMaxDcCurrent
    *   Message: MinMaxDcCurrent (0x4C4)
    *   Description: Node ID: 4 (decimal)
    *   Takes:   stFrame: The CAN frame to decode
    *   Returns: ESP_OK if successful, error code if not.
    *   Autogenerated by decodeCAN.py
    */
    if (stFrame.byDLC != 8) return ESP_ERR_INVALID_SIZE;
    if (stFrame.dwID != 0x4C4) return ESP_ERR_INVALID_ARG;

    /* Standard Signals */
    MaxDcCurrent = (float)((((uint16_t)((stFrame.abData[0] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[1] >> 0) & 0xFF))) * 0.1f;
    AvailableMaxDcCurrent = (float)((((uint16_t)((stFrame.abData[2] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[3] >> 0) & 0xFF))) * 0.1f;
    MinDcCurrent = (float)((((uint16_t)((stFrame.abData[4] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[5] >> 0) & 0xFF))) * 0.1f;
    AvailableMinDcCurrent = (float)((((uint16_t)((stFrame.abData[6] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[7] >> 0) & 0xFF))) * 0.1f;
    return ESP_OK;
}

esp_err_t MinMaxDcCurrentTx(twai_node_handle_t stCANBus)
{
    /*
    *===========================================================================
    *   MinMaxDcCurrentTx
    *   Encodes and Transmits Message: MinMaxDcCurrent (0x4C4)
    *   Uses global signal variables.
    *   Takes:   stCANBus: Handle to CAN bus to transmit on
    *   Returns: ESP_OK if successful, error code if not.
    */
    CAN_frame_t stFrame;
    stFrame.dwID = 0x4C4;
    stFrame.byDLC = 8;
    memset(stFrame.abData, 0, 8);

    stFrame.abData[0] |= (uint8_t)(((((uint32_t)(MaxDcCurrent / 0.1f) & 0xFFFF) >> 8) & 0xFF) << 0);
    stFrame.abData[1] |= (uint8_t)(((((uint32_t)(MaxDcCurrent / 0.1f) & 0xFFFF) >> 0) & 0xFF) << 0);
    stFrame.abData[2] |= (uint8_t)(((((uint32_t)(AvailableMaxDcCurrent / 0.1f) & 0xFFFF) >> 8) & 0xFF) << 0);
    stFrame.abData[3] |= (uint8_t)(((((uint32_t)(AvailableMaxDcCurrent / 0.1f) & 0xFFFF) >> 0) & 0xFF) << 0);
    stFrame.abData[4] |= (uint8_t)(((((uint32_t)(MinDcCurrent / 0.1f) & 0xFFFF) >> 8) & 0xFF) << 0);
    stFrame.abData[5] |= (uint8_t)(((((uint32_t)(MinDcCurrent / 0.1f) & 0xFFFF) >> 0) & 0xFF) << 0);
    stFrame.abData[6] |= (uint8_t)(((((uint32_t)(AvailableMinDcCurrent / 0.1f) & 0xFFFF) >> 8) & 0xFF) << 0);
    stFrame.abData[7] |= (uint8_t)(((((uint32_t)(AvailableMinDcCurrent / 0.1f) & 0xFFFF) >> 0) & 0xFF) << 0);

    return CAN_transmit(stCANBus, &stFrame);
}

esp_err_t CellStats1(CAN_frame_t stFrame)
{
    /*
    *===========================================================================
    *   CellStats1
    *   Message: CellStats1 (0x6B0)
    *   Description: Cell Statistics
    *   Takes:   stFrame: The CAN frame to decode
    *   Returns: ESP_OK if successful, error code if not.
    *   Autogenerated by decodeCAN.py
    */
    if (stFrame.byDLC != 8) return ESP_ERR_INVALID_SIZE;
    if (stFrame.dwID != 0x6B0) return ESP_ERR_INVALID_ARG;

    /* Standard Signals */
    Pack_Current = (float)((((uint16_t)((stFrame.abData[0] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[1] >> 0) & 0xFF))) * 0.1f;
    Pack_Inst_Voltage = (float)((((uint16_t)((stFrame.abData[2] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[3] >> 0) & 0xFF))) * 0.1f;
    Pack_SOC = (float)(((stFrame.abData[4] >> 0) & 0xFF)) * 0.5f;
    Pack_Resistance = (float)((((uint16_t)((stFrame.abData[5] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[6] >> 0) & 0xFF))) * 0.001f;
    CheckSum_CellStats1 = (float)(((stFrame.abData[7] >> 0) & 0xFF)) + 1720.0f;
    return ESP_OK;
}

esp_err_t CellStats1Tx(twai_node_handle_t stCANBus)
{
    /*
    *===========================================================================
    *   CellStats1Tx
    *   Encodes and Transmits Message: CellStats1 (0x6B0)
    *   Uses global signal variables.
    *   Takes:   stCANBus: Handle to CAN bus to transmit on
    *   Returns: ESP_OK if successful, error code if not.
    */
    CAN_frame_t stFrame;
    stFrame.dwID = 0x6B0;
    stFrame.byDLC = 8;
    memset(stFrame.abData, 0, 8);

    stFrame.abData[0] |= (uint8_t)(((((uint32_t)(Pack_Current / 0.1f) & 0xFFFF) >> 8) & 0xFF) << 0);
    stFrame.abData[1] |= (uint8_t)(((((uint32_t)(Pack_Current / 0.1f) & 0xFFFF) >> 0) & 0xFF) << 0);
    stFrame.abData[2] |= (uint8_t)(((((uint32_t)(Pack_Inst_Voltage / 0.1f) & 0xFFFF) >> 8) & 0xFF) << 0);
    stFrame.abData[3] |= (uint8_t)(((((uint32_t)(Pack_Inst_Voltage / 0.1f) & 0xFFFF) >> 0) & 0xFF) << 0);
    stFrame.abData[4] |= (uint8_t)(((((uint32_t)(Pack_SOC / 0.5f) & 0xFF) >> 0) & 0xFF) << 0);
    stFrame.abData[5] |= (uint8_t)(((((uint32_t)(Pack_Resistance / 0.001f) & 0xFFFF) >> 8) & 0xFF) << 0);
    stFrame.abData[6] |= (uint8_t)(((((uint32_t)(Pack_Resistance / 0.001f) & 0xFFFF) >> 0) & 0xFF) << 0);
    stFrame.abData[7] |= (uint8_t)(((((uint32_t)(CheckSum_CellStats1 - 1720.0f) & 0xFF) >> 0) & 0xFF) << 0);

    return CAN_transmit(stCANBus, &stFrame);
}

esp_err_t CellStats2(CAN_frame_t stFrame)
{
    /*
    *===========================================================================
    *   CellStats2
    *   Message: CellStats2 (0x6B1)
    *   Description: Cell Statistics
    *   Takes:   stFrame: The CAN frame to decode
    *   Returns: ESP_OK if successful, error code if not.
    *   Autogenerated by decodeCAN.py
    */
    if (stFrame.byDLC != 8) return ESP_ERR_INVALID_SIZE;
    if (stFrame.dwID != 0x6B1) return ESP_ERR_INVALID_ARG;

    /* Standard Signals */
    Pack_CCL_0 = (float)((((uint16_t)((stFrame.abData[0] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[1] >> 0) & 0xFF))) * 4.0f;
    Pack_DCL = (float)((((uint16_t)((stFrame.abData[2] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[3] >> 0) & 0xFF))) * 4.0f;
    Pack_DOD = (float)((((uint16_t)((stFrame.abData[4] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[5] >> 0) & 0xFF))) * 2.0f;
    Pack_Open_Voltage = (float)((((uint16_t)((stFrame.abData[6] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[7] >> 0) & 0xFF))) * 0.1f;
    return ESP_OK;
}

esp_err_t CellStats2Tx(twai_node_handle_t stCANBus)
{
    /*
    *===========================================================================
    *   CellStats2Tx
    *   Encodes and Transmits Message: CellStats2 (0x6B1)
    *   Uses global signal variables.
    *   Takes:   stCANBus: Handle to CAN bus to transmit on
    *   Returns: ESP_OK if successful, error code if not.
    */
    CAN_frame_t stFrame;
    stFrame.dwID = 0x6B1;
    stFrame.byDLC = 8;
    memset(stFrame.abData, 0, 8);

    stFrame.abData[0] |= (uint8_t)(((((uint32_t)(Pack_CCL_0 / 4.0f) & 0xFFFF) >> 8) & 0xFF) << 0);
    stFrame.abData[1] |= (uint8_t)(((((uint32_t)(Pack_CCL_0 / 4.0f) & 0xFFFF) >> 0) & 0xFF) << 0);
    stFrame.abData[2] |= (uint8_t)(((((uint32_t)(Pack_DCL / 4.0f) & 0xFFFF) >> 8) & 0xFF) << 0);
    stFrame.abData[3] |= (uint8_t)(((((uint32_t)(Pack_DCL / 4.0f) & 0xFFFF) >> 0) & 0xFF) << 0);
    stFrame.abData[4] |= (uint8_t)(((((uint32_t)(Pack_DOD / 2.0f) & 0xFFFF) >> 8) & 0xFF) << 0);
    stFrame.abData[5] |= (uint8_t)(((((uint32_t)(Pack_DOD / 2.0f) & 0xFFFF) >> 0) & 0xFF) << 0);
    stFrame.abData[6] |= (uint8_t)(((((uint32_t)(Pack_Open_Voltage / 0.1f) & 0xFFFF) >> 8) & 0xFF) << 0);
    stFrame.abData[7] |= (uint8_t)(((((uint32_t)(Pack_Open_Voltage / 0.1f) & 0xFFFF) >> 0) & 0xFF) << 0);

    return CAN_transmit(stCANBus, &stFrame);
}

esp_err_t CellStats3(CAN_frame_t stFrame)
{
    /*
    *===========================================================================
    *   CellStats3
    *   Message: CellStats3 (0x6B2)
    *   Description: Cell Statistics
    *   Takes:   stFrame: The CAN frame to decode
    *   Returns: ESP_OK if successful, error code if not.
    *   Autogenerated by decodeCAN.py
    */
    if (stFrame.byDLC != 8) return ESP_ERR_INVALID_SIZE;
    if (stFrame.dwID != 0x6B2) return ESP_ERR_INVALID_ARG;

    /* Standard Signals */
    Maximum_Pack_Voltage_0 = (float)((((uint16_t)((stFrame.abData[0] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[1] >> 0) & 0xFF))) * 0.1f;
    Minimum_Pack_Voltage = (float)((((uint16_t)((stFrame.abData[2] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[3] >> 0) & 0xFF))) * 0.1f;
    High_Cell_Voltage = (float)(((stFrame.abData[4] >> 0) & 0xFF)) * 0.01f + 200.0f;
    Avg_Cell_Voltage = (float)(((stFrame.abData[5] >> 0) & 0xFF)) * 0.01f + 200.0f;
    Low_Cell_Voltage = (float)(((stFrame.abData[6] >> 0) & 0xFF)) * 0.01f + 200.0f;
    High_Cell_Voltage_ID = (uint8_t)(((stFrame.abData[7] >> 0) & 0xFF));
    return ESP_OK;
}

esp_err_t CellStats3Tx(twai_node_handle_t stCANBus)
{
    /*
    *===========================================================================
    *   CellStats3Tx
    *   Encodes and Transmits Message: CellStats3 (0x6B2)
    *   Uses global signal variables.
    *   Takes:   stCANBus: Handle to CAN bus to transmit on
    *   Returns: ESP_OK if successful, error code if not.
    */
    CAN_frame_t stFrame;
    stFrame.dwID = 0x6B2;
    stFrame.byDLC = 8;
    memset(stFrame.abData, 0, 8);

    stFrame.abData[0] |= (uint8_t)(((((uint32_t)(Maximum_Pack_Voltage_0 / 0.1f) & 0xFFFF) >> 8) & 0xFF) << 0);
    stFrame.abData[1] |= (uint8_t)(((((uint32_t)(Maximum_Pack_Voltage_0 / 0.1f) & 0xFFFF) >> 0) & 0xFF) << 0);
    stFrame.abData[2] |= (uint8_t)(((((uint32_t)(Minimum_Pack_Voltage / 0.1f) & 0xFFFF) >> 8) & 0xFF) << 0);
    stFrame.abData[3] |= (uint8_t)(((((uint32_t)(Minimum_Pack_Voltage / 0.1f) & 0xFFFF) >> 0) & 0xFF) << 0);
    stFrame.abData[4] |= (uint8_t)(((((uint32_t)((High_Cell_Voltage - 200.0f) / 0.01f) & 0xFF) >> 0) & 0xFF) << 0);
    stFrame.abData[5] |= (uint8_t)(((((uint32_t)((Avg_Cell_Voltage - 200.0f) / 0.01f) & 0xFF) >> 0) & 0xFF) << 0);
    stFrame.abData[6] |= (uint8_t)(((((uint32_t)((Low_Cell_Voltage - 200.0f) / 0.01f) & 0xFF) >> 0) & 0xFF) << 0);
    stFrame.abData[7] |= (uint8_t)(((((uint32_t)High_Cell_Voltage_ID & 0xFF) >> 0) & 0xFF) << 0);

    return CAN_transmit(stCANBus, &stFrame);
}

esp_err_t CellStats4(CAN_frame_t stFrame)
{
    /*
    *===========================================================================
    *   CellStats4
    *   Message: CellStats4 (0x6B3)
    *   Description: Cell Statistics
    *   Takes:   stFrame: The CAN frame to decode
    *   Returns: ESP_OK if successful, error code if not.
    *   Autogenerated by decodeCAN.py
    */
    if (stFrame.byDLC != 8) return ESP_ERR_INVALID_SIZE;
    if (stFrame.dwID != 0x6B3) return ESP_ERR_INVALID_ARG;

    /* Standard Signals */
    Low_Cell_Voltage_ID = (uint8_t)(((stFrame.abData[0] >> 0) & 0xFF));
    High_Opencell_Voltage = (float)(((stFrame.abData[1] >> 0) & 0xFF)) * 0.01f + 200.0f;
    Avg_Opencell_Voltage = (float)(((stFrame.abData[2] >> 0) & 0xFF)) * 0.01f + 200.0f;
    Low_Opencell_Voltage = (float)(((stFrame.abData[3] >> 0) & 0xFF)) * 0.01f + 200.0f;
    High_Opencell_ID = (uint8_t)(((stFrame.abData[4] >> 0) & 0xFF));
    Low_Opencell_ID = (uint8_t)(((stFrame.abData[5] >> 0) & 0xFF));
    High_Cell_Resistance = (float)((((uint16_t)((stFrame.abData[6] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[7] >> 0) & 0xFF))) * 0.01f;
    return ESP_OK;
}

esp_err_t CellStats4Tx(twai_node_handle_t stCANBus)
{
    /*
    *===========================================================================
    *   CellStats4Tx
    *   Encodes and Transmits Message: CellStats4 (0x6B3)
    *   Uses global signal variables.
    *   Takes:   stCANBus: Handle to CAN bus to transmit on
    *   Returns: ESP_OK if successful, error code if not.
    */
    CAN_frame_t stFrame;
    stFrame.dwID = 0x6B3;
    stFrame.byDLC = 8;
    memset(stFrame.abData, 0, 8);

    stFrame.abData[0] |= (uint8_t)(((((uint32_t)Low_Cell_Voltage_ID & 0xFF) >> 0) & 0xFF) << 0);
    stFrame.abData[1] |= (uint8_t)(((((uint32_t)((High_Opencell_Voltage - 200.0f) / 0.01f) & 0xFF) >> 0) & 0xFF) << 0);
    stFrame.abData[2] |= (uint8_t)(((((uint32_t)((Avg_Opencell_Voltage - 200.0f) / 0.01f) & 0xFF) >> 0) & 0xFF) << 0);
    stFrame.abData[3] |= (uint8_t)(((((uint32_t)((Low_Opencell_Voltage - 200.0f) / 0.01f) & 0xFF) >> 0) & 0xFF) << 0);
    stFrame.abData[4] |= (uint8_t)(((((uint32_t)High_Opencell_ID & 0xFF) >> 0) & 0xFF) << 0);
    stFrame.abData[5] |= (uint8_t)(((((uint32_t)Low_Opencell_ID & 0xFF) >> 0) & 0xFF) << 0);
    stFrame.abData[6] |= (uint8_t)(((((uint32_t)(High_Cell_Resistance / 0.01f) & 0xFFFF) >> 8) & 0xFF) << 0);
    stFrame.abData[7] |= (uint8_t)(((((uint32_t)(High_Cell_Resistance / 0.01f) & 0xFFFF) >> 0) & 0xFF) << 0);

    return CAN_transmit(stCANBus, &stFrame);
}

esp_err_t CellStats5(CAN_frame_t stFrame)
{
    /*
    *===========================================================================
    *   CellStats5
    *   Message: CellStats5 (0x6B4)
    *   Description: Cell Statistics
    *   Takes:   stFrame: The CAN frame to decode
    *   Returns: ESP_OK if successful, error code if not.
    *   Autogenerated by decodeCAN.py
    */
    if (stFrame.byDLC != 8) return ESP_ERR_INVALID_SIZE;
    if (stFrame.dwID != 0x6B4) return ESP_ERR_INVALID_ARG;

    /* Standard Signals */
    Avg_Cell_Resistance = (float)((((uint16_t)((stFrame.abData[0] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[1] >> 0) & 0xFF))) * 0.01f;
    Low_Cell_Resistance = (float)((((uint16_t)((stFrame.abData[2] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[3] >> 0) & 0xFF))) * 0.01f;
    High_Intres_ID = (uint8_t)(((stFrame.abData[4] >> 0) & 0xFF));
    Low_Intres_ID = (uint8_t)(((stFrame.abData[5] >> 0) & 0xFF));
    return ESP_OK;
}

esp_err_t CellStats5Tx(twai_node_handle_t stCANBus)
{
    /*
    *===========================================================================
    *   CellStats5Tx
    *   Encodes and Transmits Message: CellStats5 (0x6B4)
    *   Uses global signal variables.
    *   Takes:   stCANBus: Handle to CAN bus to transmit on
    *   Returns: ESP_OK if successful, error code if not.
    */
    CAN_frame_t stFrame;
    stFrame.dwID = 0x6B4;
    stFrame.byDLC = 8;
    memset(stFrame.abData, 0, 8);

    stFrame.abData[0] |= (uint8_t)(((((uint32_t)(Avg_Cell_Resistance / 0.01f) & 0xFFFF) >> 8) & 0xFF) << 0);
    stFrame.abData[1] |= (uint8_t)(((((uint32_t)(Avg_Cell_Resistance / 0.01f) & 0xFFFF) >> 0) & 0xFF) << 0);
    stFrame.abData[2] |= (uint8_t)(((((uint32_t)(Low_Cell_Resistance / 0.01f) & 0xFFFF) >> 8) & 0xFF) << 0);
    stFrame.abData[3] |= (uint8_t)(((((uint32_t)(Low_Cell_Resistance / 0.01f) & 0xFFFF) >> 0) & 0xFF) << 0);
    stFrame.abData[4] |= (uint8_t)(((((uint32_t)High_Intres_ID & 0xFF) >> 0) & 0xFF) << 0);
    stFrame.abData[5] |= (uint8_t)(((((uint32_t)Low_Intres_ID & 0xFF) >> 0) & 0xFF) << 0);

    return CAN_transmit(stCANBus, &stFrame);
}

esp_err_t ElconInterface2(CAN_frame_t stFrame)
{
    /*
    *===========================================================================
    *   ElconInterface2
    *   Message: ElconInterface2 (0x1806E5F4)
    *   Description: Elcon Charger to BMS Interface
    *   Takes:   stFrame: The CAN frame to decode
    *   Returns: ESP_OK if successful, error code if not.
    *   Autogenerated by decodeCAN.py
    */
    if (stFrame.byDLC != 8) return ESP_ERR_INVALID_SIZE;
    if (stFrame.dwID != 0x1806E5F4) return ESP_ERR_INVALID_ARG;

    /* Standard Signals */
    Maximum_Cell_Voltage_0 = (float)((((uint16_t)((stFrame.abData[0] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[1] >> 0) & 0xFF))) * 0.1f;
    Pack_CCL_2 = (float)((((uint16_t)((stFrame.abData[2] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[3] >> 0) & 0xFF))) * 0.1f;
    DTC_P0A08_Charger_Safety_Relay_Fault_1 = (uint8_t)(((stFrame.abData[4] >> 0) & 0x1));
    return ESP_OK;
}

esp_err_t ElconInterface2Tx(twai_node_handle_t stCANBus)
{
    /*
    *===========================================================================
    *   ElconInterface2Tx
    *   Encodes and Transmits Message: ElconInterface2 (0x1806E5F4)
    *   Uses global signal variables.
    *   Takes:   stCANBus: Handle to CAN bus to transmit on
    *   Returns: ESP_OK if successful, error code if not.
    */
    CAN_frame_t stFrame;
    stFrame.dwID = 0x1806E5F4;
    stFrame.byDLC = 8;
    memset(stFrame.abData, 0, 8);

    stFrame.abData[0] |= (uint8_t)(((((uint32_t)(Maximum_Cell_Voltage_0 / 0.1f) & 0xFFFF) >> 8) & 0xFF) << 0);
    stFrame.abData[1] |= (uint8_t)(((((uint32_t)(Maximum_Cell_Voltage_0 / 0.1f) & 0xFFFF) >> 0) & 0xFF) << 0);
    stFrame.abData[2] |= (uint8_t)(((((uint32_t)(Pack_CCL_2 / 0.1f) & 0xFFFF) >> 8) & 0xFF) << 0);
    stFrame.abData[3] |= (uint8_t)(((((uint32_t)(Pack_CCL_2 / 0.1f) & 0xFFFF) >> 0) & 0xFF) << 0);
    stFrame.abData[4] |= (uint8_t)(((((uint32_t)DTC_P0A08_Charger_Safety_Relay_Fault_1 & 0x1) >> 0) & 0x1) << 0);

    return CAN_transmit(stCANBus, &stFrame);
}

esp_err_t ElconInterface1(CAN_frame_t stFrame)
{
    /*
    *===========================================================================
    *   ElconInterface1
    *   Message: ElconInterface1 (0x1806E7F4)
    *   Description: Elcon Charger to BMS Interface
    *   Takes:   stFrame: The CAN frame to decode
    *   Returns: ESP_OK if successful, error code if not.
    *   Autogenerated by decodeCAN.py
    */
    if (stFrame.byDLC != 8) return ESP_ERR_INVALID_SIZE;
    if (stFrame.dwID != 0x1806E7F4) return ESP_ERR_INVALID_ARG;

    /* Standard Signals */
    Maximum_Pack_Voltage_1 = (float)((((uint16_t)((stFrame.abData[0] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[1] >> 0) & 0xFF))) * 0.1f;
    Pack_CCL_1 = (float)((((uint16_t)((stFrame.abData[2] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[3] >> 0) & 0xFF))) * 0.1f;
    DTC_P0A08_Charger_Safety_Relay_Fault_0 = (uint8_t)(((stFrame.abData[4] >> 0) & 0x1));
    return ESP_OK;
}

esp_err_t ElconInterface1Tx(twai_node_handle_t stCANBus)
{
    /*
    *===========================================================================
    *   ElconInterface1Tx
    *   Encodes and Transmits Message: ElconInterface1 (0x1806E7F4)
    *   Uses global signal variables.
    *   Takes:   stCANBus: Handle to CAN bus to transmit on
    *   Returns: ESP_OK if successful, error code if not.
    */
    CAN_frame_t stFrame;
    stFrame.dwID = 0x1806E7F4;
    stFrame.byDLC = 8;
    memset(stFrame.abData, 0, 8);

    stFrame.abData[0] |= (uint8_t)(((((uint32_t)(Maximum_Pack_Voltage_1 / 0.1f) & 0xFFFF) >> 8) & 0xFF) << 0);
    stFrame.abData[1] |= (uint8_t)(((((uint32_t)(Maximum_Pack_Voltage_1 / 0.1f) & 0xFFFF) >> 0) & 0xFF) << 0);
    stFrame.abData[2] |= (uint8_t)(((((uint32_t)(Pack_CCL_1 / 0.1f) & 0xFFFF) >> 8) & 0xFF) << 0);
    stFrame.abData[3] |= (uint8_t)(((((uint32_t)(Pack_CCL_1 / 0.1f) & 0xFFFF) >> 0) & 0xFF) << 0);
    stFrame.abData[4] |= (uint8_t)(((((uint32_t)DTC_P0A08_Charger_Safety_Relay_Fault_0 & 0x1) >> 0) & 0x1) << 0);

    return CAN_transmit(stCANBus, &stFrame);
}

esp_err_t ElconInterface3(CAN_frame_t stFrame)
{
    /*
    *===========================================================================
    *   ElconInterface3
    *   Message: ElconInterface3 (0x1806E9F4)
    *   Description: Elcon Charger to BMS Interface
    *   Takes:   stFrame: The CAN frame to decode
    *   Returns: ESP_OK if successful, error code if not.
    *   Autogenerated by decodeCAN.py
    */
    if (stFrame.byDLC != 8) return ESP_ERR_INVALID_SIZE;
    if (stFrame.dwID != 0x1806E9F4) return ESP_ERR_INVALID_ARG;

    /* Standard Signals */
    Maximum_Cell_Voltage_1 = (float)((((uint16_t)((stFrame.abData[0] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[1] >> 0) & 0xFF))) * 0.1f;
    Pack_CCL_3 = (float)((((uint16_t)((stFrame.abData[2] >> 0) & 0xFF)) << 8) | ((uint16_t)((stFrame.abData[3] >> 0) & 0xFF))) * 0.1f;
    DTC_P0A08_Charger_Safety_Relay_Fault_2 = (uint8_t)(((stFrame.abData[4] >> 0) & 0x1));
    return ESP_OK;
}

esp_err_t ElconInterface3Tx(twai_node_handle_t stCANBus)
{
    /*
    *===========================================================================
    *   ElconInterface3Tx
    *   Encodes and Transmits Message: ElconInterface3 (0x1806E9F4)
    *   Uses global signal variables.
    *   Takes:   stCANBus: Handle to CAN bus to transmit on
    *   Returns: ESP_OK if successful, error code if not.
    */
    CAN_frame_t stFrame;
    stFrame.dwID = 0x1806E9F4;
    stFrame.byDLC = 8;
    memset(stFrame.abData, 0, 8);

    stFrame.abData[0] |= (uint8_t)(((((uint32_t)(Maximum_Cell_Voltage_1 / 0.1f) & 0xFFFF) >> 8) & 0xFF) << 0);
    stFrame.abData[1] |= (uint8_t)(((((uint32_t)(Maximum_Cell_Voltage_1 / 0.1f) & 0xFFFF) >> 0) & 0xFF) << 0);
    stFrame.abData[2] |= (uint8_t)(((((uint32_t)(Pack_CCL_3 / 0.1f) & 0xFFFF) >> 8) & 0xFF) << 0);
    stFrame.abData[3] |= (uint8_t)(((((uint32_t)(Pack_CCL_3 / 0.1f) & 0xFFFF) >> 0) & 0xFF) << 0);
    stFrame.abData[4] |= (uint8_t)(((((uint32_t)DTC_P0A08_Charger_Safety_Relay_Fault_2 & 0x1) >> 0) & 0x1) << 0);

    return CAN_transmit(stCANBus, &stFrame);
}

