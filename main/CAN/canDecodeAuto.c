/* This file is autogenerated from the script decodeCAN.py */
#include "canDecodeAuto.h"

esp_err_t ESPControl(CAN_frame_t stFrame, uint8_t* BRestart, uint8_t* BClearMinMax, uint8_t* BClearErrors)
{
    /*
    *===========================================================================
    *   ESPControl
    *   Message: ESPControl (0x10)
    *   Description: ESP Control Message
    *   Takes:   stFrame: The CAN frame to decode
    *            BRestart: Restart all MCUs
    *            BClearMinMax: Clear Min/ Max Recorded Values
    *            BClearErrors: Clear Any Latched Values
    * 
    *   Returns: ESP_OK if successful, error code if not.
    * 
    *   Autogenerated by decodeCAN.py
    */
    if (stFrame.byDLC != 8)
    {
        return ESP_ERR_INVALID_SIZE;
    }
    if (stFrame.dwID != 0x10) 
    {
        return ESP_ERR_INVALID_ARG;
    }
    *BRestart = (uint8_t)(((stFrame.abData[0]) & 0x1));
    *BClearMinMax = (uint8_t)(((stFrame.abData[0] >> 1) & 0x1));
    *BClearErrors = (uint8_t)(((stFrame.abData[0] >> 2) & 0x1));
    return ESP_OK;
}

esp_err_t MCUStatusTelemCar(CAN_frame_t stFrame, float* tLastTaskTime1ms, float* tMaxTaskTime1ms, float* tLastTaskTime100ms, float* tMaxTaskTime100ms, float* tLastTaskTimeBG, float* tMaxTaskTimeBG, float* tSincePowerUp, uint8_t* NLastResetReason)
{
    /*
    *===========================================================================
    *   MCUStatusTelemCar
    *   Message: MCUStatusTelemCar (0x11)
    *   Description: MCU Status Message
    *   Takes:   stFrame: The CAN frame to decode
    *            tLastTaskTime1ms: MCU 1ms Last Task Time
    *            tMaxTaskTime1ms: MCU 1ms Max Task Time
    *            tLastTaskTime100ms: MCU 100ms Last Task Time
    *            tMaxTaskTime100ms: MCU 100ms Max Task Time
    *            tLastTaskTimeBG: MCU Background Last Task Time
    *            tMaxTaskTimeBG: MCU Background Max Task Time
    *            tSincePowerUp: MCU time since power up
    *            NLastResetReason: MCU Last Reset Reason
    * 
    *   Returns: ESP_OK if successful, error code if not.
    * 
    *   Autogenerated by decodeCAN.py
    */
    if (stFrame.byDLC != 8)
    {
        return ESP_ERR_INVALID_SIZE;
    }
    if (stFrame.dwID != 0x11) 
    {
        return ESP_ERR_INVALID_ARG;
    }
    *tLastTaskTime1ms = (float)((stFrame.abData[0])) * 50.0f;
    *tMaxTaskTime1ms = (float)((stFrame.abData[1])) * 50.0f;
    *tLastTaskTime100ms = (float)((stFrame.abData[2])) * 500.0f;
    *tMaxTaskTime100ms = (float)((stFrame.abData[3])) * 500.0f;
    *tLastTaskTimeBG = (float)((stFrame.abData[4])) * 500.0f;
    *tMaxTaskTimeBG = (float)((stFrame.abData[5])) * 500.0f;
    *tSincePowerUp = (float)((((uint16_t)(stFrame.abData[6])) << 4) | ((uint16_t)((stFrame.abData[7]) & 0xF))) * 4.0f;
    *NLastResetReason = (uint8_t)(((stFrame.abData[7] >> 4) & 0xF));
    return ESP_OK;
}

esp_err_t MCUStatusTelemPits(CAN_frame_t stFrame, float* tLastTaskTime1ms, float* tMaxTaskTime1ms, float* tLastTaskTime100ms, float* tMaxTaskTime100ms, float* tLastTaskTimeBG, float* tMaxTaskTimeBG, float* tSincePowerUp, uint8_t* NLastResetReason)
{
    /*
    *===========================================================================
    *   MCUStatusTelemPits
    *   Message: MCUStatusTelemPits (0x12)
    *   Description: MCU Status Message
    *   Takes:   stFrame: The CAN frame to decode
    *            tLastTaskTime1ms: MCU 1ms Last Task Time
    *            tMaxTaskTime1ms: MCU 1ms Max Task Time
    *            tLastTaskTime100ms: MCU 100ms Last Task Time
    *            tMaxTaskTime100ms: MCU 100ms Max Task Time
    *            tLastTaskTimeBG: MCU Background Last Task Time
    *            tMaxTaskTimeBG: MCU Background Max Task Time
    *            tSincePowerUp: MCU time since power up
    *            NLastResetReason: MCU Last Reset Reason
    * 
    *   Returns: ESP_OK if successful, error code if not.
    * 
    *   Autogenerated by decodeCAN.py
    */
    if (stFrame.byDLC != 8)
    {
        return ESP_ERR_INVALID_SIZE;
    }
    if (stFrame.dwID != 0x12) 
    {
        return ESP_ERR_INVALID_ARG;
    }
    *tLastTaskTime1ms = (float)((stFrame.abData[0])) * 50.0f;
    *tMaxTaskTime1ms = (float)((stFrame.abData[1])) * 50.0f;
    *tLastTaskTime100ms = (float)((stFrame.abData[2])) * 500.0f;
    *tMaxTaskTime100ms = (float)((stFrame.abData[3])) * 500.0f;
    *tLastTaskTimeBG = (float)((stFrame.abData[4])) * 500.0f;
    *tMaxTaskTimeBG = (float)((stFrame.abData[5])) * 500.0f;
    *tSincePowerUp = (float)((((uint16_t)(stFrame.abData[6])) << 4) | ((uint16_t)((stFrame.abData[7]) & 0xF))) * 4.0f;
    *NLastResetReason = (uint8_t)(((stFrame.abData[7] >> 4) & 0xF));
    return ESP_OK;
}

esp_err_t MCUStatusIMDMonitor(CAN_frame_t stFrame, float* tLastTaskTime1ms, float* tMaxTaskTime1ms, float* tLastTaskTime100ms, float* tMaxTaskTime100ms, float* tLastTaskTimeBG, float* tMaxTaskTimeBG, float* tSincePowerUp, uint8_t* NLastResetReason)
{
    /*
    *===========================================================================
    *   MCUStatusIMDMonitor
    *   Message: MCUStatusIMDMonitor (0x13)
    *   Description: MCU Status Message
    *   Takes:   stFrame: The CAN frame to decode
    *            tLastTaskTime1ms: MCU 1ms Last Task Time
    *            tMaxTaskTime1ms: MCU 1ms Max Task Time
    *            tLastTaskTime100ms: MCU 100ms Last Task Time
    *            tMaxTaskTime100ms: MCU 100ms Max Task Time
    *            tLastTaskTimeBG: MCU Background Last Task Time
    *            tMaxTaskTimeBG: MCU Background Max Task Time
    *            tSincePowerUp: MCU time since power up
    *            NLastResetReason: MCU Last Reset Reason
    * 
    *   Returns: ESP_OK if successful, error code if not.
    * 
    *   Autogenerated by decodeCAN.py
    */
    if (stFrame.byDLC != 8)
    {
        return ESP_ERR_INVALID_SIZE;
    }
    if (stFrame.dwID != 0x13) 
    {
        return ESP_ERR_INVALID_ARG;
    }
    *tLastTaskTime1ms = (float)((stFrame.abData[0])) * 50.0f;
    *tMaxTaskTime1ms = (float)((stFrame.abData[1])) * 50.0f;
    *tLastTaskTime100ms = (float)((stFrame.abData[2])) * 500.0f;
    *tMaxTaskTime100ms = (float)((stFrame.abData[3])) * 500.0f;
    *tLastTaskTimeBG = (float)((stFrame.abData[4])) * 500.0f;
    *tMaxTaskTimeBG = (float)((stFrame.abData[5])) * 500.0f;
    *tSincePowerUp = (float)((((uint16_t)(stFrame.abData[6])) << 4) | ((uint16_t)((stFrame.abData[7]) & 0xF))) * 4.0f;
    *NLastResetReason = (uint8_t)(((stFrame.abData[7] >> 4) & 0xF));
    return ESP_OK;
}

esp_err_t MCUStatusLogger(CAN_frame_t stFrame, float* tLastTaskTime1ms, float* tMaxTaskTime1ms, float* tLastTaskTime100ms, float* tMaxTaskTime100ms, float* tLastTaskTimeBG, float* tMaxTaskTimeBG, float* tSincePowerUp, uint8_t* NLastResetReason)
{
    /*
    *===========================================================================
    *   MCUStatusLogger
    *   Message: MCUStatusLogger (0x14)
    *   Description: MCU Status Message (Not sent to BUS just logged to SD card directly)
    *   Takes:   stFrame: The CAN frame to decode
    *            tLastTaskTime1ms: MCU 1ms Last Task Time
    *            tMaxTaskTime1ms: MCU 1ms Max Task Time
    *            tLastTaskTime100ms: MCU 100ms Last Task Time
    *            tMaxTaskTime100ms: MCU 100ms Max Task Time
    *            tLastTaskTimeBG: MCU Background Last Task Time
    *            tMaxTaskTimeBG: MCU Background Max Task Time
    *            tSincePowerUp: MCU time since power up
    *            NLastResetReason: MCU Last Reset Reason
    * 
    *   Returns: ESP_OK if successful, error code if not.
    * 
    *   Autogenerated by decodeCAN.py
    */
    if (stFrame.byDLC != 8)
    {
        return ESP_ERR_INVALID_SIZE;
    }
    if (stFrame.dwID != 0x14) 
    {
        return ESP_ERR_INVALID_ARG;
    }
    *tLastTaskTime1ms = (float)((stFrame.abData[0])) * 50.0f;
    *tMaxTaskTime1ms = (float)((stFrame.abData[1])) * 50.0f;
    *tLastTaskTime100ms = (float)((stFrame.abData[2])) * 500.0f;
    *tMaxTaskTime100ms = (float)((stFrame.abData[3])) * 500.0f;
    *tLastTaskTimeBG = (float)((stFrame.abData[4])) * 500.0f;
    *tMaxTaskTimeBG = (float)((stFrame.abData[5])) * 500.0f;
    *tSincePowerUp = (float)((((uint16_t)(stFrame.abData[6])) << 4) | ((uint16_t)((stFrame.abData[7]) & 0xF))) * 4.0f;
    *NLastResetReason = (uint8_t)(((stFrame.abData[7] >> 4) & 0xF));
    return ESP_OK;
}

esp_err_t MCUStatusPDU(CAN_frame_t stFrame, float* tLastTaskTime1ms, float* tMaxTaskTime1ms, float* tLastTaskTime100ms, float* tMaxTaskTime100ms, float* tLastTaskTimeBG, float* tMaxTaskTimeBG, float* tSincePowerUp, uint8_t* NLastResetReason)
{
    /*
    *===========================================================================
    *   MCUStatusPDU
    *   Message: MCUStatusPDU (0x15)
    *   Description: MCU Status Message
    *   Takes:   stFrame: The CAN frame to decode
    *            tLastTaskTime1ms: MCU 1ms Last Task Time
    *            tMaxTaskTime1ms: MCU 1ms Max Task Time
    *            tLastTaskTime100ms: MCU 100ms Last Task Time
    *            tMaxTaskTime100ms: MCU 100ms Max Task Time
    *            tLastTaskTimeBG: MCU Background Last Task Time
    *            tMaxTaskTimeBG: MCU Background Max Task Time
    *            tSincePowerUp: MCU time since power up
    *            NLastResetReason: MCU Last Reset Reason
    * 
    *   Returns: ESP_OK if successful, error code if not.
    * 
    *   Autogenerated by decodeCAN.py
    */
    if (stFrame.byDLC != 8)
    {
        return ESP_ERR_INVALID_SIZE;
    }
    if (stFrame.dwID != 0x15) 
    {
        return ESP_ERR_INVALID_ARG;
    }
    *tLastTaskTime1ms = (float)((stFrame.abData[0])) * 50.0f;
    *tMaxTaskTime1ms = (float)((stFrame.abData[1])) * 50.0f;
    *tLastTaskTime100ms = (float)((stFrame.abData[2])) * 500.0f;
    *tMaxTaskTime100ms = (float)((stFrame.abData[3])) * 500.0f;
    *tLastTaskTimeBG = (float)((stFrame.abData[4])) * 500.0f;
    *tMaxTaskTimeBG = (float)((stFrame.abData[5])) * 500.0f;
    *tSincePowerUp = (float)((((uint16_t)(stFrame.abData[6])) << 4) | ((uint16_t)((stFrame.abData[7]) & 0xF))) * 4.0f;
    *NLastResetReason = (uint8_t)(((stFrame.abData[7] >> 4) & 0xF));
    return ESP_OK;
}

esp_err_t StatusAPPS(CAN_frame_t stFrame, float* tLastTaskTime1ms, float* tMaxTaskTime1ms, float* tLastTaskTime100ms, float* tMaxTaskTime100ms, float* tLastTaskTimeBG, float* tMaxTaskTimeBG, float* tSincePowerUp, uint8_t* NLastResetReason)
{
    /*
    *===========================================================================
    *   StatusAPPS
    *   Message: StatusAPPS (0x16)
    *   Description: MCU Status Message
    *   Takes:   stFrame: The CAN frame to decode
    *            tLastTaskTime1ms: MCU 1ms Last Task Time
    *            tMaxTaskTime1ms: MCU 1ms Max Task Time
    *            tLastTaskTime100ms: MCU 100ms Last Task Time
    *            tMaxTaskTime100ms: MCU 100ms Max Task Time
    *            tLastTaskTimeBG: MCU Background Last Task Time
    *            tMaxTaskTimeBG: MCU Background Max Task Time
    *            tSincePowerUp: MCU time since power up
    *            NLastResetReason: MCU Last Reset Reason
    * 
    *   Returns: ESP_OK if successful, error code if not.
    * 
    *   Autogenerated by decodeCAN.py
    */
    if (stFrame.byDLC != 8)
    {
        return ESP_ERR_INVALID_SIZE;
    }
    if (stFrame.dwID != 0x16) 
    {
        return ESP_ERR_INVALID_ARG;
    }
    *tLastTaskTime1ms = (float)((stFrame.abData[0])) * 50.0f;
    *tMaxTaskTime1ms = (float)((stFrame.abData[1])) * 50.0f;
    *tLastTaskTime100ms = (float)((stFrame.abData[2])) * 500.0f;
    *tMaxTaskTime100ms = (float)((stFrame.abData[3])) * 500.0f;
    *tLastTaskTimeBG = (float)((stFrame.abData[4])) * 500.0f;
    *tMaxTaskTimeBG = (float)((stFrame.abData[5])) * 500.0f;
    *tSincePowerUp = (float)((((uint16_t)(stFrame.abData[6])) << 4) | ((uint16_t)((stFrame.abData[7]) & 0xF))) * 4.0f;
    *NLastResetReason = (uint8_t)(((stFrame.abData[7] >> 4) & 0xF));
    return ESP_OK;
}

esp_err_t MCUStatusScreen(CAN_frame_t stFrame, float* tLastTaskTime1ms, float* tMaxTaskTime1ms, float* tLastTaskTime100ms, float* tMaxTaskTime100ms, float* tLastTaskTimeBG, float* tMaxTaskTimeBG, float* tSincePowerUp, uint8_t* NLastResetReason)
{
    /*
    *===========================================================================
    *   MCUStatusScreen
    *   Message: MCUStatusScreen (0x17)
    *   Description: MCU Status Message
    *   Takes:   stFrame: The CAN frame to decode
    *            tLastTaskTime1ms: MCU 1ms Last Task Time
    *            tMaxTaskTime1ms: MCU 1ms Max Task Time
    *            tLastTaskTime100ms: MCU 100ms Last Task Time
    *            tMaxTaskTime100ms: MCU 100ms Max Task Time
    *            tLastTaskTimeBG: MCU Background Last Task Time
    *            tMaxTaskTimeBG: MCU Background Max Task Time
    *            tSincePowerUp: MCU time since power up
    *            NLastResetReason: MCU Last Reset Reason
    * 
    *   Returns: ESP_OK if successful, error code if not.
    * 
    *   Autogenerated by decodeCAN.py
    */
    if (stFrame.byDLC != 8)
    {
        return ESP_ERR_INVALID_SIZE;
    }
    if (stFrame.dwID != 0x17) 
    {
        return ESP_ERR_INVALID_ARG;
    }
    *tLastTaskTime1ms = (float)((stFrame.abData[0])) * 50.0f;
    *tMaxTaskTime1ms = (float)((stFrame.abData[1])) * 50.0f;
    *tLastTaskTime100ms = (float)((stFrame.abData[2])) * 500.0f;
    *tMaxTaskTime100ms = (float)((stFrame.abData[3])) * 500.0f;
    *tLastTaskTimeBG = (float)((stFrame.abData[4])) * 500.0f;
    *tMaxTaskTimeBG = (float)((stFrame.abData[5])) * 500.0f;
    *tSincePowerUp = (float)((((uint16_t)(stFrame.abData[6])) << 4) | ((uint16_t)((stFrame.abData[7]) & 0xF))) * 4.0f;
    *NLastResetReason = (uint8_t)(((stFrame.abData[7] >> 4) & 0xF));
    return ESP_OK;
}

esp_err_t MCUStatusDash(CAN_frame_t stFrame, float* tLastTaskTime1ms, float* tMaxTaskTime1ms, float* tLastTaskTime100ms, float* tMaxTaskTime100ms, float* tLastTaskTimeBG, float* tMaxTaskTimeBG, float* tSincePowerUp, uint8_t* NLastResetReason)
{
    /*
    *===========================================================================
    *   MCUStatusDash
    *   Message: MCUStatusDash (0x18)
    *   Description: MCU Status Message
    *   Takes:   stFrame: The CAN frame to decode
    *            tLastTaskTime1ms: MCU 1ms Last Task Time
    *            tMaxTaskTime1ms: MCU 1ms Max Task Time
    *            tLastTaskTime100ms: MCU 100ms Last Task Time
    *            tMaxTaskTime100ms: MCU 100ms Max Task Time
    *            tLastTaskTimeBG: MCU Background Last Task Time
    *            tMaxTaskTimeBG: MCU Background Max Task Time
    *            tSincePowerUp: MCU time since power up
    *            NLastResetReason: MCU Last Reset Reason
    * 
    *   Returns: ESP_OK if successful, error code if not.
    * 
    *   Autogenerated by decodeCAN.py
    */
    if (stFrame.byDLC != 8)
    {
        return ESP_ERR_INVALID_SIZE;
    }
    if (stFrame.dwID != 0x18) 
    {
        return ESP_ERR_INVALID_ARG;
    }
    *tLastTaskTime1ms = (float)((stFrame.abData[0])) * 50.0f;
    *tMaxTaskTime1ms = (float)((stFrame.abData[1])) * 50.0f;
    *tLastTaskTime100ms = (float)((stFrame.abData[2])) * 500.0f;
    *tMaxTaskTime100ms = (float)((stFrame.abData[3])) * 500.0f;
    *tLastTaskTimeBG = (float)((stFrame.abData[4])) * 500.0f;
    *tMaxTaskTimeBG = (float)((stFrame.abData[5])) * 500.0f;
    *tSincePowerUp = (float)((((uint16_t)(stFrame.abData[6])) << 4) | ((uint16_t)((stFrame.abData[7]) & 0xF))) * 4.0f;
    *NLastResetReason = (uint8_t)(((stFrame.abData[7] >> 4) & 0xF));
    return ESP_OK;
}

esp_err_t SetCurrent(CAN_frame_t stFrame, float* ACCurrentSET)
{
    /*
    *===========================================================================
    *   SetCurrent
    *   Message: SetCurrent (0x24)
    *   Description: Set AC Current - Current (2-byte)
    *   Takes:   stFrame: The CAN frame to decode
    *            ACCurrentSET: READ THE COMMENT Sets the target motor AC Peak current, auto switches to current control mode
    * 
    *   Returns: ESP_OK if successful, error code if not.
    * 
    *   Autogenerated by decodeCAN.py
    */
    if (stFrame.byDLC != 8)
    {
        return ESP_ERR_INVALID_SIZE;
    }
    if (stFrame.dwID != 0x24) 
    {
        return ESP_ERR_INVALID_ARG;
    }
    *ACCurrentSET = (float)((((uint16_t)(stFrame.abData[0])) << 8) | ((uint16_t)(stFrame.abData[1]))) * 0.1f;
    return ESP_OK;
}

esp_err_t IMDData(CAN_frame_t stFrame, uint8_t* BIMDOff, uint8_t* BIMDUndervoltage, uint8_t* BIMDStarting, uint8_t* BIMDSSTGood, uint8_t* BIMDDeviceError, uint8_t* BIMDGroundConnectionFault, uint8_t* BIMDInvalidState, float* RIsolation)
{
    /*
    *===========================================================================
    *   IMDData
    *   Message: IMDData (0x40)
    *   Description: Bender IMD Measurements
    *   Takes:   stFrame: The CAN frame to decode
    *            BIMDOff: IMD is off
    *            BIMDUndervoltage: IMD detected undervoltage
    *            BIMDStarting: IMD is starting up
    *            BIMDSSTGood: IMD insulation state good during start up
    *            BIMDDeviceError: IMD device is in fault
    *            BIMDGroundConnectionFault: IMD connection to ground is broken
    *            BIMDInvalidState: IMD is in a invalid state
    *            RIsolation: IMD Insulation measurement
    * 
    *   Returns: ESP_OK if successful, error code if not.
    * 
    *   Autogenerated by decodeCAN.py
    */
    if (stFrame.byDLC != 8)
    {
        return ESP_ERR_INVALID_SIZE;
    }
    if (stFrame.dwID != 0x40) 
    {
        return ESP_ERR_INVALID_ARG;
    }
    *BIMDOff = (uint8_t)(((stFrame.abData[0]) & 0x1));
    *BIMDUndervoltage = (uint8_t)(((stFrame.abData[0] >> 1) & 0x1));
    *BIMDStarting = (uint8_t)(((stFrame.abData[0] >> 2) & 0x1));
    *BIMDSSTGood = (uint8_t)(((stFrame.abData[0] >> 3) & 0x1));
    *BIMDDeviceError = (uint8_t)(((stFrame.abData[0] >> 4) & 0x1));
    *BIMDGroundConnectionFault = (uint8_t)(((stFrame.abData[0] >> 5) & 0x1));
    *BIMDInvalidState = (uint8_t)(((stFrame.abData[0] >> 6) & 0x1));
    *RIsolation = (float)((((uint16_t)((stFrame.abData[0] >> 7) & 0x1)) << 15) | (((uint16_t)(stFrame.abData[1])) << 7) | ((uint16_t)((stFrame.abData[2]) & 0x7F))) * 200.0f;
    return ESP_OK;
}

esp_err_t SetBreakCurrent(CAN_frame_t stFrame, float* TargetbrakecurrentSET)
{
    /*
    *===========================================================================
    *   SetBreakCurrent
    *   Message: SetBreakCurrent (0x44)
    *   Description: Set AC Break Current - Current (2-byte, x10)
    *   Takes:   stFrame: The CAN frame to decode
    *            TargetbrakecurrentSET: ONLY POSITIVE CURRENTS ARE ACCEPTED Targets the brake current of the motor, resulting in negative torque, relative to the forward direction of the motor.
    * 
    *   Returns: ESP_OK if successful, error code if not.
    * 
    *   Autogenerated by decodeCAN.py
    */
    if (stFrame.byDLC != 8)
    {
        return ESP_ERR_INVALID_SIZE;
    }
    if (stFrame.dwID != 0x44) 
    {
        return ESP_ERR_INVALID_ARG;
    }
    *TargetbrakecurrentSET = (float)((((uint16_t)(stFrame.abData[0])) << 8) | ((uint16_t)(stFrame.abData[1]))) * 0.1f;
    return ESP_OK;
}

esp_err_t SetERPM(CAN_frame_t stFrame, int32_t* TargetERPMSET)
{
    /*
    *===========================================================================
    *   SetERPM
    *   Message: SetERPM (0x64)
    *   Description: Set ERPM - ERPM (4-byte)
    *   Takes:   stFrame: The CAN frame to decode
    *            TargetERPMSET: Enable speed control of motor using target ERPM, Sign is direction of spinning,
    * 
    *   Returns: ESP_OK if successful, error code if not.
    * 
    *   Autogenerated by decodeCAN.py
    */
    if (stFrame.byDLC != 8)
    {
        return ESP_ERR_INVALID_SIZE;
    }
    if (stFrame.dwID != 0x64) 
    {
        return ESP_ERR_INVALID_ARG;
    }
    *TargetERPMSET = (int32_t)((((uint32_t)(stFrame.abData[0])) << 24) | (((uint32_t)(stFrame.abData[1])) << 16) | (((uint32_t)(stFrame.abData[2])) << 8) | ((uint32_t)(stFrame.abData[3])));
    return ESP_OK;
}

esp_err_t StatusAPPSSensor(CAN_frame_t stFrame, int8_t* rAPPs1, int8_t* rAPPs2, int8_t* rAPPsFinal, uint8_t* BThrottleOK, uint8_t* BAPPS1Fail, uint8_t* BAPPS2Fail, uint8_t* BAPPSDrift)
{
    /*
    *===========================================================================
    *   StatusAPPSSensor
    *   Message: StatusAPPSSensor (0x81)
    *   Description: APPS Sensor Status
    *   Takes:   stFrame: The CAN frame to decode
    *            rAPPs1: Signal from APPS 1
    *            rAPPs2: Signal from APPS 2
    *            rAPPsFinal: Final calculated throttle signal
    *            BThrottleOK: Throttle signal is valid
    *            BAPPS1Fail: APPS sensor one in failure state
    *            BAPPS2Fail: APPS sensor two in failure state
    *            BAPPSDrift: APPS sensors have drifted from each other
    * 
    *   Returns: ESP_OK if successful, error code if not.
    * 
    *   Autogenerated by decodeCAN.py
    */
    if (stFrame.byDLC != 8)
    {
        return ESP_ERR_INVALID_SIZE;
    }
    if (stFrame.dwID != 0x81) 
    {
        return ESP_ERR_INVALID_ARG;
    }
    *rAPPs1 = (int8_t)((stFrame.abData[0]));
    *rAPPs2 = (int8_t)((stFrame.abData[1]));
    *rAPPsFinal = (int8_t)((stFrame.abData[2]));
    *BThrottleOK = (uint8_t)(((stFrame.abData[3] >> 4) & 0x1));
    *BAPPS1Fail = (uint8_t)(((stFrame.abData[3] >> 5) & 0x1));
    *BAPPS2Fail = (uint8_t)(((stFrame.abData[3] >> 6) & 0x1));
    *BAPPSDrift = (uint8_t)(((stFrame.abData[3] >> 7) & 0x1));
    return ESP_OK;
}

esp_err_t SetPostion(CAN_frame_t stFrame, float* TargetPositionSET)
{
    /*
    *===========================================================================
    *   SetPostion
    *   Message: SetPostion (0x84)
    *   Description: Set Position (hold motor at angle in degrees if encoder exists) - Angle (2-byte, x10)
    *   Takes:   stFrame: The CAN frame to decode
    *            TargetPositionSET: Target the desired position of the motor in degrees, hold position of motor
    * 
    *   Returns: ESP_OK if successful, error code if not.
    * 
    *   Autogenerated by decodeCAN.py
    */
    if (stFrame.byDLC != 8)
    {
        return ESP_ERR_INVALID_SIZE;
    }
    if (stFrame.dwID != 0x84) 
    {
        return ESP_ERR_INVALID_ARG;
    }
    *TargetPositionSET = (float)((((uint16_t)(stFrame.abData[0])) << 8) | ((uint16_t)(stFrame.abData[1]))) * 0.1f;
    return ESP_OK;
}

esp_err_t SetRelativeCurrent(CAN_frame_t stFrame, float* TargetrelativeACcurrentSET)
{
    /*
    *===========================================================================
    *   SetRelativeCurrent
    *   Message: SetRelativeCurrent (0xA4)
    *   Description: Set Relative current
    *   Takes:   stFrame: The CAN frame to decode
    *            TargetrelativeACcurrentSET: Set relative motor AC current between limits using percentages COMMENT!
    * 
    *   Returns: ESP_OK if successful, error code if not.
    * 
    *   Autogenerated by decodeCAN.py
    */
    if (stFrame.byDLC != 8)
    {
        return ESP_ERR_INVALID_SIZE;
    }
    if (stFrame.dwID != 0xA4) 
    {
        return ESP_ERR_INVALID_ARG;
    }
    *TargetrelativeACcurrentSET = (float)((((uint16_t)(stFrame.abData[0])) << 8) | ((uint16_t)(stFrame.abData[1]))) * 0.1f;
    return ESP_OK;
}

esp_err_t SetRelativeBreak(CAN_frame_t stFrame, float* RelativeBrakeACCurrent)
{
    /*
    *===========================================================================
    *   SetRelativeBreak
    *   Message: SetRelativeBreak (0xC4)
    *   Description: Set relative break current
    *   Takes:   stFrame: The CAN frame to decode
    *            RelativeBrakeACCurrent: Set relative AC motor brake current between limits using %
    * 
    *   Returns: ESP_OK if successful, error code if not.
    * 
    *   Autogenerated by decodeCAN.py
    */
    if (stFrame.byDLC != 8)
    {
        return ESP_ERR_INVALID_SIZE;
    }
    if (stFrame.dwID != 0xC4) 
    {
        return ESP_ERR_INVALID_ARG;
    }
    *RelativeBrakeACCurrent = (float)((((uint16_t)(stFrame.abData[0])) << 8) | ((uint16_t)(stFrame.abData[1]))) * 0.1f;
    return ESP_OK;
}

esp_err_t SetDigOut(CAN_frame_t stFrame, uint8_t* DigitalOutput1, uint8_t* DigitalOutput2, uint8_t* DigitalOutput3, uint8_t* DigitalOutput4)
{
    /*
    *===========================================================================
    *   SetDigOut
    *   Message: SetDigOut (0xE4)
    *   Description: Set digital output
    *   Takes:   stFrame: The CAN frame to decode
    *            DigitalOutput1: Sets the digital output 1 to HIGH (1) or LOW (0) state
    *            DigitalOutput2: Sets the digital output 2 to HIGH (1) or LOW (0) state
    *            DigitalOutput3: Sets the digital output 3 to HIGH (1) or LOW (0) state
    *            DigitalOutput4: Sets the digital output 4 to HIGH (1) or LOW (0) state
    * 
    *   Returns: ESP_OK if successful, error code if not.
    * 
    *   Autogenerated by decodeCAN.py
    */
    if (stFrame.byDLC != 8)
    {
        return ESP_ERR_INVALID_SIZE;
    }
    if (stFrame.dwID != 0xE4) 
    {
        return ESP_ERR_INVALID_ARG;
    }
    *DigitalOutput1 = (uint8_t)(((stFrame.abData[0]) & 0x1));
    *DigitalOutput2 = (uint8_t)(((stFrame.abData[0] >> 1) & 0x1));
    *DigitalOutput3 = (uint8_t)(((stFrame.abData[0] >> 2) & 0x1));
    *DigitalOutput4 = (uint8_t)(((stFrame.abData[0] >> 3) & 0x1));
    return ESP_OK;
}

esp_err_t SetCurrentMaxAC(CAN_frame_t stFrame, float* MaxACCurrentSET)
{
    /*
    *===========================================================================
    *   SetCurrentMaxAC
    *   Message: SetCurrentMaxAC (0x104)
    *   Description: Set max AC current
    *   Takes:   stFrame: The CAN frame to decode
    *            MaxACCurrentSET: Set the maximum allowable drive current on the AC side
    * 
    *   Returns: ESP_OK if successful, error code if not.
    * 
    *   Autogenerated by decodeCAN.py
    */
    if (stFrame.byDLC != 8)
    {
        return ESP_ERR_INVALID_SIZE;
    }
    if (stFrame.dwID != 0x104) 
    {
        return ESP_ERR_INVALID_ARG;
    }
    *MaxACCurrentSET = (float)((((uint16_t)(stFrame.abData[1])) << 8) | ((uint16_t)(stFrame.abData[2]))) * 0.1f;
    return ESP_OK;
}

esp_err_t SetBreakCurrentMax(CAN_frame_t stFrame, float* MaxbrakeACcurrentSET)
{
    /*
    *===========================================================================
    *   SetBreakCurrentMax
    *   Message: SetBreakCurrentMax (0x124)
    *   Description: Set max AC break current
    *   Takes:   stFrame: The CAN frame to decode
    *            MaxbrakeACcurrentSET: ONLY NEGATIVE CURRENTS ACCEPTEDSets the maximum allowable brake current on the AC side
    * 
    *   Returns: ESP_OK if successful, error code if not.
    * 
    *   Autogenerated by decodeCAN.py
    */
    if (stFrame.byDLC != 8)
    {
        return ESP_ERR_INVALID_SIZE;
    }
    if (stFrame.dwID != 0x124) 
    {
        return ESP_ERR_INVALID_ARG;
    }
    *MaxbrakeACcurrentSET = (float)((((uint16_t)(stFrame.abData[1])) << 8) | ((uint16_t)(stFrame.abData[2]))) * 0.1f;
    return ESP_OK;
}

esp_err_t SetCurrentMaxDC(CAN_frame_t stFrame, float* MaxDCcurrentSET)
{
    /*
    *===========================================================================
    *   SetCurrentMaxDC
    *   Message: SetCurrentMaxDC (0x144)
    *   Description: Set max DC current
    *   Takes:   stFrame: The CAN frame to decode
    *            MaxDCcurrentSET: Maximum allowable drive current on the DC side, (batt discharge current)
    * 
    *   Returns: ESP_OK if successful, error code if not.
    * 
    *   Autogenerated by decodeCAN.py
    */
    if (stFrame.byDLC != 8)
    {
        return ESP_ERR_INVALID_SIZE;
    }
    if (stFrame.dwID != 0x144) 
    {
        return ESP_ERR_INVALID_ARG;
    }
    *MaxDCcurrentSET = (float)((((uint16_t)(stFrame.abData[1])) << 8) | ((uint16_t)(stFrame.abData[2]))) * 0.1f;
    return ESP_OK;
}

esp_err_t SetBreakCurrentMaxDC(CAN_frame_t stFrame, float* MaximumbrakeDCcurrentSET)
{
    /*
    *===========================================================================
    *   SetBreakCurrentMaxDC
    *   Message: SetBreakCurrentMaxDC (0x164)
    *   Description: Set max DC break current
    *   Takes:   stFrame: The CAN frame to decode
    *            MaximumbrakeDCcurrentSET: ONLY NEGATIVE CURRENTS ACCEPTED Maximum allowable brake current DC side
    * 
    *   Returns: ESP_OK if successful, error code if not.
    * 
    *   Autogenerated by decodeCAN.py
    */
    if (stFrame.byDLC != 8)
    {
        return ESP_ERR_INVALID_SIZE;
    }
    if (stFrame.dwID != 0x164) 
    {
        return ESP_ERR_INVALID_ARG;
    }
    *MaximumbrakeDCcurrentSET = (float)((((uint16_t)(stFrame.abData[1])) << 8) | ((uint16_t)(stFrame.abData[2]))) * 0.1f;
    return ESP_OK;
}

esp_err_t DriveEnable(CAN_frame_t stFrame, uint8_t* Driveenable)
{
    /*
    *===========================================================================
    *   DriveEnable
    *   Message: DriveEnable (0x184)
    *   Description: Drive Enable
    *   Takes:   stFrame: The CAN frame to decode
    *            Driveenable: Must be sent periodically to be enabled, 1 = enable, 0 = disable
    * 
    *   Returns: ESP_OK if successful, error code if not.
    * 
    *   Autogenerated by decodeCAN.py
    */
    if (stFrame.byDLC != 8)
    {
        return ESP_ERR_INVALID_SIZE;
    }
    if (stFrame.dwID != 0x184) 
    {
        return ESP_ERR_INVALID_ARG;
    }
    *Driveenable = (uint8_t)(((stFrame.abData[0]) & 0x1));
    return ESP_OK;
}

esp_err_t FRTireTemp1(CAN_frame_t stFrame, float* TFRTireChannel01, float* TFRTireChannel02, float* TFRTireChannel03, float* TFRTireChannel04)
{
    /*
    *===========================================================================
    *   FRTireTemp1
    *   Message: FRTireTemp1 (0x200)
    *   Description: Front Right Tire temperature sensor channels 1-4
    *   Takes:   stFrame: The CAN frame to decode
    *            TFRTireChannel01: Front Right Tire Temperature Channel 1
    *            TFRTireChannel02: Front Right Tire Temperature Channel 2
    *            TFRTireChannel03: Front Right Tire Temperature Channel 3
    *            TFRTireChannel04: Front Right Tire Temperature Channel 4
    * 
    *   Returns: ESP_OK if successful, error code if not.
    * 
    *   Autogenerated by decodeCAN.py
    */
    if (stFrame.byDLC != 8)
    {
        return ESP_ERR_INVALID_SIZE;
    }
    if (stFrame.dwID != 0x200) 
    {
        return ESP_ERR_INVALID_ARG;
    }
    *TFRTireChannel01 = (float)((((uint16_t)(stFrame.abData[0])) << 8) | ((uint16_t)(stFrame.abData[1]))) * 0.1f + -100.0f;
    *TFRTireChannel02 = (float)((((uint16_t)(stFrame.abData[2])) << 8) | ((uint16_t)(stFrame.abData[3]))) * 0.1f + -100.0f;
    *TFRTireChannel03 = (float)((((uint16_t)(stFrame.abData[4])) << 8) | ((uint16_t)(stFrame.abData[5]))) * 0.1f + -100.0f;
    *TFRTireChannel04 = (float)((((uint16_t)(stFrame.abData[6])) << 8) | ((uint16_t)(stFrame.abData[7]))) * 0.1f + -100.0f;
    return ESP_OK;
}

esp_err_t FRTireTemp2(CAN_frame_t stFrame, float* TFRTireChannel05, float* TFRTireChannel06, float* TFRTireChannel07, float* TFRTireChannel08)
{
    /*
    *===========================================================================
    *   FRTireTemp2
    *   Message: FRTireTemp2 (0x201)
    *   Description: Front Right Tire temperature sensor channels 5-8
    *   Takes:   stFrame: The CAN frame to decode
    *            TFRTireChannel05: Front Right Tire Temperature Channel 5
    *            TFRTireChannel06: Front Right Tire Temperature Channel 6
    *            TFRTireChannel07: Front Right Tire Temperature Channel 7
    *            TFRTireChannel08: Front Right Tire Temperature Channel 8
    * 
    *   Returns: ESP_OK if successful, error code if not.
    * 
    *   Autogenerated by decodeCAN.py
    */
    if (stFrame.byDLC != 8)
    {
        return ESP_ERR_INVALID_SIZE;
    }
    if (stFrame.dwID != 0x201) 
    {
        return ESP_ERR_INVALID_ARG;
    }
    *TFRTireChannel05 = (float)((((uint16_t)(stFrame.abData[0])) << 8) | ((uint16_t)(stFrame.abData[1]))) * 0.1f + -100.0f;
    *TFRTireChannel06 = (float)((((uint16_t)(stFrame.abData[2])) << 8) | ((uint16_t)(stFrame.abData[3]))) * 0.1f + -100.0f;
    *TFRTireChannel07 = (float)((((uint16_t)(stFrame.abData[4])) << 8) | ((uint16_t)(stFrame.abData[5]))) * 0.1f + -100.0f;
    *TFRTireChannel08 = (float)((((uint16_t)(stFrame.abData[6])) << 8) | ((uint16_t)(stFrame.abData[7]))) * 0.1f + -100.0f;
    return ESP_OK;
}

esp_err_t FRTireTemp3(CAN_frame_t stFrame, float* TFRTireChannel09, float* TFRTireChannel10, float* TFRTireChannel11, float* TFRTireChannel12)
{
    /*
    *===========================================================================
    *   FRTireTemp3
    *   Message: FRTireTemp3 (0x202)
    *   Description: Front Right Tire temperature sensor channels 9-12
    *   Takes:   stFrame: The CAN frame to decode
    *            TFRTireChannel09: Front Right Tire Temperature Channel 9
    *            TFRTireChannel10: Front Right Tire Temperature Channel 10
    *            TFRTireChannel11: Front Right Tire Temperature Channel 11
    *            TFRTireChannel12: Front Right Tire Temperature Channel 12
    * 
    *   Returns: ESP_OK if successful, error code if not.
    * 
    *   Autogenerated by decodeCAN.py
    */
    if (stFrame.byDLC != 8)
    {
        return ESP_ERR_INVALID_SIZE;
    }
    if (stFrame.dwID != 0x202) 
    {
        return ESP_ERR_INVALID_ARG;
    }
    *TFRTireChannel09 = (float)((((uint16_t)(stFrame.abData[0])) << 8) | ((uint16_t)(stFrame.abData[1]))) * 0.1f + -100.0f;
    *TFRTireChannel10 = (float)((((uint16_t)(stFrame.abData[2])) << 8) | ((uint16_t)(stFrame.abData[3]))) * 0.1f + -100.0f;
    *TFRTireChannel11 = (float)((((uint16_t)(stFrame.abData[4])) << 8) | ((uint16_t)(stFrame.abData[5]))) * 0.1f + -100.0f;
    *TFRTireChannel12 = (float)((((uint16_t)(stFrame.abData[6])) << 8) | ((uint16_t)(stFrame.abData[7]))) * 0.1f + -100.0f;
    return ESP_OK;
}

esp_err_t FRTireTemp4(CAN_frame_t stFrame, float* TFRTireChannel13, float* TFRTireChannel14, float* TFRTireChannel15, float* TFRTireChannel16)
{
    /*
    *===========================================================================
    *   FRTireTemp4
    *   Message: FRTireTemp4 (0x203)
    *   Description: Front Right Tire temperature sensor channels 13-16
    *   Takes:   stFrame: The CAN frame to decode
    *            TFRTireChannel13: Front Right Tire Temperature Channel 13
    *            TFRTireChannel14: Front Right Tire Temperature Channel 14
    *            TFRTireChannel15: Front Right Tire Temperature Channel 15
    *            TFRTireChannel16: Front Right Tire Temperature Channel 16
    * 
    *   Returns: ESP_OK if successful, error code if not.
    * 
    *   Autogenerated by decodeCAN.py
    */
    if (stFrame.byDLC != 8)
    {
        return ESP_ERR_INVALID_SIZE;
    }
    if (stFrame.dwID != 0x203) 
    {
        return ESP_ERR_INVALID_ARG;
    }
    *TFRTireChannel13 = (float)((((uint16_t)(stFrame.abData[0])) << 8) | ((uint16_t)(stFrame.abData[1]))) * 0.1f + -100.0f;
    *TFRTireChannel14 = (float)((((uint16_t)(stFrame.abData[2])) << 8) | ((uint16_t)(stFrame.abData[3]))) * 0.1f + -100.0f;
    *TFRTireChannel15 = (float)((((uint16_t)(stFrame.abData[4])) << 8) | ((uint16_t)(stFrame.abData[5]))) * 0.1f + -100.0f;
    *TFRTireChannel16 = (float)((((uint16_t)(stFrame.abData[6])) << 8) | ((uint16_t)(stFrame.abData[7]))) * 0.1f + -100.0f;
    return ESP_OK;
}

esp_err_t FLTireTemp1(CAN_frame_t stFrame, float* TFLTireChannel01, float* TFLTireChannel02, float* TFLTireChannel03, float* TFLTireChannel04)
{
    /*
    *===========================================================================
    *   FLTireTemp1
    *   Message: FLTireTemp1 (0x204)
    *   Description: Front Left Tire temperature sensor channels 1-4
    *   Takes:   stFrame: The CAN frame to decode
    *            TFLTireChannel01: Front Left Tire Temperature Channel 1
    *            TFLTireChannel02: Front Left Tire Temperature Channel 2
    *            TFLTireChannel03: Front Left Tire Temperature Channel 3
    *            TFLTireChannel04: Front Left Tire Temperature Channel 4
    * 
    *   Returns: ESP_OK if successful, error code if not.
    * 
    *   Autogenerated by decodeCAN.py
    */
    if (stFrame.byDLC != 8)
    {
        return ESP_ERR_INVALID_SIZE;
    }
    if (stFrame.dwID != 0x204) 
    {
        return ESP_ERR_INVALID_ARG;
    }
    *TFLTireChannel01 = (float)((((uint16_t)(stFrame.abData[0])) << 8) | ((uint16_t)(stFrame.abData[1]))) * 0.1f + -100.0f;
    *TFLTireChannel02 = (float)((((uint16_t)(stFrame.abData[2])) << 8) | ((uint16_t)(stFrame.abData[3]))) * 0.1f + -100.0f;
    *TFLTireChannel03 = (float)((((uint16_t)(stFrame.abData[4])) << 8) | ((uint16_t)(stFrame.abData[5]))) * 0.1f + -100.0f;
    *TFLTireChannel04 = (float)((((uint16_t)(stFrame.abData[6])) << 8) | ((uint16_t)(stFrame.abData[7]))) * 0.1f + -100.0f;
    return ESP_OK;
}

esp_err_t FLTireTemp2(CAN_frame_t stFrame, float* TFLTireChannel05, float* TFLTireChannel06, float* TFLTireChannel07, float* TFLTireChannel08)
{
    /*
    *===========================================================================
    *   FLTireTemp2
    *   Message: FLTireTemp2 (0x205)
    *   Description: Front Left Tire temperature sensor channels 5-8
    *   Takes:   stFrame: The CAN frame to decode
    *            TFLTireChannel05: Front Left Tire Temperature Channel 5
    *            TFLTireChannel06: Front Left Tire Temperature Channel 6
    *            TFLTireChannel07: Front Left Tire Temperature Channel 7
    *            TFLTireChannel08: Front Left Tire Temperature Channel 8
    * 
    *   Returns: ESP_OK if successful, error code if not.
    * 
    *   Autogenerated by decodeCAN.py
    */
    if (stFrame.byDLC != 8)
    {
        return ESP_ERR_INVALID_SIZE;
    }
    if (stFrame.dwID != 0x205) 
    {
        return ESP_ERR_INVALID_ARG;
    }
    *TFLTireChannel05 = (float)((((uint16_t)(stFrame.abData[0])) << 8) | ((uint16_t)(stFrame.abData[1]))) * 0.1f + -100.0f;
    *TFLTireChannel06 = (float)((((uint16_t)(stFrame.abData[2])) << 8) | ((uint16_t)(stFrame.abData[3]))) * 0.1f + -100.0f;
    *TFLTireChannel07 = (float)((((uint16_t)(stFrame.abData[4])) << 8) | ((uint16_t)(stFrame.abData[5]))) * 0.1f + -100.0f;
    *TFLTireChannel08 = (float)((((uint16_t)(stFrame.abData[6])) << 8) | ((uint16_t)(stFrame.abData[7]))) * 0.1f + -100.0f;
    return ESP_OK;
}

esp_err_t FLTireTemp3(CAN_frame_t stFrame, float* TFLTireChannel09, float* TFLTireChannel10, float* TFLTireChannel11, float* TFLTireChannel12)
{
    /*
    *===========================================================================
    *   FLTireTemp3
    *   Message: FLTireTemp3 (0x206)
    *   Description: Front Left Tire temperature sensor channels 9-12
    *   Takes:   stFrame: The CAN frame to decode
    *            TFLTireChannel09: Front Left Tire Temperature Channel 9
    *            TFLTireChannel10: Front Left Tire Temperature Channel 10
    *            TFLTireChannel11: Front Left Tire Temperature Channel 11
    *            TFLTireChannel12: Front Left Tire Temperature Channel 12
    * 
    *   Returns: ESP_OK if successful, error code if not.
    * 
    *   Autogenerated by decodeCAN.py
    */
    if (stFrame.byDLC != 8)
    {
        return ESP_ERR_INVALID_SIZE;
    }
    if (stFrame.dwID != 0x206) 
    {
        return ESP_ERR_INVALID_ARG;
    }
    *TFLTireChannel09 = (float)((((uint16_t)(stFrame.abData[0])) << 8) | ((uint16_t)(stFrame.abData[1]))) * 0.1f + -100.0f;
    *TFLTireChannel10 = (float)((((uint16_t)(stFrame.abData[2])) << 8) | ((uint16_t)(stFrame.abData[3]))) * 0.1f + -100.0f;
    *TFLTireChannel11 = (float)((((uint16_t)(stFrame.abData[4])) << 8) | ((uint16_t)(stFrame.abData[5]))) * 0.1f + -100.0f;
    *TFLTireChannel12 = (float)((((uint16_t)(stFrame.abData[6])) << 8) | ((uint16_t)(stFrame.abData[7]))) * 0.1f + -100.0f;
    return ESP_OK;
}

esp_err_t FLTireTemp4(CAN_frame_t stFrame, float* TFLTireChannel13, float* TFLTireChannel14, float* TFLTireChannel15, float* TFLTireChannel16)
{
    /*
    *===========================================================================
    *   FLTireTemp4
    *   Message: FLTireTemp4 (0x207)
    *   Description: Front Left Tire temperature sensor channels 13-16
    *   Takes:   stFrame: The CAN frame to decode
    *            TFLTireChannel13: Front Left Tire Temperature Channel 13
    *            TFLTireChannel14: Front Left Tire Temperature Channel 14
    *            TFLTireChannel15: Front Left Tire Temperature Channel 15
    *            TFLTireChannel16: Front Left Tire Temperature Channel 16
    * 
    *   Returns: ESP_OK if successful, error code if not.
    * 
    *   Autogenerated by decodeCAN.py
    */
    if (stFrame.byDLC != 8)
    {
        return ESP_ERR_INVALID_SIZE;
    }
    if (stFrame.dwID != 0x207) 
    {
        return ESP_ERR_INVALID_ARG;
    }
    *TFLTireChannel13 = (float)((((uint16_t)(stFrame.abData[0])) << 8) | ((uint16_t)(stFrame.abData[1]))) * 0.1f + -100.0f;
    *TFLTireChannel14 = (float)((((uint16_t)(stFrame.abData[2])) << 8) | ((uint16_t)(stFrame.abData[3]))) * 0.1f + -100.0f;
    *TFLTireChannel15 = (float)((((uint16_t)(stFrame.abData[4])) << 8) | ((uint16_t)(stFrame.abData[5]))) * 0.1f + -100.0f;
    *TFLTireChannel16 = (float)((((uint16_t)(stFrame.abData[6])) << 8) | ((uint16_t)(stFrame.abData[7]))) * 0.1f + -100.0f;
    return ESP_OK;
}

esp_err_t RRTireTemp1(CAN_frame_t stFrame, float* TRRTireChannel01, float* TRRTireChannel02, float* TRRTireChannel03, float* TRRTireChannel04)
{
    /*
    *===========================================================================
    *   RRTireTemp1
    *   Message: RRTireTemp1 (0x208)
    *   Description: Rear Right Tire temperature sensor channels 1-4
    *   Takes:   stFrame: The CAN frame to decode
    *            TRRTireChannel01: Rear Right Tire Temperature Channel 1
    *            TRRTireChannel02: Rear Right Tire Temperature Channel 2
    *            TRRTireChannel03: Rear Right Tire Temperature Channel 3
    *            TRRTireChannel04: Rear Right Tire Temperature Channel 4
    * 
    *   Returns: ESP_OK if successful, error code if not.
    * 
    *   Autogenerated by decodeCAN.py
    */
    if (stFrame.byDLC != 8)
    {
        return ESP_ERR_INVALID_SIZE;
    }
    if (stFrame.dwID != 0x208) 
    {
        return ESP_ERR_INVALID_ARG;
    }
    *TRRTireChannel01 = (float)((((uint16_t)(stFrame.abData[0])) << 8) | ((uint16_t)(stFrame.abData[1]))) * 0.1f + -100.0f;
    *TRRTireChannel02 = (float)((((uint16_t)(stFrame.abData[2])) << 8) | ((uint16_t)(stFrame.abData[3]))) * 0.1f + -100.0f;
    *TRRTireChannel03 = (float)((((uint16_t)(stFrame.abData[4])) << 8) | ((uint16_t)(stFrame.abData[5]))) * 0.1f + -100.0f;
    *TRRTireChannel04 = (float)((((uint16_t)(stFrame.abData[6])) << 8) | ((uint16_t)(stFrame.abData[7]))) * 0.1f + -100.0f;
    return ESP_OK;
}

esp_err_t RRTireTemp2(CAN_frame_t stFrame, float* TRRTireChannel05, float* TRRTireChannel06, float* TRRTireChannel07, float* TRRTireChannel08)
{
    /*
    *===========================================================================
    *   RRTireTemp2
    *   Message: RRTireTemp2 (0x209)
    *   Description: Rear Right Tire temperature sensor channels 5-8
    *   Takes:   stFrame: The CAN frame to decode
    *            TRRTireChannel05: Rear Right Tire Temperature Channel 5
    *            TRRTireChannel06: Rear Right Tire Temperature Channel 6
    *            TRRTireChannel07: Rear Right Tire Temperature Channel 7
    *            TRRTireChannel08: Rear Right Tire Temperature Channel 8
    * 
    *   Returns: ESP_OK if successful, error code if not.
    * 
    *   Autogenerated by decodeCAN.py
    */
    if (stFrame.byDLC != 8)
    {
        return ESP_ERR_INVALID_SIZE;
    }
    if (stFrame.dwID != 0x209) 
    {
        return ESP_ERR_INVALID_ARG;
    }
    *TRRTireChannel05 = (float)((((uint16_t)(stFrame.abData[0])) << 8) | ((uint16_t)(stFrame.abData[1]))) * 0.1f + -100.0f;
    *TRRTireChannel06 = (float)((((uint16_t)(stFrame.abData[2])) << 8) | ((uint16_t)(stFrame.abData[3]))) * 0.1f + -100.0f;
    *TRRTireChannel07 = (float)((((uint16_t)(stFrame.abData[4])) << 8) | ((uint16_t)(stFrame.abData[5]))) * 0.1f + -100.0f;
    *TRRTireChannel08 = (float)((((uint16_t)(stFrame.abData[6])) << 8) | ((uint16_t)(stFrame.abData[7]))) * 0.1f + -100.0f;
    return ESP_OK;
}

esp_err_t RRTireTemp3(CAN_frame_t stFrame, float* TRRTireChannel09, float* TRRTireChannel10, float* TRRTireChannel11, float* TRRTireChannel12)
{
    /*
    *===========================================================================
    *   RRTireTemp3
    *   Message: RRTireTemp3 (0x20A)
    *   Description: Rear Right Tire temperature sensor channels 9-12
    *   Takes:   stFrame: The CAN frame to decode
    *            TRRTireChannel09: Rear Right Tire Temperature Channel 9
    *            TRRTireChannel10: Rear Right Tire Temperature Channel 10
    *            TRRTireChannel11: Rear Right Tire Temperature Channel 11
    *            TRRTireChannel12: Rear Right Tire Temperature Channel 12
    * 
    *   Returns: ESP_OK if successful, error code if not.
    * 
    *   Autogenerated by decodeCAN.py
    */
    if (stFrame.byDLC != 8)
    {
        return ESP_ERR_INVALID_SIZE;
    }
    if (stFrame.dwID != 0x20A) 
    {
        return ESP_ERR_INVALID_ARG;
    }
    *TRRTireChannel09 = (float)((((uint16_t)(stFrame.abData[0])) << 8) | ((uint16_t)(stFrame.abData[1]))) * 0.1f + -100.0f;
    *TRRTireChannel10 = (float)((((uint16_t)(stFrame.abData[2])) << 8) | ((uint16_t)(stFrame.abData[3]))) * 0.1f + -100.0f;
    *TRRTireChannel11 = (float)((((uint16_t)(stFrame.abData[4])) << 8) | ((uint16_t)(stFrame.abData[5]))) * 0.1f + -100.0f;
    *TRRTireChannel12 = (float)((((uint16_t)(stFrame.abData[6])) << 8) | ((uint16_t)(stFrame.abData[7]))) * 0.1f + -100.0f;
    return ESP_OK;
}

esp_err_t RRTireTemp4(CAN_frame_t stFrame, float* TRRTireChannel13, float* TRRTireChannel14, float* TRRTireChannel15, float* TRRTireChannel16)
{
    /*
    *===========================================================================
    *   RRTireTemp4
    *   Message: RRTireTemp4 (0x20B)
    *   Description: Rear Right Tire temperature sensor channels 13-16
    *   Takes:   stFrame: The CAN frame to decode
    *            TRRTireChannel13: Rear Right Tire Temperature Channel 13
    *            TRRTireChannel14: Rear Right Tire Temperature Channel 14
    *            TRRTireChannel15: Rear Right Tire Temperature Channel 15
    *            TRRTireChannel16: Rear Right Tire Temperature Channel 16
    * 
    *   Returns: ESP_OK if successful, error code if not.
    * 
    *   Autogenerated by decodeCAN.py
    */
    if (stFrame.byDLC != 8)
    {
        return ESP_ERR_INVALID_SIZE;
    }
    if (stFrame.dwID != 0x20B) 
    {
        return ESP_ERR_INVALID_ARG;
    }
    *TRRTireChannel13 = (float)((((uint16_t)(stFrame.abData[0])) << 8) | ((uint16_t)(stFrame.abData[1]))) * 0.1f + -100.0f;
    *TRRTireChannel14 = (float)((((uint16_t)(stFrame.abData[2])) << 8) | ((uint16_t)(stFrame.abData[3]))) * 0.1f + -100.0f;
    *TRRTireChannel15 = (float)((((uint16_t)(stFrame.abData[4])) << 8) | ((uint16_t)(stFrame.abData[5]))) * 0.1f + -100.0f;
    *TRRTireChannel16 = (float)((((uint16_t)(stFrame.abData[6])) << 8) | ((uint16_t)(stFrame.abData[7]))) * 0.1f + -100.0f;
    return ESP_OK;
}

esp_err_t RLTireTemp1(CAN_frame_t stFrame, float* TRLTireChannel01, float* TRLTireChannel02, float* TRLTireChannel03, float* TRLTireChannel04)
{
    /*
    *===========================================================================
    *   RLTireTemp1
    *   Message: RLTireTemp1 (0x20C)
    *   Description: Rear Left Tire temperature sensor channels 1-4
    *   Takes:   stFrame: The CAN frame to decode
    *            TRLTireChannel01: Rear Left Tire Temperature Channel 1
    *            TRLTireChannel02: Rear Left Tire Temperature Channel 2
    *            TRLTireChannel03: Rear Left Tire Temperature Channel 3
    *            TRLTireChannel04: Rear Left Tire Temperature Channel 4
    * 
    *   Returns: ESP_OK if successful, error code if not.
    * 
    *   Autogenerated by decodeCAN.py
    */
    if (stFrame.byDLC != 8)
    {
        return ESP_ERR_INVALID_SIZE;
    }
    if (stFrame.dwID != 0x20C) 
    {
        return ESP_ERR_INVALID_ARG;
    }
    *TRLTireChannel01 = (float)((((uint16_t)(stFrame.abData[0])) << 8) | ((uint16_t)(stFrame.abData[1]))) * 0.1f + -100.0f;
    *TRLTireChannel02 = (float)((((uint16_t)(stFrame.abData[2])) << 8) | ((uint16_t)(stFrame.abData[3]))) * 0.1f + -100.0f;
    *TRLTireChannel03 = (float)((((uint16_t)(stFrame.abData[4])) << 8) | ((uint16_t)(stFrame.abData[5]))) * 0.1f + -100.0f;
    *TRLTireChannel04 = (float)((((uint16_t)(stFrame.abData[6])) << 8) | ((uint16_t)(stFrame.abData[7]))) * 0.1f + -100.0f;
    return ESP_OK;
}

esp_err_t RLTireTemp2(CAN_frame_t stFrame, float* TRLTireChannel05, float* TRLTireChannel06, float* TRLTireChannel07, float* TRLTireChannel08)
{
    /*
    *===========================================================================
    *   RLTireTemp2
    *   Message: RLTireTemp2 (0x20D)
    *   Description: Rear Left Tire temperature sensor channels 5-8
    *   Takes:   stFrame: The CAN frame to decode
    *            TRLTireChannel05: Rear Left Tire Temperature Channel 5
    *            TRLTireChannel06: Rear Left Tire Temperature Channel 6
    *            TRLTireChannel07: Rear Left Tire Temperature Channel 7
    *            TRLTireChannel08: Rear Left Tire Temperature Channel 8
    * 
    *   Returns: ESP_OK if successful, error code if not.
    * 
    *   Autogenerated by decodeCAN.py
    */
    if (stFrame.byDLC != 8)
    {
        return ESP_ERR_INVALID_SIZE;
    }
    if (stFrame.dwID != 0x20D) 
    {
        return ESP_ERR_INVALID_ARG;
    }
    *TRLTireChannel05 = (float)((((uint16_t)(stFrame.abData[0])) << 8) | ((uint16_t)(stFrame.abData[1]))) * 0.1f + -100.0f;
    *TRLTireChannel06 = (float)((((uint16_t)(stFrame.abData[2])) << 8) | ((uint16_t)(stFrame.abData[3]))) * 0.1f + -100.0f;
    *TRLTireChannel07 = (float)((((uint16_t)(stFrame.abData[4])) << 8) | ((uint16_t)(stFrame.abData[5]))) * 0.1f + -100.0f;
    *TRLTireChannel08 = (float)((((uint16_t)(stFrame.abData[6])) << 8) | ((uint16_t)(stFrame.abData[7]))) * 0.1f + -100.0f;
    return ESP_OK;
}

esp_err_t RLTireTemp3(CAN_frame_t stFrame, float* TRLTireChannel09, float* TRLTireChannel10, float* TRLTireChannel11, float* TRLTireChannel12)
{
    /*
    *===========================================================================
    *   RLTireTemp3
    *   Message: RLTireTemp3 (0x20E)
    *   Description: Rear Left Tire temperature sensor channels 9-12
    *   Takes:   stFrame: The CAN frame to decode
    *            TRLTireChannel09: Rear Left Tire Temperature Channel 9
    *            TRLTireChannel10: Rear Left Tire Temperature Channel 10
    *            TRLTireChannel11: Rear Left Tire Temperature Channel 11
    *            TRLTireChannel12: Rear Left Tire Temperature Channel 12
    * 
    *   Returns: ESP_OK if successful, error code if not.
    * 
    *   Autogenerated by decodeCAN.py
    */
    if (stFrame.byDLC != 8)
    {
        return ESP_ERR_INVALID_SIZE;
    }
    if (stFrame.dwID != 0x20E) 
    {
        return ESP_ERR_INVALID_ARG;
    }
    *TRLTireChannel09 = (float)((((uint16_t)(stFrame.abData[0])) << 8) | ((uint16_t)(stFrame.abData[1]))) * 0.1f + -100.0f;
    *TRLTireChannel10 = (float)((((uint16_t)(stFrame.abData[2])) << 8) | ((uint16_t)(stFrame.abData[3]))) * 0.1f + -100.0f;
    *TRLTireChannel11 = (float)((((uint16_t)(stFrame.abData[4])) << 8) | ((uint16_t)(stFrame.abData[5]))) * 0.1f + -100.0f;
    *TRLTireChannel12 = (float)((((uint16_t)(stFrame.abData[6])) << 8) | ((uint16_t)(stFrame.abData[7]))) * 0.1f + -100.0f;
    return ESP_OK;
}

esp_err_t RLTireTemp4(CAN_frame_t stFrame, float* TRLTireChannel13, float* TRLTireChannel14, float* TRLTireChannel15, float* TRLTireChannel16)
{
    /*
    *===========================================================================
    *   RLTireTemp4
    *   Message: RLTireTemp4 (0x20F)
    *   Description: Rear Left Tire temperature sensor channels 13-16
    *   Takes:   stFrame: The CAN frame to decode
    *            TRLTireChannel13: Rear Left Tire Temperature Channel 13
    *            TRLTireChannel14: Rear Left Tire Temperature Channel 14
    *            TRLTireChannel15: Rear Left Tire Temperature Channel 15
    *            TRLTireChannel16: Rear Left Tire Temperature Channel 16
    * 
    *   Returns: ESP_OK if successful, error code if not.
    * 
    *   Autogenerated by decodeCAN.py
    */
    if (stFrame.byDLC != 8)
    {
        return ESP_ERR_INVALID_SIZE;
    }
    if (stFrame.dwID != 0x20F) 
    {
        return ESP_ERR_INVALID_ARG;
    }
    *TRLTireChannel13 = (float)((((uint16_t)(stFrame.abData[0])) << 8) | ((uint16_t)(stFrame.abData[1]))) * 0.1f + -100.0f;
    *TRLTireChannel14 = (float)((((uint16_t)(stFrame.abData[2])) << 8) | ((uint16_t)(stFrame.abData[3]))) * 0.1f + -100.0f;
    *TRLTireChannel15 = (float)((((uint16_t)(stFrame.abData[4])) << 8) | ((uint16_t)(stFrame.abData[5]))) * 0.1f + -100.0f;
    *TRLTireChannel16 = (float)((((uint16_t)(stFrame.abData[6])) << 8) | ((uint16_t)(stFrame.abData[7]))) * 0.1f + -100.0f;
    return ESP_OK;
}

esp_err_t InverterData1(CAN_frame_t stFrame, int32_t* ERPM, float* DutyCycle, int16_t* InputVoltage)
{
    /*
    *===========================================================================
    *   InverterData1
    *   Message: InverterData1 (0x404)
    *   Description: GenData 1 - ERPM, Duty, Input Voltage
    *   Takes:   stFrame: The CAN frame to decode
    *            ERPM: ERPM = Motor RPM * number of motor pole pairs
    *            DutyCycle: Controller Duty Cycle, +ve = running -ve = regenerating
    *            InputVoltage: Input voltage DC voltage
    * 
    *   Returns: ESP_OK if successful, error code if not.
    * 
    *   Autogenerated by decodeCAN.py
    */
    if (stFrame.byDLC != 8)
    {
        return ESP_ERR_INVALID_SIZE;
    }
    if (stFrame.dwID != 0x404) 
    {
        return ESP_ERR_INVALID_ARG;
    }
    *ERPM = (int32_t)((((uint32_t)(stFrame.abData[0])) << 24) | (((uint32_t)(stFrame.abData[1])) << 16) | (((uint32_t)(stFrame.abData[2])) << 8) | ((uint32_t)(stFrame.abData[3])));
    *DutyCycle = (float)((((uint16_t)(stFrame.abData[4])) << 8) | ((uint16_t)(stFrame.abData[5]))) * 0.1f;
    *InputVoltage = (int16_t)((((uint16_t)(stFrame.abData[6])) << 8) | ((uint16_t)(stFrame.abData[7])));
    return ESP_OK;
}

esp_err_t InverterData2(CAN_frame_t stFrame, float* ACCurrent, float* DCCurrent)
{
    /*
    *===========================================================================
    *   InverterData2
    *   Message: InverterData2 (0x424)
    *   Description: GenData 2 - AC Current, DC Current
    *   Takes:   stFrame: The CAN frame to decode
    *            ACCurrent: The Motor current +ve = running, -ve = regenerating
    *            DCCurrent: Current on the DC Side, Motor where +ve = running, -ve = regen
    * 
    *   Returns: ESP_OK if successful, error code if not.
    * 
    *   Autogenerated by decodeCAN.py
    */
    if (stFrame.byDLC != 8)
    {
        return ESP_ERR_INVALID_SIZE;
    }
    if (stFrame.dwID != 0x424) 
    {
        return ESP_ERR_INVALID_ARG;
    }
    *ACCurrent = (float)((((uint16_t)(stFrame.abData[0])) << 8) | ((uint16_t)(stFrame.abData[1]))) * 0.1f;
    *DCCurrent = (float)((((uint16_t)(stFrame.abData[2])) << 8) | ((uint16_t)(stFrame.abData[3]))) * 0.1f;
    return ESP_OK;
}

esp_err_t InverterData3(CAN_frame_t stFrame, float* ControllerTemperature, float* MotorTemperature, uint8_t* FaultCode)
{
    /*
    *===========================================================================
    *   InverterData3
    *   Message: InverterData3 (0x444)
    *   Description: GenData 3 - Controller Temp., Motor temp., Fault code
    *   Takes:   stFrame: The CAN frame to decode
    *            ControllerTemperature: Temperature of the inverter semicondcutors
    *            MotorTemperature: Temperature of the motor measured by the inverter
    *            FaultCode: See Comment for list of codes
    * 
    *   Returns: ESP_OK if successful, error code if not.
    * 
    *   Autogenerated by decodeCAN.py
    */
    if (stFrame.byDLC != 8)
    {
        return ESP_ERR_INVALID_SIZE;
    }
    if (stFrame.dwID != 0x444) 
    {
        return ESP_ERR_INVALID_ARG;
    }
    *ControllerTemperature = (float)((((uint16_t)(stFrame.abData[0])) << 8) | ((uint16_t)(stFrame.abData[1]))) * 0.1f;
    *MotorTemperature = (float)((((uint16_t)(stFrame.abData[2])) << 8) | ((uint16_t)(stFrame.abData[3]))) * 0.1f;
    *FaultCode = (uint8_t)((stFrame.abData[4]));
    return ESP_OK;
}

esp_err_t InverterData4(CAN_frame_t stFrame, float* Id, float* Iq)
{
    /*
    *===========================================================================
    *   InverterData4
    *   Message: InverterData4 (0x464)
    *   Description: GenData 4 - ID, Iq values
    *   Takes:   stFrame: The CAN frame to decode
    *            Id: FOC algorithm component Id
    *            Iq: FOC algorithm component Iq
    * 
    *   Returns: ESP_OK if successful, error code if not.
    * 
    *   Autogenerated by decodeCAN.py
    */
    if (stFrame.byDLC != 8)
    {
        return ESP_ERR_INVALID_SIZE;
    }
    if (stFrame.dwID != 0x464) 
    {
        return ESP_ERR_INVALID_ARG;
    }
    *Id = (float)((((uint32_t)(stFrame.abData[0])) << 24) | (((uint32_t)(stFrame.abData[1])) << 16) | (((uint32_t)(stFrame.abData[2])) << 8) | ((uint32_t)(stFrame.abData[3]))) * 0.001f;
    *Iq = (float)((((uint32_t)(stFrame.abData[4])) << 24) | (((uint32_t)(stFrame.abData[5])) << 16) | (((uint32_t)(stFrame.abData[6])) << 8) | ((uint32_t)(stFrame.abData[7]))) * 0.001f;
    return ESP_OK;
}

esp_err_t InverterData5(CAN_frame_t stFrame, int8_t* ThrottleSignal, int8_t* BrakeSignal, uint8_t* DigitalIn1, uint8_t* DigitalIn2, uint8_t* DigitalIn3, uint8_t* DigitalIn4, uint8_t* DigitalOut1, uint8_t* DigitalOut2, uint8_t* DigitalOut3, uint8_t* DigitalOut4, uint8_t* DriveEnable, uint8_t* CapacitorTempLimit, uint8_t* DCCurrentLimit, uint8_t* DriveEnableLimit, uint8_t* IGBTAccelerationLimit, uint8_t* IGBTTemperatureLimit, uint8_t* InputVoltageLimit, uint8_t* TempAccelThrottle, uint8_t* MotorTemperatureLimit, uint8_t* RPMminlimit, uint8_t* RPMMaxlimit, uint8_t* Powerlimit, uint8_t* CANmapversion)
{
    /*
    *===========================================================================
    *   InverterData5
    *   Message: InverterData5 (0x484)
    *   Description: GenData 5 -  Throttle Sig., Brake Sig., Digi I/O, Drive Enable, Limit Status Bits, CAN Map version
    *   Takes:   stFrame: The CAN frame to decode
    *            ThrottleSignal: Throttle signal derrived from analog inputs or CAN2
    *            BrakeSignal: Brake Signal derrived frm analog inputs or CAN2
    *            DigitalIn1: 1 : Digital Input is active, 0 : Digital input is inactive
    *            DigitalIn2: 
    *            DigitalIn3: 
    *            DigitalIn4: 
    *            DigitalOut1: 1 : Digital output is active, 0 : Digital output is inactive
    *            DigitalOut2: 
    *            DigitalOut3: 
    *            DigitalOut4: 
    *            DriveEnable: 1 : Drive enabled, 0 : Drive Disabled, can be enabled/disabled by the digital input and/or via CAN2
    *            CapacitorTempLimit: 1 : Cap temp limit active, 0 : Inactive, inverter can limit output power to not overheat internal capacitors (HW V3.6 or newer)
    *            DCCurrentLimit: 1 : DC Current limit active, 0 : Inactive
    *            DriveEnableLimit: 1 : Drive enable limit active, 0 : Inactive
    *            IGBTAccelerationLimit: 1 : Drive enable limit active, 0 : Inactive
    *            IGBTTemperatureLimit: 1 : Active, 0 : Inactive
    *            InputVoltageLimit: 1 : Active, 0 : inactive
    *            TempAccelThrottle: 1 : Active, 0 : inactive
    *            MotorTemperatureLimit: 1 : Active, 0 : inactive
    *            RPMminlimit: 1 : Active, 0 : inactive
    *            RPMMaxlimit: 1 : Active, 0 : inactive
    *            Powerlimit: 1 : Active, 0 : inactive
    *            CANmapversion: Example, 23 -> (V2,3)
    * 
    *   Returns: ESP_OK if successful, error code if not.
    * 
    *   Autogenerated by decodeCAN.py
    */
    if (stFrame.byDLC != 8)
    {
        return ESP_ERR_INVALID_SIZE;
    }
    if (stFrame.dwID != 0x484) 
    {
        return ESP_ERR_INVALID_ARG;
    }
    *ThrottleSignal = (int8_t)((stFrame.abData[0]));
    *BrakeSignal = (int8_t)((stFrame.abData[1]));
    *DigitalIn1 = (uint8_t)(((stFrame.abData[2]) & 0x1));
    *DigitalIn2 = (uint8_t)(((stFrame.abData[2] >> 1) & 0x1));
    *DigitalIn3 = (uint8_t)(((stFrame.abData[2] >> 2) & 0x1));
    *DigitalIn4 = (uint8_t)(((stFrame.abData[2] >> 3) & 0x1));
    *DigitalOut1 = (uint8_t)(((stFrame.abData[2] >> 4) & 0x1));
    *DigitalOut2 = (uint8_t)(((stFrame.abData[2] >> 5) & 0x1));
    *DigitalOut3 = (uint8_t)(((stFrame.abData[2] >> 6) & 0x1));
    *DigitalOut4 = (uint8_t)(((stFrame.abData[2] >> 7) & 0x1));
    *DriveEnable = (uint8_t)((stFrame.abData[3]));
    *CapacitorTempLimit = (uint8_t)(((stFrame.abData[4]) & 0x1));
    *DCCurrentLimit = (uint8_t)(((stFrame.abData[4] >> 1) & 0x1));
    *DriveEnableLimit = (uint8_t)(((stFrame.abData[4] >> 2) & 0x1));
    *IGBTAccelerationLimit = (uint8_t)(((stFrame.abData[4] >> 3) & 0x1));
    *IGBTTemperatureLimit = (uint8_t)(((stFrame.abData[4] >> 4) & 0x1));
    *InputVoltageLimit = (uint8_t)(((stFrame.abData[4] >> 5) & 0x1));
    *TempAccelThrottle = (uint8_t)(((stFrame.abData[4] >> 6) & 0x1));
    *MotorTemperatureLimit = (uint8_t)(((stFrame.abData[4] >> 7) & 0x1));
    *RPMminlimit = (uint8_t)(((stFrame.abData[5]) & 0x1));
    *RPMMaxlimit = (uint8_t)(((stFrame.abData[5] >> 1) & 0x1));
    *Powerlimit = (uint8_t)(((stFrame.abData[5] >> 2) & 0x1));
    *CANmapversion = (uint8_t)((stFrame.abData[7]));
    return ESP_OK;
}

esp_err_t CellVoltages1(CAN_frame_t stFrame, uint8_t* NCellID, float* VCell, float* RCellInternal, float* VCellOC, uint8_t* Checksum)
{
    /*
    *===========================================================================
    *   CellVoltages1
    *   Message: CellVoltages1 (0x6A0)
    *   Description: All cell voltages from BMS
    *   Takes:   stFrame: The CAN frame to decode
    *            NCellID: Cell ID
    *            VCell: Cell instant voltage
    *            RCellInternal: Cell internal resistance
    *            VCellOC: Cell open circuit voltage
    *            Checksum: 
    * 
    *   Returns: ESP_OK if successful, error code if not.
    * 
    *   Autogenerated by decodeCAN.py
    */
    if (stFrame.byDLC != 8)
    {
        return ESP_ERR_INVALID_SIZE;
    }
    if (stFrame.dwID != 0x6A0) 
    {
        return ESP_ERR_INVALID_ARG;
    }
    *NCellID = (uint8_t)((stFrame.abData[0]));
    *VCell = (float)((((uint16_t)(stFrame.abData[1])) << 8) | ((uint16_t)(stFrame.abData[2]))) * 0.0001f;
    *RCellInternal = (float)((((uint16_t)(stFrame.abData[3])) << 8) | ((uint16_t)(stFrame.abData[4]))) * 1e-05f;
    *VCellOC = (float)((((uint16_t)(stFrame.abData[5])) << 8) | ((uint16_t)(stFrame.abData[6]))) * 0.0001f;
    *Checksum = (uint8_t)((stFrame.abData[7]));
    return ESP_OK;
}

esp_err_t BMSData1(CAN_frame_t stFrame, float* IPack, float* VPack, uint8_t* rPackSOC, uint16_t* NRelayState, float* Checksum)
{
    /*
    *===========================================================================
    *   BMSData1
    *   Message: BMSData1 (0x6B0)
    *   Description: BMS Data Message
    *   Takes:   stFrame: The CAN frame to decode
    *            IPack: Pack current
    *            VPack: Pack instant voltage
    *            rPackSOC: State of Charge, How much energy remains in the battery
    *            NRelayState: Active State of BMS Outputs and Inputs
    *            Checksum: 
    * 
    *   Returns: ESP_OK if successful, error code if not.
    * 
    *   Autogenerated by decodeCAN.py
    */
    if (stFrame.byDLC != 8)
    {
        return ESP_ERR_INVALID_SIZE;
    }
    if (stFrame.dwID != 0x6B0) 
    {
        return ESP_ERR_INVALID_ARG;
    }
    *IPack = (float)((((uint16_t)(stFrame.abData[0])) << 8) | ((uint16_t)(stFrame.abData[1]))) * 0.1f;
    *VPack = (float)((((uint16_t)(stFrame.abData[2])) << 8) | ((uint16_t)(stFrame.abData[3]))) * 0.1f;
    *rPackSOC = (uint8_t)((stFrame.abData[4]));
    *NRelayState = (uint16_t)((((uint16_t)(stFrame.abData[5])) << 8) | ((uint16_t)(stFrame.abData[6])));
    *Checksum = (float)((stFrame.abData[7])) + 1720.0f;
    return ESP_OK;
}

esp_err_t BMSData2(CAN_frame_t stFrame, uint16_t* IPackDischargeLimit, uint8_t* THigh, uint8_t* LowTemperature, float* Checksum)
{
    /*
    *===========================================================================
    *   BMSData2
    *   Message: BMSData2 (0x6B1)
    *   Description: BMS Data Message
    *   Takes:   stFrame: The CAN frame to decode
    *            IPackDischargeLimit: Discharge Current Limit ? (Amps)
    *            THigh: ??????
    *            LowTemperature: ??????
    *            Checksum: 
    * 
    *   Returns: ESP_OK if successful, error code if not.
    * 
    *   Autogenerated by decodeCAN.py
    */
    if (stFrame.byDLC != 8)
    {
        return ESP_ERR_INVALID_SIZE;
    }
    if (stFrame.dwID != 0x6B1) 
    {
        return ESP_ERR_INVALID_ARG;
    }
    *IPackDischargeLimit = (uint16_t)((((uint16_t)(stFrame.abData[0])) << 8) | ((uint16_t)(stFrame.abData[1])));
    *THigh = (uint8_t)((stFrame.abData[4]));
    *LowTemperature = (uint8_t)((stFrame.abData[5]));
    *Checksum = (float)((stFrame.abData[7])) + 1721.0f;
    return ESP_OK;
}

esp_err_t PackVoltage(CAN_frame_t stFrame, float* VPackOpenCircuit, float* VPackMax, float* VPackMin, float* VBMSSupply12V)
{
    /*
    *===========================================================================
    *   PackVoltage
    *   Message: Pack Voltage (0x6B2)
    *   Description: Pack Voltages from BMS
    *   Takes:   stFrame: The CAN frame to decode
    *            VPackOpenCircuit: Battery pack open circuit voltage
    *            VPackMax: Battery pack maximum voltage
    *            VPackMin: Battery pack minimum voltage
    *            VBMSSupply12V: BMS Supply Voltage 12V
    * 
    *   Returns: ESP_OK if successful, error code if not.
    * 
    *   Autogenerated by decodeCAN.py
    */
    if (stFrame.byDLC != 8)
    {
        return ESP_ERR_INVALID_SIZE;
    }
    if (stFrame.dwID != 0x6B2) 
    {
        return ESP_ERR_INVALID_ARG;
    }
    *VPackOpenCircuit = (float)((((uint16_t)(stFrame.abData[0])) << 8) | ((uint16_t)(stFrame.abData[1]))) * 0.01f;
    *VPackMax = (float)((((uint16_t)(stFrame.abData[2])) << 8) | ((uint16_t)(stFrame.abData[3]))) * 0.01f;
    *VPackMin = (float)((((uint16_t)(stFrame.abData[4])) << 8) | ((uint16_t)(stFrame.abData[5]))) * 0.01f;
    *VBMSSupply12V = (float)((((uint16_t)(stFrame.abData[6])) << 8) | ((uint16_t)(stFrame.abData[7]))) * 0.001f;
    return ESP_OK;
}

esp_err_t PackTemperature(CAN_frame_t stFrame, float* TPackHigh, float* TPackLow, float* TPackAvg, float* TBMSInternal)
{
    /*
    *===========================================================================
    *   PackTemperature
    *   Message: Pack Temperature (0x6B3)
    *   Description: Pack Temperatures from BMS
    *   Takes:   stFrame: The CAN frame to decode
    *            TPackHigh: High pack temperature
    *            TPackLow: Low pack temperature
    *            TPackAvg: Average pack temperature
    *            TBMSInternal: Internal BMS temperature
    * 
    *   Returns: ESP_OK if successful, error code if not.
    * 
    *   Autogenerated by decodeCAN.py
    */
    if (stFrame.byDLC != 8)
    {
        return ESP_ERR_INVALID_SIZE;
    }
    if (stFrame.dwID != 0x6B3) 
    {
        return ESP_ERR_INVALID_ARG;
    }
    *TPackHigh = (float)((((uint16_t)(stFrame.abData[0])) << 8) | ((uint16_t)(stFrame.abData[1]))) * 0.005f;
    *TPackLow = (float)((((uint16_t)(stFrame.abData[2])) << 8) | ((uint16_t)(stFrame.abData[3]))) * 0.005f;
    *TPackAvg = (float)((((uint16_t)(stFrame.abData[4])) << 8) | ((uint16_t)(stFrame.abData[5]))) * 0.005f;
    *TBMSInternal = (float)((((uint16_t)(stFrame.abData[6])) << 8) | ((uint16_t)(stFrame.abData[7]))) * 0.005f;
    return ESP_OK;
}

esp_err_t CellVoltages2(CAN_frame_t stFrame, float* VCellLow, float* VCellHigh, float* VCellAvg, float* VCellLowOC)
{
    /*
    *===========================================================================
    *   CellVoltages2
    *   Message: CellVoltages2 (0x6B4)
    *   Description: ID Reserved for BMS
    *   Takes:   stFrame: The CAN frame to decode
    *            VCellLow: Low cell voltage
    *            VCellHigh: High cell voltage
    *            VCellAvg: Average Cell voltage
    *            VCellLowOC: Low cell voltage (open circuit)
    * 
    *   Returns: ESP_OK if successful, error code if not.
    * 
    *   Autogenerated by decodeCAN.py
    */
    if (stFrame.byDLC != 8)
    {
        return ESP_ERR_INVALID_SIZE;
    }
    if (stFrame.dwID != 0x6B4) 
    {
        return ESP_ERR_INVALID_ARG;
    }
    *VCellLow = (float)((((uint16_t)(stFrame.abData[0])) << 8) | ((uint16_t)(stFrame.abData[1]))) * 0.0001f;
    *VCellHigh = (float)((((uint16_t)(stFrame.abData[2])) << 8) | ((uint16_t)(stFrame.abData[3]))) * 0.0001f;
    *VCellAvg = (float)((((uint16_t)(stFrame.abData[4])) << 8) | ((uint16_t)(stFrame.abData[5]))) * 0.0001f;
    *VCellLowOC = (float)((((uint16_t)(stFrame.abData[6])) << 8) | ((uint16_t)(stFrame.abData[7]))) * 0.0001f;
    return ESP_OK;
}

esp_err_t CellVoltages3(CAN_frame_t stFrame, float* VCellHighOC, float* VCellAvgOC, float* VCellMaximum, float* VCellMinimum, uint8_t* NVCellMaxID, uint8_t* NVCellMinID)
{
    /*
    *===========================================================================
    *   CellVoltages3
    *   Message: CellVoltages3 (0x6B5)
    *   Description: ID Reserved for BMS
    *   Takes:   stFrame: The CAN frame to decode
    *            VCellHighOC: High cell voltage (open circuit)
    *            VCellAvgOC: Average cell voltage (open circuit)
    *            VCellMaximum: Maximum cell voltage
    *            VCellMinimum: Minimum cell voltage
    *            NVCellMaxID: Location of cell at max voltage
    *            NVCellMinID: Location of cell at min voltage
    * 
    *   Returns: ESP_OK if successful, error code if not.
    * 
    *   Autogenerated by decodeCAN.py
    */
    if (stFrame.byDLC != 8)
    {
        return ESP_ERR_INVALID_SIZE;
    }
    if (stFrame.dwID != 0x6B5) 
    {
        return ESP_ERR_INVALID_ARG;
    }
    *VCellHighOC = (float)((((uint16_t)(stFrame.abData[0])) << 8) | ((uint16_t)(stFrame.abData[1]))) * 0.0001f;
    *VCellAvgOC = (float)((((uint16_t)(stFrame.abData[2])) << 8) | ((uint16_t)(stFrame.abData[3]))) * 0.0001f;
    *VCellMaximum = (float)((stFrame.abData[4])) * 0.02f;
    *VCellMinimum = (float)((stFrame.abData[5])) * 0.02f;
    *NVCellMaxID = (uint8_t)((stFrame.abData[6]));
    *NVCellMinID = (uint8_t)((stFrame.abData[7]));
    return ESP_OK;
}

